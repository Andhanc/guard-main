{
  "nextId": 67,
  "documents": [
    {
      "id": 1,
      "title": "МиИСБП_ПР1_314302_ФурсовАВ",
      "author": "Furs Art Val",
      "filename": "МиИСБП_ПР1_314302_ФурсовАВ.pdf",
      "filePath": "data/uploads/1764173927005_МиИСБП_ПР1_314302_ФурсовАВ.pdf",
      "content": "Министерство образования Республики Беларусь Учреждение образования БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ Факультет компьютерного проектирования Кафедра проектирования информационно - компьютерных систем Дисциплина Методы и инструментальные средства бизнес - планирования Отчет по практической работе №1 на тему: « РАЗРАБОТКА БИЗНЕС - ИДЕИ. ФОРМИРОВАНИЕ ОБРАЗА НОВОГО ПРОДУКТА » Выполнил: Фурсов А . В . (подпись) гр. 314302 Проверил: Левченя Ж.Б (подпись) Минск 2025 1 ГЕНЕРИРОВАНИЕ БИЗНЕС - ИДЕИ 1.1 Ф ормализация бизнес - идей проектов Генерирование идей – это творческий процесс, направленный на поиск решений проблем потребителей и выявление новых рыночных возможностей. Этот процесс может быть эффективно инициирован с помощью метода брейншторминга. На этапе брейншторминга была сгенерирована несколько потенциальных бизнес - идей, основанных на актуальных потребностях рынка. Все идеи были записаны и систематизированы в лист активности Brainstorming, представленный в таблице 1.1, что позволило не только з афиксировать предложения, но и предварительно отсортировать их. Таблица 1.1 − Лист активности мозгового штурма № п/п Все идеи для бизнеса № п/п Рабочие идеи 1 Платформа для аренды личных вещей (одежда, техника, книги) 1 Приложение для управления здоровьем с помощью AI 2 Онлайн - услуга по подбору персональных подарков 2 Платформа для аренды объектов искусства 3 Приложение для управления здоровьем с помощью AI 3 Платформа для обмена знаниями и навыками 4 Платформа для обмена знаниями и навыками (в т.ч. обучение языкам) 5 Платформа для аренды объектов искусства (в т.ч. виртуальные туры) Анализ рабочих идей позволил выявить сильные и слабые стороны каждой идеи, что является важным шагом на пути к выбору наиболее перспективного проекта. Анализ рабочих бизнес - идей представлен в таблице 1.2. Таблица 1.2 − Анализ рабочих бизнес - идей Бизнес - идеи Плюсы Минусы Приложение для управления здоровьем с помощью AI - Актуальность: растущий интерес к здоровому образу жизни. - Удобство для клиентов: консультации в любое время и в любом месте. - Модель монетизации \"по подписке\": регулярный доход. - Персонализированный подход: возможность создания индивидуальных программ. - Высокая конкуренция с традиционными врачами. - Риски недостаточной квалификации консультантов. - Зависимость от точности диагностики: ошибки могут привести к неприятным последствиям. Бизнес - идеи Плюсы Минусы Платформа для аренды объектов искусства - Уникальная ниша: возможность арендовать произведения искусства для бизнеса или дома. - Повышение доступности искусства для широких слоев населения. - Создание партнерских отношений с художниками и галереями. - Узкая аудитория: интерес к аренде искусства ограничен. - Логистика и страховка: требуется обеспечение сохранности объектов и организация доставки. - Необходимость поддержания постоянного потока произведений. Платформа для обмена знаниями и навыками - Образование для всех: любой человек может передавать свои знания. - Возможность монетизации контента: пользователи могут продавать свои курсы. - Простота запуска: начальный этап можно реализовать без больших вложений. - Гибкость для пользователей. - Сезонность спроса: пик активности в теплое время года и праздники. - Конкуренция с классическими гидами. - Необходимость в постоянном создании нового контента. - Зависимость от местоположения и языка. Для наглядной систематизации и формализации проанализированных концепций была составлена карта бизнес - идей. В таблице 1.3 раскрывается суть каждой идеи, а также проблема или потребность, которая лежит в её основе. Таблица 1.3 − Карта бизнес - идей № п/п Название бизнес - идеи Источник зарождения идеи (проблема, потребность, возможность) Суть идеи 1 Приложение для управления здоровьем с помощью AI 1 Проблема: Традиционные консультации у врачей могут быть дорогостоящими и неудобными. 2 Потребность: Желание иметь доступ к консультациям по здоровью и фитнесу в любое время. 3 Возможность: Развитие телемедицины и AI - технологий. Создание мобильного приложения, которое предоставляет онлайн - консультации с врачами, тренерами, диетологами, используя AI для персонализации советов. 2 Платформа для аренды объектов искусства 1 Проблема: Доступ к искусству ограничен, а покупка картин – серьезные финансовые вложения. 2 Потребность: В удобном и доступном способе наслаждаться искусством без его покупки. 3 Возможность: Рост экономики совместного потребления Создание платформы, которая позволяет арендовать картины, скульптуры и другие объекты искусства для домов, офисов и публичных мест. 3 Платформа для обмена знаниями и навыками 1 Проблема: Ограниченные возможности для получения практических знаний и навыков. 2 Потребность: В доступных образовательных курсах и мастер - классах. 3 Возможность: Рост популярности онлайн - обучения и фриланса. Создание платформы, на которой пользователи могут делиться знаниями, проводить мастер - классы, курсы и тренинги по разнообразным темам. 1.2 В ыбор наилучшей бизнес - идеи для разработки и реализации проекта на основе проведения рейтинговой оценки Для удобства дальнейшего анализа и проведения расчетов каждой из трех рассматриваемых бизнес - идей был присвоен уникальный идентификатор, как показано в таблице 1.4. Таблица 1. 4 − Идентификация бизнес - идей проекта Идентификатор бизнес - идеи Название бизнес - идеи проекта БИП - 1 Приложение для управления здоровьем с помощью AI БИП - 2 Платформа для аренды объектов искусства БИП - 3 Платформа для обмена знаниями и навыками Процесс выбора наиболее перспективного проекта осуществлялся на основе системы рейтинговой оценки. Каждая идея была оценена по ряду критериев, имеющих разный вес. Детальные расчеты и итоговые баллы приведены в таблице 1.5. Таблица 1. 5 − Система рейтинговой оценки бизнес - идей проектов Критерии оценки Оценка общей важности критериев (0 - 1) Бизнес - идеи проектов БИП - 1 БИП - 2 БИП - 3 Оценка частной важности критериев, баллы (1 - 100) (2х3) (1 - 100) (2х5) (1 - 100) (2х7) Уникальность 0.10 75 7.5 90 9.0 75 7.5 Реализуемость 0.25 60 15.0 65 16.25 70 17.5 Эффективность (полезность) 0.15 80 12.0 70 10.5 90 13.5 Конкурентоспособность 0.15 50 7.5 60 9.0 65 9.75 Рыночный потенциал 0.20 75 15.0 50 10.0 85 17.0 Масштабируемость 0.10 65 6.5 60 6.0 85 8.5 Риски 0.05 50 2.5 30 1.5 60 3.0 ИТОГО: 1.00 66.00 62.25 76.75 По результатам рейтинговой оценки, бизнес - идея БИП - 3 «Платформа для обмена знаниями и навыками» одержала победу, набрав 76.75 балла. Этот проект показал наилучшие результаты благодаря высоким показателям рыночного потенциала, полезности и масштабируемости при умеренных рисках. На втором месте оказалось БИП - 1 «Приложение для управления здоровьем с помощью AI» с результатом 66.00 баллов, а БИП - 2 «Платформа для аренды объектов искусства» набрала 62.25 балла. Таким образом, для дальнейшей разработки и реализации в рамках проекта была выбрана бизнес - идея БИП - 3. 1.3 Х арактеристика выбранной наилучшей бизнес - идеи проекта На основе проведенной рейтинговой оценки была выбрана наиболее перспективная бизнес - идея, которая и станет основой для дальнейшей разработки проекта. Ниже представлена ее детальная характеристика. Основная цель бизнес - идеи: Ключевая цель проекта заключается в создании децентрализованной онлайн - платформы, которая позволит пользователям обмениваться практическими знаниями и навыками. Проект направлен на формирование среды, где любой человек может выст упать как в роли ученика, так и в роли наставника, монетизируя свои компетенции. Новизна идеи проекта: Инновационность проекта проявляется в объединении механик образовательной платформы, социального сервиса и маркетплейса. В отличие от традиционных онлайн - школ с фиксированным преподавательским составом, данная концепция предполагает с оздание открытой экосистемы. Новизна заключается в низком пороге входа для создателей контента и разнообразии форматов взаимодействия (от полноценных курсов до разовых консультаций и мастер - классов). Обоснование актуальности бизнес - идеи: Актуальность проекта обусловлена несколькими современными трендами. Во - первых, растет спрос на непрерывное обучение (lifelong learning) и получение узкоспециализированных, прикладных навыков. Во - вторых, развитие «гиг - э кономики» мотивирует людей искать дополнительные источники дохода, в том числе через монетизацию своих увлечений и профессионального опыта. Платформа отвечает на запрос общества в гибком, доступном и персонализированном образовании. Отличительные черты бизнес - идеи: − Демократизация знаний: Возможность для любого пользователя стать преподавателем. − Широкий спектр тем: От IT и бизнеса до кулинарии, музыки и ремесел. − Гибкие форматы: Поддержка видеокурсов, вебинаров, индивидуальных сессий и воркшопов. − Социальная составляющая: Встроенные системы рейтингов, отзывов и прямого общения для формирования доверия и сообщества. Способ реализации бизнес - идеи: Реализация проекта предполагает разработку кроссплатформенного решения, включающего веб - сайт и мобильные приложения для iOS и Android. На начальном этапе планируется запуск минимально жизнеспособного продукта (MVP), который б удет включать базовый функционал: регистрацию пользователей, создание и поиск предложений, систему бронирования и оплаты, а также профили с отзывами. Для всестороннего анализа выбранной бизнес - идеи были выделены её положительные стороны и потенциальные проблемы реализации в регионе. Данный анализ представлен в таблице 1.6. Таблица 1. 6 − Положительные стороны бизнес - идеи и возможные проблемы её реализации Положительные стороны бизнес - идеи Проблемы реализации бизнес - идеи Высокий потенциал масштабирования (географическое расширение, добавление новых категорий знаний). Проблема «курицы и яйца»: сложность привлечения первых преподавателей без аудитории и первых учеников без контента. Широкая целевая аудитория, включающая как желающих обучаться, так и специалистов, готовых делиться опытом. Обеспечение контроля качества: риск появления недобросовестных или некомпетентных преподавателей, необходимость введения сложной системы модерации и рейтингования. Гибкая модель монетизации (комиссия со сделок, подписка, плата за продвижение курсов). Высокая конкуренция на рынке онлайн - образования с крупными международными и локальными игроками ( Coursera , Skillbox , Udemy ). Низкий порог входа для создателей контента, что способствует генерации большого количества уникальных предложений. Техническая сложность реализации: необходимость создания надежной инфраструктуры для обработки платежей, видеостриминга и хранения данных. Создание сильного сообщества вокруг платформы, что повышает лояльность пользователей и стимулирует органический рост. Значительные затраты на маркетинг для привлечения обеих сторон рынка (преподавателей и учеников). 1.4 О писание бизнес - идеи проекта Для того чтобы более наглядно представить сущность проекта и его основные характеристики, бизнес - идея была формализована в виде таблицы 1.7. Эта структура помогает последовательно ответить на ключевые вопросы: какую проблему решает продукт, что он собой пр едставляет, на кого ориентирован и каким образом будет реализован. Таблица 1. 7 − Описание бизнес - идеи КАКАЯ БОЛЬ? (какую потребность удовлетворяет продукт?) ЧТО? (что представляет из себя продукт, услуга, работа?) 1. Недоступность узкоспециализированных знаний: Традиционное образование часто не успевает за рынком, а найти эксперта - практика в редкой нише (например, реставрация мебели или нейрографика) бывает сложно и дорого. 2. Сложность монетизации навыков: Множество талантливых людей обладают уникальными умениями, но не имеют простого инструмента для превращения их в источник дохода без создания собственного сайта, рекламы и системы оплат. 3. Потребность в гибком обучении: Пользователи ищут возможность учиться в удобное для себя время, по индивидуальному графику и в различных форматах, которые не всегда предлагают крупные образовательные платформы. 1. Онлайн - маркетплейс знаний: Цифровая площадка, которая соединяет людей, желающих научиться чему - то новому (учеников), с теми, кто готов поделиться своими знаниями и опытом (наставниками). 2. Конструктор образовательных продуктов: Сервис предлагает наставникам готовые инструменты для создания и продажи различных форматов обучения: от записанных видеокурсов и текстовых гайдов до проведения живых онлайн - семинаров и индивидуальных консультаций. КОМУ? (кому предназначен данный продукт, работа, услуга?) КАК? (как будет реализовываться данный продукт, работа, услуга?) 1. Наставникам и экспертам: Специалисты в любой области, фрилансеры, ремесленники, преподаватели и просто увлеченные люди, которые хотят систематизировать свои знания и получать за это вознаграждение. 2. Ученикам и энтузиастам: Люди всех возрастов, стремящиеся к саморазвитию, освоению нового хобби, получению конкретного прикладного навыка для работы или решения личных задач. 3. Компаниям и HR - отделам: Организации, заинтересованные в быстром и точечном обучении своих сотрудников у узкопрофильных специалистов - практиков. 1. Реализация через веб - платформу и мобильные приложения: Разработка интуитивно понятного сайта и приложений для iOS/Android, обеспечивающих удобный доступ ко всем функциям сервиса. 2. Механизм работы: Наставник регистрируется, создает профиль и размещает свои образовательные продукты. Ученик находит нужное предложение через систему поиска и фильтров, оплачивает его через безопасную внутреннюю систему, после чего получает доступ к мат ериалам или согласовывает время консультации. Платформа удерживает комиссию с каждой транзакции. 2 МОРФОЛОГИЧЕСКИЙ АНАЛИЗ Морфологический анализ – это инструмент систематического исследования, который позволяет деконструировать объект или идею на ключевые параметры и изучить все возможные комбинации их реализации. Цель этого метода – расширить область поиска новых решений и выявить нетривиальные, потенциально успешные концепции развития продукта. Морфологическая таблица для проекта «Платформа для обмена знаниями и навыками» представлена в таблице 2.1. В ней выделены основные параметры, определяющие архитектуру и стратегию платформы, а также предложены различные варианты их исполнения. Таблица 2.1 − Морфологическая таблица по описанию решения задачи о платформе для обмена знаниями Элемент / параметр Вариант 1 Вариант 2 Вариант 3 Вариант 4 Тип контента Профессиональ ные навыки ( IT , маркетинг, дизайн) Творческие и бытовые хобби (музыка, рисование, кулинария) Академические дисциплины (репетиторство) Soft skills (ораторское искусство, тайм - менеджмент ) Формат обучения Записанные видеокурсы Живые вебинары и мастер - классы Индивидуальные консультации (1 - на - 1) Текстовые материалы и гайды Модель монетизации Комиссия с каждой транзакции Месячная подписка за доступ к контенту Freemium (базовый доступ бесплатно, доп. функции платно) Платное продвижени е для наставников Основная аудитория Новички и любители Профессионалы (повышение квалификации) Корпоративные клиенты (B2B) Студенты и школьники Социальный компонент Рейтинги и отзывы Форум и тематические сообщества Совместные проекты и домашние задания Прямой мессенджер (ученик - наставник) Проведённый морфологический анализ позволил структурировать возможные варианты реализации платформы по обмену знаниями и рассмотреть её с точки зрения ключевых параметров: типа контента, формата обучения, целевой аудитории, модели монетизации и других факторов. Такой подход показал, что каждая комбинация параметров формирует уникальную стратегию развития проекта и определяет его рыночные перспективы. Вариант, обозначенный синей линией, представляет собой B2B - решение, ориентированное на интеграцию в системы корпоративного обучения. Для его успеха необходимы сильные навыки прямых продаж, умение работать с HR - отделами и руководством компаний, а также пони мание процессов внутрикорпоративного развития персонала. Концепция, обозначенная желтой линией, напротив, это классический B2C - продукт, нацеленный напрямую на конечного потребителя – широкую аудиторию людей, желающих освоить новое увлечение. Здесь на первый план выходят компетенции в области B2C - маркетинга, комьюнити - менед жмента и удержания пользовательского внимания в высококонкурентной среде. Подходы к рынку и монетизации также кардинально различаются. Синяя линия (B2B - платформа) нацелена на более узкий, но стабильный сектор корпоративных клиентов. Модель дохода здесь строится на Freemium - модели с последующим переходом на корпоративные подписки , что обеспечивает прогнозируемый денежный поток, но ограничивает потенциальный рост количеством компаний на рынке. Желтая линия (B2C - платформа) ориентирована на обширный и глобальный потребительский рынок. Монетизация через комиссию с транзакций подразуме вает привлечение огромной аудитории для получения прибыли, что менее предсказуемо, но при успехе открывает доступ к значительно большему финансовому потенциалу. Таким образом, выбор между концепциями сводится к выбору стратегии. Синяя линия – это путь к созданию устойчивого нишевого бизнеса с понятной экономикой в краткосрочной перспективе, который решает проблему точечного обучения сотрудников. Желтая линия – это более рискованная, но и более амбициозная ставка на создание массового, вирального продукта с огромным потенциалом роста и влияния, который становится главным местом для поиска и монетизации хобби для миллионов людей. Первый вариант обладает большей стаби льностью, второй – более высоким стратегическим потенциалом. 3 МЕТОДИКА SCAMPER Применение методики SCAMPER для генерации новых идей по развитию «Платформы для обмена знаниями и навыками» представлено в таблице 3.1. Таблица 3.1 – Методика SCAMPER Сокращение Этап пробежки / модификация (прием) Ответ S Substitute / Заменить Заменить стандартный формат «курса» на «рецепты навыков» — короткие, пошаговые инструкции для решения конкретной практической задачи. Это снизит время на обучение и повысит его прикладную ценность. C Combine / Скомбинировать Скомбинировать образовательную платформу с биржей микро - задач. После изучения навыка пользователь может сразу же выполнить оплачиваемый проект от реального заказчика, подтвердив свою компетенцию. A Adapt / Адаптировать Адаптировать алгоритм мэтчинга из дейтинг - приложений для подбора идеальной пары «ученик - наставник» на основе не только темы, но и стиля преподавания, целей обучения и психологической совместимости. M Magnify / Увеличить и Modify / Модифицировать Увеличить значимость статуса наставника, внедрив систему грейдов (например, \"Практик\", \"Мастер\", \"Эксперт\"), которые открывают доступ к более высокооплачиваемым заказам и участию в эксклюзивных проектах. P Put to other uses / Применить для другого Использовать платформу не только для обучения, но и как сервис «эксперт на час» для компаний, которым нужна быстрая консультация по узкому вопросу без найма сотрудника в штат. E Eliminate / Устранить и Minify / Минимизировать Устранить необходимость покупать курс целиком. Внедрить модель оплаты за потребленный контент (например, за просмотренный урок или минуту консультации), что снизит финансовый барьер для пользователей. R Reverse / Перевернуть и Rearrange / Изменить порядок Перевернуть традиционную модель: создать «биржу учебных запросов», где пользователи публикуют свои проблемы («не могу настроить X»), а наставники предлагают свои услуги для их решения, соревнуясь за заказ Применение методики SCAMPER к идее платформы по обмену знаниями позволило выявить целый ряд направлений для её кардинального улучшения. Основное внимание сместилось от модели простого каталога курсов к созданию динамичной и интерактивной экосистемы. Интегр ация с биржей реальных задач формирует прямую связь между обучением и практическим применением навыков, а адаптация современных алгоритмов подбора повышает удовлетворенность пользователей. Идеи, полученные в ходе анализа, способствуют формированию более гибкой и клиентоориентированной среды. Устранение барьера в виде необходимости покупки целого курса и переворот модели в сторону «биржи запросов» ставят в центр потребности конкретного пользо вателя, а не готовый образовательный продукт. Это превращает платформу из пассивного хранилища информации в активный инструмент решения проблем. SCAMPER показал, что платформа может эволюционировать из стандартного образовательного маркетплейса в многофункциональную экосистему для профессионального и личностного роста. Это открывает возможности для выхода на смежные рынки (микро - консалтинг, B2B - реш ения) и значительно повышает ценность и конкурентоспособность итогового продукта. 4 МОДЕЛЬ КАНО Анкета Кано для определения возможных атрибутов (свойств, функций, характеристик и так далее) продукта представлена в таблице 4.1. Таблица 4.1 − Анкета Кано №, свойство Характеристика Ответы Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится 1 Поиск курсов по категориям и ключевым словам присутствует отсутствует 2 Система рейтингов и отзывов о наставниках присутствует отсутствует 3 Встроенный мессенджер для общения с наставником присутствует отсутствует 4 Возможность создавать «учебные треки» из разных курсов присутствует отсутствует 5 Геймификация: получение баллов, значков и уровней присутствует отсутствует 6 Интеграция с LinkedIn для добавления сертификатов присутствует отсутствует 7 Персональные рекомендации курсов на основе AI присутствует отсутствует 8 «Биржа запросов», где ученики размещают задачи присутствует отсутствует 9 Корпоративные аккаунты для командного обучения присутствует отсутствует Исходя из опроса тридцати человек по составленной выше анкете Кано выполнен промежуточный расчет результатов, представленный в таблице 4.2. Таблица 4.2 – Промежуточная таблица результатов для поиска курсов Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 0 0 1 2 3 Так должно быть 0 1 1 2 20 Мне все равно 0 0 0 0 0 Я могу с этим жить 0 0 0 0 0 Мне это не нравится 0 0 0 0 0 Таблица 4.3 – Промежуточная таблица результатов для системы рейтингов Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 0 1 1 1 12 Так должно быть 1 1 2 1 5 Мне все равно 0 0 1 1 0 Я могу с этим жить 0 0 0 2 1 Мне это не нравится 0 0 0 0 0 Таблица 4.4 – Промежуточная таблица результатов для встроенного мессенджера Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 1 0 2 2 10 Так должно быть 2 1 3 1 4 Мне все равно 0 0 2 1 0 Я могу с этим жить 0 0 1 0 0 Мне это не нравится 0 0 0 0 0 Таблица 4.5 – Промежуточная таблица результатов для учебных треков Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 0 2 10 6 0 Так должно быть 0 1 3 2 0 Мне все равно 0 0 2 2 0 Я могу с этим жить 0 0 1 1 0 Мне это не нравится 0 0 0 0 0 Таблица 4.6 – Промежуточная таблица результатов для геймификации Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 1 2 12 5 0 Так должно быть 0 1 3 1 0 Мне все равно 0 0 3 1 0 Я могу с этим жить 0 0 1 0 0 Мне это не нравится 0 0 0 0 0 Таблица 4.7 – Промежуточная таблица результатов для интеграции с LinkedIn Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 0 0 3 2 0 Так должно быть 0 0 1 1 0 Мне все равно 0 1 16 3 0 Я могу с этим жить 0 0 2 1 0 Мне это не нравится 0 0 0 0 0 Таблица 4.8 – Промежуточная таблица результатов для персональных рекомендаций Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 1 2 15 4 0 Так должно быть 0 1 2 1 0 Мне все равно 0 0 2 1 0 Я могу с этим жить 0 0 1 0 0 Мне это не нравится 0 0 0 0 0 Таблица 4.9 – Промежуточная таблица результатов для биржи запросов Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 1 2 17 3 0 Так должно быть 0 0 2 1 0 Мне все равно 0 0 3 1 0 Я могу с этим жить 0 0 0 0 0 Мне это не нравится 0 0 0 0 0 Таблица 4.10 – Промежуточная таблица результатов для корпоративных аккаунтов Функциональ - ная характе - ристика Дисфункциональная характеристика Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится Мне это нравится 0 0 5 2 0 Так должно быть 0 0 2 1 0 Мне все равно 1 1 13 3 0 Я могу с этим жить 0 0 2 0 0 Мне это не нравится 0 0 0 0 0 Исходя из опроса тридцати человек по составленной выше анкете Кано, были обработаны и сведены в частотную таблицу 4. 11 . Таблица 4. 11 − Частотность свойств продукта ( O - M - A - I - R + Q ) Свойство Мне это нравится Так должно быть Мне все равно Я могу с этим жить Мне это не нравится 1 Поиск курсов 20% 80% 0% 0% 0% 2 Система рейтингов 57% 27% 3% 3% 10% 3 Встроенный мессенджер 60% 23% 7% 10% 0% 4 Учебные треки 70% 13% 10% 7% 0% 5 Геймификация 77% 10% 10% 3% 0% 6 Интеграция с LinkedIn 13% 3% 77% 7% 0% 7 Рекомендации на AI 80% 7% 10% 3% 0% 8 Биржа запросов 83% 3% 10% 4% 0% 9 Корпоративные аккаунты 27% 7% 63% 3% 0% Пользовательский приоритет свойства (характеристики, функции, атрибута) исследуемого продукта представлены в таблице 4. 12 . Таблица 4. 12 − Интерпретация результатов опроса по анкете Кано Свойство (характеристика, функция, атрибут) Тип 1 Поиск курсов по категориям и ключевым словам М – Обязательные 2 Система рейтингов и отзывов о наставниках О – Одномерные 3 Встроенный мессенджер для общения с наставником О – Одномерные 4 Возможность создавать «учебные треки» из разных курсов А – Привлекательные 5 Геймификация: получение баллов, значков и уровней А – Привлекательные 6 Интеграция с LinkedIn для добавления сертификатов I – Неважные 7 Персональные рекомендации курсов на основе AI А – Привлекательные 8 «Биржа запросов», где ученики размещают задачи А – Привлекательные 9 Корпоративные аккаунты для командного обучения I – Неважные Платформа для обмена знаниями и навыками в первую очередь должна реализовать обязательные функции: в данном случае это базовый поиск по курсам. Без этого функционала сервис не сможет выполнять свою основную задачу и не оправдает базовых ожиданий пользовате лей. После этого важно внедрять одномерные функции: система рейтингов и внутренний мессенджер. Удобство и качество реализации этих функций будут напрямую влиять на уровень удовлетворенности пользователей и их готовность продолжать использовать приложение, так к ак чем лучше они реализованы, тем выше будет лояльность. Привлекательные функции, такие как создание учебных треков, геймификация, AI - рекомендации и «биржа запросов», следует использовать для создания «wow - эффекта» и отстройки от конкурентов. Их наличие не является обязательным, но способно вызвать восторг у пол ьзователей, повысить их лояльность и стать ключевым маркетинговым преимуществом. Функции интеграции с LinkedIn и корпоративных аккаунтов были оценены как неважные для основной аудитории, что позволяет отложить их реализацию на более поздние этапы. Нежелате льных функций в ходе анализа выявлено не было, поэтому все предложенные элементы имеют практическую ценность для работы платформы. ВЫВОД В ходе практической работы была проведена пошаговая разработка и анализ бизнес - идеи: 1 Генерация идей: с помощью мозгового штурма были предложены различные варианты бизнес - проектов. После первичной фильтрации выделены три перспективные идеи: приложение для управления здоровьем с помощью AI; платформа для аренды объектов искусства; платформа для обмена знаниями и навыками. 2 Рейтинговая оценка: каждая идея была проанализирована по ключевым критериям (уникальность, реализуемость, риски, рыночный потенциал, масштабируемость и др.). Наибольшую итоговую оценку (76,75 балла) получила платформа для обмена знаниями и навыками, что по зволило выбрать её для дальнейшей проработки. 3 Характеристика и описание: определены цель проекта, его миссия, целевая аудитория (наставники и ученики) и особенности реализации. Сформулированы положительные стороны и потенциальные проблемы внедрения. Платформа позиционируется как кроссплатформенное реш ение для создания децентрализованной образовательной среды. 4 Морфологический анализ: были рассмотрены различные варианты реализации проекта (тип контента, формат обучения, модель монетизации). В результате сформированы две концепции – B2B ( интеграция в корпоративные системы) и B2C ( платформа для индивидуальных польз ователей). 5 Методика SCAMPER: с её помощью разработаны направления улучшения платформы: интеграция с биржей микро - задач, внедрение алгоритма мэтчинга, создание «биржи учебных запросов». Это позволило превратить идею в многофункциональную экосистему для профессионально го и личностного роста. 6 Модель Кано: на основе опроса пользователей выделены обязательные функции (поиск курсов), одномерные (система рейтингов, мессенджер) и привлекательные (геймификация, AI - рекомендации, биржа запросов). Это дало понимание, какие элементы нужно реализовать в п ервую очередь. В ходе работы была проведена комплексная разработка бизнес - идеи, начиная от генерации и сравнительного анализа, до детальной проработки с помощью морфологического анализа, методики SCAMPER и модели Кано. Полученный результат подтвердил жизнеспособность про екта платформы для обмена знаниями и навыками и показал её высокий социальный и рыночный потенциал.",
      "wordCount": 4303,
      "uploadDate": "2025-11-26T16:18:47.099Z",
      "category": "coursework",
      "minhashSignature": [
        23179,
        781084,
        494249,
        65691,
        189858,
        53090,
        101639,
        32474,
        142348,
        4952,
        310703,
        78318,
        152945,
        50633,
        76865,
        149912,
        73518,
        80489,
        294351,
        22458,
        3304,
        167056,
        116921,
        369695,
        637853,
        7161,
        33077,
        141314,
        71696,
        326667,
        62070,
        32834,
        63981,
        22551,
        19382,
        390990,
        128606,
        103031,
        417176,
        46667,
        121573,
        141803,
        159372,
        105816,
        26861,
        71805,
        230460,
        229934,
        353790,
        6422,
        59335,
        56155,
        63816,
        36331,
        34355,
        204574,
        157477,
        130099,
        139395,
        686358,
        328632,
        192523,
        110212,
        226126,
        43374,
        293733,
        17621,
        151866,
        126076,
        49161,
        222090,
        405737,
        13049,
        4509,
        121174,
        60981,
        39245,
        240433,
        23595,
        104581,
        7481,
        53068,
        36150,
        53313,
        227359,
        10874,
        369610,
        52509,
        210081,
        373365,
        37360,
        289631,
        209611,
        67318,
        128544,
        91924,
        15087,
        103780,
        27602,
        221872,
        112254,
        805,
        159331,
        124391,
        136640,
        7003,
        456585,
        62333,
        56862,
        108284,
        242098,
        211640,
        42995,
        10847,
        827044,
        174568,
        1231,
        72738,
        12127,
        154405,
        151466,
        89446,
        87960,
        18237,
        151666,
        290401,
        209920,
        37535
      ],
      "shingleCount": 11556
    },
    {
      "id": 2,
      "title": "МиИСБП_ПР2_314302_ФурсовАВ",
      "author": "Furs Art Val",
      "filename": "МиИСБП_ПР2_314302_ФурсовАВ.pdf",
      "filePath": "data/uploads/1764173950760_МиИСБП_ПР2_314302_ФурсовАВ.pdf",
      "content": "Министерство образования Республики Беларусь Учреждение образования БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ Факультет компьютерного проектирования Кафедра проектирования информационно - компьютерных систем Дисциплина Методы и инструментальные средства бизнес - планирования Отчет по практической работе № 2 на тему: « РАЗРАБОТКА БИЗНЕС - МОДЕЛИ » Выполнил: Фурсов А . В . (подпись) гр. 314302 Проверил: Левченя Ж.Б (подпись) Минск 2025 1 БИЗНЕС - МОДЕЛЬ ПРОЕКТА ПО ШАБЛОНУ А. ОСТЕРВАЛЬДЕРА И И. ПЕНЬЕ В таблице 1 представлена бизнес - модель проекта «Платформа для обмена знаниями и навыками» по шаблону А. Остервальдера и И. Пенье. Таблица 1 – Бизнес - модель проекта по шаблону А. Остервальдера и И. Пенье. Описание элементов бизнес - модели проекта представлено в таблице 1. Ключевые партнёры Ключевые действия Ценностное предложение Взаимоотношения с клиентами Потребительские сегменты − Платежные системы − Образовательные блогеры и инфлюенсеры − IT - компании (облачная инфраструктура) – Разработка и поддержка IT - платформы – Привлечение и удержание обеих групп пользователей – Модерация контента и поддержка пользователей – Маркетинг и продвижение – Для наставников: Простой способ монетизации своих знаний и навыков. – Для учеников: Доступ к уникальным практическим знаниям напрямую от экспертов в гибком формате. – Автоматизированный сервис (рейтинги, отзывы, рекомендации) – Сообщества и форумы по интересам – Персональная поддержка для корпоративных клиентов – Наставники (эксперты): Специалисты, желающие делиться опытом. – Ученики (энтузиасты): Люди, стремящиеся к саморазвитию и освоению новых навыков. – Корпоративные клиенты: Компании, ищущие точечное обучение для сотрудников. Ключевые ресурсы Каналы сбыта – Программная платформа (сайт и приложения) – Сообщество наставников и учеников – Команда разработчиков, маркетологов, модераторов – Бренд и репутация – App Store и Google Play• Контент - маркетинг (блог, соцсети) – Таргетированная реклама – Партнерства с инфлюенсерами Структура издержек Потоки доходов – Заработная плата команды – Расходы на маркетинг и рекламу – Затраты на серверную инфраструктуру и ПО – Комиссии платежных систем – Комиссия с каждой транзакции (оплаты курса или консультации) – Freemium - модель (платная подписка на расширенные функции для наставников) – Продажа корпоративных лицензий (B2B) Таблица 1 – Описание элементов бизнес - модели Название блока Основные вопросы Описание Потребительские сегменты Для кого мы создаем ценностное предложение? Какие клиенты наиболее важны? Проект ориентирован на двусторонний рынок. Первый ключевой сегмент – наставники: эксперты - практики, специалисты, ремесленники, желающие монетизировать свои знания. Второй ключевой сегмент – ученики: люди любого возраста, стремящиеся к получению прикладных навыков, освоению хобби или повышению квалификации. Вторичный сегмент – корпоративные клиенты ( B 2 B ): компании, нуждающиеся в точечном обучении своих сотрудников у узкопрофильных специалистов. Ценностное предложение Какие ценности мы предлагаем потребителю? Какие проблемы решаем? Для наставников платформа решает проблему сложной монетизации навыков, предоставляя готовый инструментарий для создания, продвижения и продажи образовательных продуктов. Для учеников решается проблема поиска качественных практических знаний, предлагая дост уп к экспертам напрямую в удобном формате (видеокурсы, консультации). Дополнительная ценность – гибкость и персонализация обучения. Каналы сбыта Какие каналы взаимодействия наиболее эффективны? Как мы доносим ценность до клиентов? Основными каналами являются цифровые магазины App Store и Google Play , а также веб - сайт платформы. Привлечение пользователей осуществляется через контент - маркетинг (экспертные статьи, туториалы), таргетированную рекламу в социальных сетях ( LinkedIn , Instagram ) и сотрудничество с образовательными блогерами и лидерами мнений. Взаимоотношения с клиентами Отношений какого типа ждут клиенты? Как они интегрированы в модель? Для большинства пользователей отношения строятся на автоматизированном сервисе: система рейтингов и отзывов, персонализированные рекомендации, самообслуживание. Важную роль играет сообщество (форумы, чаты). Для корпоративных клиентов ( B 2 B ) предусмотрена персональная поддержка через выделенного менеджера. Продолжение таблицы 1 Название блока Основные вопросы Описание Потоки доходов За что клиенты готовы платить? Каким образом платят? Основной поток доходов – комиссия с каждой успешной транзакции между учеником и наставником. Дополнительные источники: модель Freemium , где наставники могут покупать подписку для получения расширенных инструментов аналитики и продвижения, а также продажа корпоративных лицензий компаниям для обучения их сотрудников. Ключевые ресурсы Какие ресурсы необходимы для реализации ценностного предложения? Важнейшие ресурсы – это сама IT - платформа (программный код, инфраструктура), сеть пользователей (критическая масса наставников и учеников) и команда проекта (разработчики, маркетологи, служба поддержки). В долгосрочной перспективе ключевым ресурсом также станет бренд и репутация платфор мы. Ключевые виды деятельности Какие виды деятельности необходимы для работы бизнес - модели? Основные виды деятельности – разработка и поддержка платформы, обеспечение ее стабильной и безопасной работы. Ключевой деятельностью также является маркетинг и привлечение пользователей с обеих сторон рынка. Важнейшее направление – управление сообществом и модерация контента для поддержания высокого качества. Ключевые партнеры Кто является партнерами и поставщиками? Какие ресурсы получаем от партнеров? Ключевые партнеры – платежные системы, обеспечивающие проведение транзакций. Важными партнерами являются лидеры мнений и образовательные блогеры, выступающие как канал привлечения аудитории. Поставщики облачной инфраструктуры (например, AWS , Google Cloud ) предоставляют технические ресурсы. Структура издержек Какие расходы наиболее значимы? Ключевые расходы связаны с оплатой труда команды. Существенную долю занимают расходы на маркетинг и рекламу. Также важны затраты на IT - инфраструктуру (серверы, базы данных, CDN ) и комиссии платежных систем и магазинов приложений. Потребительские сегменты Для кого мы создаем ценностное предложение? Какие клиенты наиболее важны? Проект ориентирован на двусторонний рынок. Первый ключевой сегмент – наставники: эксперты - практики, специалисты, ремесленники, желающие монетизировать свои знания. Второй ключевой сегмент – ученики: люди любого возраста, стремящиеся к получению прикладных навыков, освоению хобби или повышению квалификации. Вторичный сегмент – корпоративные клиенты ( B 2 B ): компании, нуждающиеся в точечном обучении своих сотрудников у узкопрофильных специалистов. Модель демонстрирует четкое понимание структуры двустороннего рынка и отражает ценностное предложение для каждого сегмента. Продуманные каналы привлечения, структура взаимоотношений и диверсифицированные потоки доходов создают условия для устойчивого роста . Включение ключевых партнеров, таких как лидеры мнений и поставщики инфраструктуры, а также выделение необходимых ресурсов и видов деятельности обеспечивают реализацию проекта с управляемыми рисками. 2 МОДЕЛЬ LEAN CANVAS Пример заполнения Lean Canvas для рассматриваемого проекта представлен в таблице 2. Таблица 2 – Lean Canvas проекта Lean Canvas для проекта «Платформа для обмена знаниями и навыками» показывает, что бизнес - модель сфокусирована на решении четко определенной проблемы (сложность монетизации и поиска практических знаний) для конкретных сегментов аудитории. Модель подтверждает жизнеспо собность идеи, выявляя понятные каналы для охвата ранних последователей и предлагая сильное ценностное предложение. Ключевые метрики, такие как удержание и конверсия, позволяют отслеживать успех продукта на ранних стадиях, а скрытое преимущество в виде сет евого эффекта создает барьер для конкурентов. Lean Canvas демонстрирует, что проект обладает ясной, ориентированной на быстрый рост и масштабирование структурой. Проблема и существующие альтернативы Решение Уникальная ценность Скрытое преимущество Сегменты потребителей , ранние последователи − Экспертам сложно монетизировать свои нишевые знания. − Учащимся трудно найти качественный прикладной контент. − Существующие платформы имеют высокий порог входа для авторов. Альтернативы: Udemy, Skillbox, YouTube, фриланс - биржи, частные консультации. – Маркетплейс для курсов и консультаций. – Простые инструменты для создания контента. – Система рейтингов и отзывов. – Монетизируй любой навык – И зучай любую практику. – Прямой доступ к реальным экспертам. Сетевой эффект: критическая масса качественных наставников и лояльных учеников, которую сложно скопировать. – Наставники, фрилансеры. – Люди, ищущие новые хобби и навыки. Ранние последователи: технически подкованные специалисты, уже продающие услуги онлайн; активные пользователи образовательных блогов. Ключевые метрики Каналы – Количество активных пользователей (наставников и учеников). – Коэффициент удержания пользователей – Конверсия в первую покупку. – Контент - маркетинг. – Таргетированная реклама. – Партнерства с инфлюенсерами. – App Store / Google Play. Структура издержек Потоки прибыли – Разработка и поддержка платформы. – Маркетинг и привлечение. – Зарплата команды. – Комиссия с транзакций. – Подписка для наставников (Pro - аккаунты). – B2B - лицензии. ВЫВОД В ходе выполнения практической работы были разработаны и проанализированы две ключевые бизнес - модели для проекта «Платформа для обмена знаниями и навыками»: классическая Business Model Canvas по шаблону А. Остервальдера и И. Пенье, а также модель Lean Canv as. Разработка Business Model Canvas позволила получить целостное, стратегическое видение проекта. В рамках этой модели были четко определены потребительские сегменты (наставники, ученики, компании), сформулировано ценностное предложение для каждой группы, про работаны каналы сбыта, взаимоотношения с клиентами и структура потоков доходов на основе комиссионной и Freemium - моделей. Анализ этой модели показал внутреннюю согласованность всех девяти блоков и подтвердил экономическую жизнеспособность и устойчивость би знес - логики проекта в долгосрочной перспективе. Модель Lean Canvas, в свою очередь, сместила акцент на ключевые аспекты, важные для стартапа. Она позволила сфокусироваться на конкретной проблеме (сложность монетизации и поиска практических знаний) и предложенном решении (маркетплейс с низким порогом вхо да). Были определены ключевые метрики для отслеживания успеха (удержание, конверсия) и сформулировано скрытое преимущество, создающее барьер для конкурентов. Данная модель подтвердила, что продукт решает реальную рыночную проблему и имеет четкий путь для б ыстрого тестирования гипотез и дальнейшего масштабирования. Оба инструмента успешно дополнили друг друга: Business Model Canvas продемонстрировала, что проект является продуманным и жизнеспособным бизнесом, а Lean Canvas предоставила практическую основу для его запуска и роста. Проделанная работа подтвердила высоки й потенциал проекта и наличие у него четкой, проработанной структуры.",
      "wordCount": 1441,
      "uploadDate": "2025-11-26T16:19:10.826Z",
      "category": "coursework",
      "minhashSignature": [
        23179,
        498290,
        494249,
        394184,
        1425255,
        313023,
        322962,
        357172,
        676298,
        953613,
        235163,
        29609,
        195154,
        188219,
        982022,
        398845,
        892937,
        195198,
        225468,
        1229284,
        512533,
        167056,
        815730,
        175369,
        1181446,
        544391,
        33077,
        141314,
        874965,
        1073146,
        559850,
        32834,
        273463,
        586705,
        19382,
        901549,
        196844,
        152983,
        307433,
        814989,
        348320,
        1043627,
        420850,
        42872,
        15493,
        668726,
        238730,
        686873,
        51357,
        1020421,
        197435,
        547494,
        63816,
        36331,
        49451,
        204574,
        319540,
        2126291,
        1168533,
        378351,
        172363,
        194200,
        419524,
        1458984,
        48305,
        72515,
        17621,
        1561612,
        126076,
        434039,
        356211,
        405737,
        227320,
        4509,
        83768,
        104103,
        366780,
        409959,
        1558972,
        151169,
        7481,
        117229,
        106677,
        405474,
        20381,
        8989,
        296337,
        52509,
        403092,
        223091,
        250810,
        132054,
        679291,
        413630,
        1089934,
        119660,
        745581,
        1620989,
        166850,
        1577162,
        1571874,
        853377,
        324633,
        511657,
        136640,
        7003,
        413029,
        105866,
        246,
        153133,
        300649,
        1749030,
        586384,
        36293,
        326259,
        1087347,
        1231,
        271136,
        2039786,
        154405,
        151466,
        89446,
        534923,
        18237,
        469091,
        290401,
        209920,
        549803
      ],
      "shingleCount": 5091
    },
    {
      "id": 3,
      "title": "МиИСБП_ПР3_314302_ФурсовАВ",
      "author": "Furs Art Val",
      "filename": "МиИСБП_ПР3_314302_ФурсовАВ.pdf",
      "filePath": "data/uploads/1764174171764_МиИСБП_ПР3_314302_ФурсовАВ.pdf",
      "content": "Министерство образования Республики Беларусь Учреждение образования БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ Факультет компьютерного проектирования Кафедра проектирования информационно - компьютерных систем Дисциплина Методы и инструментальные средства бизнес - планирования Отчет по практической работе № 3 на тему: « АНАЛИЗ ВЛИЯНИЯ ФАКТОРОВ ОКРУЖАЮЩЕЙ СРЕДЫ » Выполнил: Фурсов А . В . (подпись) гр. 314302 Проверил: Левченя Ж.Б (подпись) Минск 2025 1 АНАЛИЗ МАКРОСРЕДЫ STEP/PEST Для всестороннего понимания внешнего контекста, в котором будет развиваться проект «Платформа для обмена знаниями и навыками», был проведен анализ ключевых макроэкономических факторов. В таблице 1 сгруппированы основные тенденции и события, которые могут оказать как положительное, так и отриц ательное влияние на стратегию и тактику развития проекта. Таблица 1 .1 – Факторы внешней среды PEST - анализа Политические факторы (Р) Экономические факторы (Е) 1. Государственная поддержка IT - сектора и самозанятых. 1. Рост «гиг - экономики» и рынка фриланса. 2. Законодательство в области защиты интеллектуальной собственности (авторского права на курсы). 2. Экономическая нестабильность, влияющая на платежеспособность населения. 3. Ужесточение законов о защите персональных данных пользователей. 3. Рост рынка онлайн - образования (EdTech) и венчурных инвестиций в сектор. 4. Требования к маркировке рекламы в интернете. 4. Увеличение стоимости привлечения клиентов ( CAC) из - за высокой конкуренции. Социальные факторы ( S) Технологические факторы (Т) 1. Тренд на непрерывное обучение (lifelong learning) и саморазвитие. 1. Высокий уровень проникновения широкополосного интернета и мобильных устройств. 2. Рост популярности удаленной работы и обучения. 2. Развитие технологий видеостриминга и облачных хранилищ. 3. Повышение доверия к онлайн - платежам и цифровым сервисам. 3. Развитие искусственного интеллекта для персонализации рекомендаций контента. 4. Ориентация молодежи на получение практических навыков, а не только академических знаний. 4. Развитие мобильных платформ (App Store, Google Play) и их политики в отношении приложений. Чтобы перейти от простого перечисления факторов к их практической оценке, необходимо провести более детальное исследование. В таблице 2 представлен углубленный анализ, в рамках которого каждый фактор оценивается с точки зрения его вероятности, важности и потенциального влияния на проект, а также предлагаются конкретные шаги для реагирования. Таблица 1. 2 – Табличная форма для проведения STEP - анализа Группы факторов События/ факторы Опасность/ возможность Оценка вероятности Оценка важности Влияние на проект Программа действий Социальные ( S) Тренд на непрерывное обучение + 3 10 +30 Позиционировать платформу как инструмент для карьерного роста и личностного развития. Создавать контент, подчеркивающий важность постоянного приобретения новых навыков. Рост популярности удаленного обучения + 3 8 +24 Оптимизировать платформу для всех форматов удаленного взаимодействия (видео, чаты). Предлагать инструменты для создания интерактивных онлайн - занятий. Технологические (T) Высокое проникновение интернета + 3 9 +27 Ориентироваться на mobile - first подход в разработке. Обеспечить высокую скорость загрузки и стабильность работы сервиса на различных устройствах и скоростях соединения. Развитие ИИ для персонализации + 2 8 +16 Разработать и внедрить алгоритм рекомендаций курсов и наставников на основе интересов, предыдущих покупок и поведения пользователя на платформе. Экономические ( E) Рост рынка EdTech и инвестиций + 2 9 +18 Активно отслеживать тренды рынка. Разработать инвестиционно - привлекательную презентацию проекта для потенциальных инвесторов, делая акцент на масштабируемости. Увеличение стоимости привлечения клиентов - 3 8 - 24 Сфокусироваться на удержании существующих пользователей и стимулировании органического роста Продолжение таблицы 1.2 Группы факторов События/ факторы Опасность/ возможность Оценка вероятности Оценка важности Влияние на проект Программа действий Политические (Р) Ужесточение законов о персональных данных - 3 9 - 27 Разработать политику конфиденциальности в строгом соответствии с законодательством. Сделать процесс получения согласия на обработку данных максимально прозрачным для пользователя. Проведенный анализ демонстрирует, что проект функционирует в среде со значительным потенциалом роста, который подкрепляется мощными социальными и технологическими тенденциями. Основными драйверами выступают общественный запрос на самообразование и широкая технологическая доступность. В то же время, ключевые вызовы сосредоточены в экономической плоскости, где высокая конкуренция приводит к росту маркетинговых затрат, и в политико - правовой, связанной с ужесточением регуляторных норм. Предложенная программа де йствий нацелена на максимальное использование благоприятных факторов и проактивную нейтрализацию угроз. 2 ТЕХНИКА АНАЛИЗА УГРОЗ И ВОЗМОЖНОСТЕЙ ВНЕШНЕЙ СРЕДЫ ЕТОМ - АНАЛИЗ Для более глубокой и количественной оценки факторов макросреды применяется матрица ETOM (Environmental Threats and Opportunities Matrix). В рамках этого анализа мы отберем 15 ключевых факторов, сгруппированных по категориям, и оценим их по трем параметрам . Матрица ЕТОМ - анализа для нашего проекта представлена в таблице 2.1 . Таблица 2.1 – Матрица ЕТОМ - анализа Группа факторов Описание факторов Угроза ( - ), X Возможность (+), X Оценка веса, балл (от 1 до 5), Y Оценка важности, балл (от 1 до 15), Z Совокупное влияние факторов, I = X * Y * Z Экономические 1. Рост венчурных инвестиций в EdTech - стартапы. + 4 11 +44 2. Валютные колебания, влияющие на стоимость ПО. - 2 5 - 10 3. Рост «гиг - экономики» (увеличение числа наставников). + 5 13 +65 4. Снижение покупательной способности населения. - 3 9 - 27 Технологические 5. Широкое распространение мобильных платежей. + 5 14 +70 6. Развитие технологий VR/AR для обучения. + 2 6 +12 7. Появление новых платформ - конструкторов курсов. - 4 12 - 48 8. Риск утечки данных и кибератаки. - 4 10 - 40 Социально - демографические 9. Тренд на получение практических навыков (reskilling). + 5 15 +75 10. Рост популярности микро - обучения. + 3 8 +24 11. Снижение концентрации внимания у пользователей. - 3 7 - 21 12. Повышение цифровой грамотности старшего поколения. + 2 3 +6 Политико - правовые 13. Законы о маркировке интернет - рекламы. - 3 4 - 12 14. Ужесточение законов о защите интеллектуальной собственности. - 4 8 - 32 15. Государственные программы поддержки самозанятых. + 2 2 +4 Итого +110 Итоговый балл (+110) показывает, что в целом внешняя среда является весьма благоприятной, и у проекта значительно больше весомых возможностей, чем угроз. Это говорит о высоком потенциале роста в текущих рыночных условиях. Теперь на основе проведенного анализа выделим самые критические факторы, которые получили наивысшие оценки по совокупному влиянию. Итоговая таблица анализа ЕТОМ методом экспертных оценок представлена в таблице 2.2 . Таблица 2.2 – Итоговая таблица анализа ЕТОМ методом экспертных оценок Эксперт Три фактора, получившие самые высокие оценки Описание фактора Возможность (+) Угроза ( - ) 1. Социальный спрос: глобальный тренд на переобучение и получение новых практических навыков для адаптации к меняющемуся рынку труда. Тренд на получение практических навыков (reskilling) (I = +75) 2. Технологическая готовность: повсеместное использование смартфонов и доверие к мобильным платежам создают идеальную инфраструктуру для транзакций на платформе. Широкое распространение мобильных платежей (I = +70) 3. Рыночные риски: появление новых технологических решений, которые упрощают запуск конкурирующих платформ, усиливает конкуренцию. Появление новых платформ - конструкторов курсов (I = - 48) 4. Риски безопасности: с ростом платформы увеличивается риск кибератак и утечек персональных данных пользователей, что может нанести непоправимый ущерб репутации. Риск утечки данных и кибератаки. ( I = - 40 ) 5. Правовые риски: усложнение законодательства в сфере защиты авторских прав на контент может привести к судебным искам и дополнительным издержкам. Ужесточение законов о защите интеллектуальной собственности. (I = - 32) 6. Экономический драйвер: рост числа фрилансеров и самозанятых («гиг - экономика») напрямую увеличивает потенциальную базу наставников для платформы. Рост «гиг - экономики» (I = +65) Анализ подтверждает, что успех проекта зависит от способности максимально использовать социальный запрос на переобучение и технологическую готовность рынка к мобильным платежам. В то же время, стратегия проекта должна быть направлена на создание технологич еского и репутационного барьера для новых конкурентов, а также на выстраивание надежной системы безопасности данных и юридической защиты контента. 3 ТЕХНИКА БЫСТРОГО СКАНИРОВАНИЯ ОКРУЖАЮЩЕЙ СРЕДЫ QUEST - АНАЛИЗ Чтобы глубже понять динамику внешней среды, мы применим QUEST - анализ. Этот метод позволит не просто констатировать наличие факторов, но и выявить скрытые взаимосвязи между ними. Для анализа были отобраны пять наиболее весомых факторов, определённых на пред ыдущем этапе. Отобранные факторы для QUEST - анализа: − Фактор 1 (Социальный): тренд на получение практических навыков (reskilling); − Фактор 2 (Технологический): широкое распространение мобильных платежей; − Фактор 3 (Экономический): рост «гиг - экономики» и увеличение числа потенциальных наставников; − Фактор 4 (Технологический): появление новых платформ - конструкторов курсов и усиление конкуренции; − Фактор 5 (Технологический): риск утечки данных и кибератаки. На первом шаге анализа оценивается вероятность того, что каждый из этих факторов сохранит свою актуальность в обозримом будущем. Результаты этой оценки представлены в таблице 3.1 . Таблица 3.1 – Матрица QUEST - анализа, этап I Фактор Вероятность проявления, % Фактор 1 Фактор 2 Фактор 3 Фактор 4 Фактор 5 Фактор 1: Тренд на reskilling 95 X Фактор 2: Мобильные платежи 95 X Фактор 3: Рост гиг - экономики 90 X Фактор 4: Усиление конкуренции 90 X Фактор 5: Риск кибератак 85 X На втором шаге определяется характер взаимовлияния факторов. Наличие прямой связи и влияния обозначается знаком «+». Результаты отражены в таблице 3.2 . Таблица 3.2 – Матрица QUEST - анализа, этап II Фактор Вероятность проявления, % Фактор 1 Фактор 2 Фактор 3 Фактор 4 Фактор 5 Фактор 1: Тренд на reskilling 95 X + + Фактор 2: Мобильные платежи 95 X + + Фактор 3: Рост гиг - экономики 90 + X + Фактор 4: Усиление конкуренции 90 + X Фактор 5: Риск кибератак 85 + X Проведенный анализ позволяет сделать следующие выводы о структуре внешнего окружения: 1 Движущие силы рынка: «Тренд на reskilling» ( Фактор 1) и «Рост гиг - экономики» (Фактор 3) являются основными катализаторами. Они формируют как спрос (потребность в новых навыках), так и предложение (рост числа экспертов, готовых обучать), что, в свою очередь , неизбежно приводит к «Усилению конкуренции» (Фактор 4), делая рынок привлекательным. 2 Эпицентр вызовов: «Усиление конкуренции» (Фактор 4) выступает в роли зависимой переменной, на которую воздействуют почти все остальные факторы. Это превращает борьбу за долю рынка в центральную стратегическую задачу для проекта. 3 Технологическая основа: «Распространение мобильных платежей» (Фактор 2) является необходимым условием для функционирования бизнес - модели. В то же время, эта технологическая зависимость напрямую порождает «Риск кибератак» (Фактор 5), демонстрируя неразрывну ю связь между возможностью и угрозой. 4 Фактор - ограничитель: «Риск кибератак» (Фактор 5) играет роль универсального барьера, повышая операционные издержки и требования к безопасности для всех участников рынка, хотя и не оказывает прямого влияния на уровень конкуренции. Таким образом, стратегия проекта должна быть построена на синергии двух мощных трендов: растущего спроса на практические навыки и увеличивающегося предложения со стороны экспертов. Однако именно эта синергия порождает главный вызов – острую конкурентную борьбу. Долгосрочный успех будет зависеть от способности не только предложить уникальный продукт, но и гарантировать высочайший уровень безопасности данных, что является гигиеническим минимумом для любого современного цифрового сервиса . 4 МЕТОД СОСТАВЛЕНИЯ ПРОФИЛЯ СРЕДЫ Для финального обобщения результатов анализа и определения наиболее критичных для проекта внешних сил используется метод составления профиля среды. Этот подход позволяет в концентрированном виде представить стратегический ландшафт, в котором предстоит дейс твовать. Для построения профиля мы используем те же пять ключевых факторов, что были отобраны для QUEST - анализа. Результаты оценки представлены в таблице 4.1 . Таблица 4.1 – Метод составления профиля среды Фактор среды Важность для отрасли (от 1 до 3), X Влияние на организацию (от 0 до 3), Y Направленность влияния (+1 или - 1), Z Степень важности, I = X * Y * Z 1. (S) Тренд на получение практических навыков ( reskilling). 3 3 +1 +9 2. (T) Широкое распространение мобильных платежей. 3 3 +1 +9 3. (E) Рост «гиг - экономики». 3 2 +1 +6 4. (T) Появление новых платформ - конструкторов курсов (усиление конкуренции). 3 3 - 1 - 9 5. (T) Риск утечки данных и кибератаки. 3 3 - 1 - 9 Профиль среды выявляет четыре фактора с наивысшим абсолютным значением важности (9), которые определяют контуры стратегических задач для проекта. На основе этих данных можно сделать следующие выводы: 1 Полярность окружения: Внешняя среда проекта характеризуется ярко выраженным дуализмом. С одной стороны, она предлагает мощнейшие возможности (+9), основанные на глобальном социальном тренде и готовой технологической базе. Эти факторы являются локомотивом для роста. С другой стороны, она содержит угрозы равной силы ( - 9), связанные с постоянно растущей конкуренцие й и критической важностью кибербезопасности. 2 Ключевые факторы успеха: Успех проекта напрямую зависит от способности менеджмента эффективно работать с основными вызовами и возможностями. Необходимо, с одной стороны, максимально капитализировать растущий спрос на reskilling и использовать повсеместное наличие мобильных платеже й как основу бизнес - модели. С другой стороны, требуется эффективно нейтрализовать угрозы, выстроив безупречную систему защиты данных и разработав уникальное торговое предложение, которое позволит отстроиться от конкурентов, создаваемых на готовых платформах. 3 Второстепенный, но важный фактор: Общий рост «гиг - экономики» (+6) является благоприятным фоном, который обеспечивает постоянный приток потенциальных наставников на платформу, но его влияние на сам проект менее прямое, чем у ключевых четырех факторов. Стратегия проекта должна быть сфокусирована на двух главных направлениях: создание превосходного, вовлекающего продукта, отвечающего на прямой запрос рынка на практические знания, и проактивное управление технологическими и репутационными рисками. Игнориро вание любого из этих четырех ключевых факторов недопустимо и несет экзистенциальную угрозу для бизнеса. ВЫВОД В ходе выполнения практической работы был проведен комплексный анализ факторов внешней среды, влияющих на проект «Платформа для обмена знаниями и навыками», с использованием таких методик, как STEP/PEST, ЕТОМ - анализ, QUEST - анализ и метод составления профиля среды. На первом этапе, посредством STEP/PEST - анализа, были выявлены и сгруппированы ключевые социальные, технологические, экономические и политические факторы. Этот анализ показал, что проект развивается в целом в благоприятной среде, где основными драйверами ро ста выступают растущий социальный запрос на практические навыки (reskilling) и высокий уровень технологической готовности рынка. Техника анализа угроз и возможностей (ЕТОМ) позволила не просто перечислить, а количественно оценить и ранжировать факторы по степени их влияния. В результате были определены наиболее значимые возможности (тренд на reskilling, рост гиг - экономики и повсемес тное использование мобильных платежей) и критические угрозы (усиление конкуренции, риски кибербезопасности, ужесточение законодательства в сфере интеллектуальной собственности), что позволило сфокусировать стратегическое внимание на самых весомых аспектах. Применение QUEST - анализа помогло выявить сложные взаимосвязи между ключевыми факторами, продемонстрировав, как социальные тренды и рост рынка напрямую стимулируют конкуренцию, а технологические удобства порождают новые риски безопасности. Завершающий метод составления профиля среды окончательно подтвердил полярный характер внешнего окружения, выделив четыре фактора с максимальной степенью важности, которые требуют первостепенного стратегического внимания. Проделанная работа позволила перейти от широкого сканирования среды к глубокому пониманию ключевых движущих сил и ограничений проекта. Анализ подтвердил высокую актуальность и потенциал платформы для обмена знаниями, но вместе с тем четко обозначил основны е вызовы, связанные с высокой конкуренцией и необходимостью обеспечения безопасности данных и контента. Полученные результаты формируют прочную основу для разработки дальнейшей рыночной стратегии, минимизации рисков и эффективного использования выявленных возможностей.",
      "wordCount": 2354,
      "uploadDate": "2025-11-26T16:22:51.823Z",
      "category": "coursework",
      "minhashSignature": [
        487885,
        511568,
        608273,
        65691,
        40675,
        53090,
        431382,
        382849,
        554452,
        776416,
        70374,
        78318,
        820342,
        188219,
        190293,
        398845,
        745024,
        80489,
        636455,
        344951,
        60936,
        147573,
        242487,
        65172,
        299370,
        502885,
        52568,
        91695,
        551919,
        55230,
        1050918,
        196652,
        308293,
        393622,
        19382,
        51155,
        196844,
        29425,
        1400497,
        66273,
        120895,
        596547,
        327662,
        127195,
        26861,
        236615,
        230641,
        715213,
        1474107,
        396221,
        59335,
        699676,
        63816,
        36331,
        13303,
        204574,
        44206,
        130099,
        171097,
        87734,
        198167,
        193051,
        122991,
        343043,
        547563,
        624059,
        2274,
        824360,
        181227,
        582070,
        222090,
        682576,
        227320,
        4509,
        35237,
        104103,
        39245,
        240433,
        109757,
        104581,
        70841,
        117229,
        65550,
        26384,
        247883,
        133009,
        330162,
        52509,
        303347,
        506773,
        334354,
        41481,
        386179,
        126197,
        128544,
        38859,
        235456,
        67499,
        27602,
        245809,
        112254,
        46590,
        60484,
        141064,
        282179,
        282295,
        456585,
        308055,
        56862,
        108284,
        300649,
        778213,
        522062,
        59661,
        420381,
        129544,
        1231,
        116178,
        431715,
        154405,
        151466,
        89446,
        394624,
        18237,
        311440,
        289944,
        28543,
        133414
      ],
      "shingleCount": 7663
    },
    {
      "id": 10,
      "title": "laba7",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "laba7.pdf",
      "filePath": "data/uploads/1764179435821_laba7.pdf",
      "content": "Лабораторная работа №6 «Эффективные принципы проектирования SOLID, аннотации и механизмы API reflection ПО» Вариант 5 1. Цель работы Изучить на практике принципы проектирования SOLID, механизмы аннотаций и API рефлексии в Java. Реализовать консольное приложение «Библиотека», демонстрирующее использование SOLID - подхода, кастомных аннотаций и Reflection API для анализа кода во время выполнения. 2. Краткая теоретическая часть Принципы SOLID — это набор рекомендаций по проектированию объектно - ориентированных систем, предложенный Робертом Мартином. Они включают: SRP (Single Responsibility Principle), OCP (Open/Closed Principle), LSP (Liskov Substitution Principle), ISP (Interface Segregation Principle) и DIP (Dependency Inversion Principle). SRP требует, чтобы у класса была только одна зона ответственности. OCP говорит, что сущности должны быть открыты для расширения, но закрыты для модификации. LSP утверждает, что наследники должны корректно подменять базовые типы. ISP призывает разделять крупные интерфейсы на небольшие специализированные. DIP рекомендует зависеть от абстракций, а не от конкретных реализаций. Аннотации в Java представляют собой механизм добавления метаданных к коду (классам, методам, полям и т.д.). Они объявляются с помощью конструкции @interface и могут иметь область видимости до исходников, до байткода или до времени выполнения (RetentionPolicy.SOURCE, CLASS, RUNTIME). Встроенные аннотации (@Override, @Deprecated) и пользовательские аннотации активно используются во фреймворках и инструментах. Reflection API в Java позволяет анализировать и модифицировать структуру программы во время выполнения. С помощью класса Class и связанных с ним типов (Method, Field, Constructor) можно получать сведения о методах, полях, конструкторах, вызывать их и читать аннотации. Это даёт возможность строить гибкие, расширяемые системы, но требует аккуратного использования из‑за накладных расходов и усложнения кода. 3. Постановка задачи Необходимо разработать консольное приложение для управления книгами в библиотеке. Приложение должно демонстрировать применение принципов SOLID, работу с аннотациями и использование рефлексии. Основные требования к программе: — хранение данных о книгах (название, автор); — поддержка различных стратегий поиска книг (по названию, по автору); — реализация системы уведомлений о новых поступлениях (e‑mail и SMS‑уведомления); — введение пользовательской аннотации @ImportantBook и чтение её через Reflection API; — вывод информации о методах класса Library с помощью Reflection API. 4. Структура и описание программы Программа реализована на языке Java и состоит из следующих основных элементов: 1) Класс Book — модель книги (поля title и author, геттеры). На геттере getTitle используется кастомная аннотация @ImportantBook, помечающая книги, важные для изучения лучших практик. 2) Интерфейс BookSearch — абстракция для стратегий поиска книг (принцип OCP). Имеет один метод List<Book> search(String query). 3) Классы AuthorSearch и TitleSearch — конкретные стратегии поиска по автору и по названию, работающие со списком книг библиотеки (демонстрация SRP, OCP, LSP). 4) Класс Library — инкапсулирует коллекцию книг, отвечает за добавление и поиск книг через переданную стратегию BookSearch. Класс не зависит от конкретных реализаций поиска (LSP, OCP). 5) Интерфейс NotificationService и его реализации EmailNotificationService и SMSNotificationService — узкий интерфейс для отправки уведомлений и две реализации, различающиеся способом оповещения (ISP). 6) Класс NotificationManager — менеджер уведомлений, зависящий от абстракции NotificationService, а не от конкретного класса (демонстрация DIP). Способ уведомления можно легко сменить за счёт передачи другой реализации в конструктор. 7) Аннотация @ImportantBook с политикой хранения RUNTIME — позволяет считывать её во время выполнения через Reflection API. 8) Класс ReflectionDemo — демонстрирует работу Reflection API: анализирует методы класса Book на предмет наличия аннотации @ImportantBook и перечисляет методы класса Library с их параметрами. 9) Класс LibraryApp с методом main — точка входа приложения. Создаёт библиотеку, добавляет тестовые книги, выполняет поиск по названию и автору, отправляет уведомления и запускает примеры работы ReflectionDemo. 5. Листинг основных классов import java.util.ArrayList; import java.util.List; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.reflect.Method; import java.io.PrintStream; import java.nio.charset.StandardCharsets; class Book { private String title; private String author; public Book(String title, String author) { this.title = title; this.author = author; } @ImportantBook(reason = \"Рекомендуется для изучения лучших практик\") public String ge tTitle() { return title; } public String getAuthor() { return author; } } interface BookSearch { List<Book> search(String query); } class AuthorSearch implements BookSearch { private List<Book> books; public AuthorSearch(List<Book> books) { this.books = books; } @Override public List<Book> search(String query) { List<Book> result = new ArrayList<>(); for (Book book : books) { if (book.getAuthor().toLowerCase().conta ins(query.toLowerCase())) { result.add(book); } } return result; } } class TitleSearch implements BookSearch { private List<Book> books; public TitleSearch(List<Book> books) { this.books = books; } @Override public List<Book> search(String query) { List<Book> result = new ArrayList<>(); for (Book book : books) { if (book.getTitle().toLowerCase().contains(query.toLowerCase())) { result.add(book); } } return result; } } class Library { private List<Book> books; public Library() { this.books = new ArrayList<>(); } public void addBook(Book book) { books.add(book); } public List<Book> searchBooks(BookSearch searchStrategy, String query) { return searchStrategy.search(query); } public List<Book> getBooks() { return books; } } interface NotificationService { void notify(String message); } class EmailNotificationSe rvice implements NotificationService { @Override public void notify(String message) { System.out.println(\"Email: \" + message); } } class SMSNotificationService implements NotificationService { @Override public void notify(String message) { System.out.println(\"SMS: \" + message); } } class NotificationManager { private NotificationService notificationService; public NotificationManager(NotificationService notificationService) { this.notificationService = notificationService; } public void sendNotification(String message) { notificationService.notify(message); } } @Retention(RetentionPolicy.RUNTIME) @interface ImportantBook { String reason() default \"Классика\"; } class ReflectionDemo { public static void analyzeBookClass() { Class<Book> bookClass = Book.class; System.out.println(\" \\ nАнализ аннотаций класса Book:\"); for (Method method : bookClass.getDeclaredMethods()) { if (method.isAnnotationPresent(ImportantBook.class)) { ImportantBook annotation = method.getAnnotation(ImportantBook.class); System.out.println(\"Метод \" + method.getName() + \" помечен как важный. Причина: \" + annotation.reason()); } } } public static void listLibraryMethods() { Class<Library> libraryClass = Library.class; System.out.println(\" \\ nМетоды класса Library:\"); for (Method method : libraryClass.getDeclaredMethods()) { System.out.print(method.getName() + \"(\"); Class<?>[] params = method.getParameterTypes(); for (int i = 0; i < params.length; i++) { System.out.print(params[i].getSimpleName()); if (i < params.l ength - 1) System.out.print(\", \"); } System.out.println(\")\"); } } } public class LibraryApp { public static void main(String[] args) throws Exception { System.setOut(new PrintStream(System.out, true, StandardCharsets.UTF_8)); Library library = new Library(); library.addBook(new Book(\"Effective Java\", \"Joshua Bloch\")); library.addBook(new Book(\"Clean Code\", \"Robert C. Martin\")); library.addBook(new Book(\"Java Concurrency in Pra ctice\", \"Brian Goetz\")); BookSearch titleSearch = new TitleSearch(library.getBooks()); List<Book> foundBooks = library.searchBooks(titleSearch, \"Java\"); System.out.println(\" \\ nНайденные книги по заголовку:\"); for (Book book : foundBooks) { System.out.println(book.getTitle() + \" — \" + book.getAuthor()); } BookSearch authorSearch = new AuthorSearch(library.getBooks()); List<Book> foundByAuthor = library.searchBooks(authorSearch, \"Martin\"); System.out.println(\" \\ nНайденные книги по автору:\"); for (Book book : foundByAuthor) { System.out.println(book.getTitle() + \" — \" + book.getAuthor()); } NotificationManager notificationManager = new NotificationManager(new EmailNotificationService()); notificationManager.sendNotification(\"Новая книга поступила в библиотеку!\"); notificationManager = new NotificationManager(new SMSNotificationService()); notificationManager.sendNotification(\"Новая книга доступна для чтения!\"); ReflectionDemo.analyzeBookClass(); ReflectionDemo.listLibraryMethods(); } } 6. Примеры работы программы При запуске программы создаются три книги: \"Effective Java\", \"Clean Code\", \"Java Concurrency in Practice\". Далее демонстрируются два варианта поиска: — поиск по заголовку с запросом \"Java\" — выводятся книги, в названии которых есть подсрока \"Java\"; — поиск по автору с запросом \"Martin\" — выводится список книг, автор которых содержит \"Martin\". Затем демонстрируется работа системы уведомлений: сначала отправляется уведомление по e‑mail, затем по SMS. В консоль выводятся соответствующие строки с префиксами \"Email:\" и \"SMS:\". Далее запускается модуль ReflectionDemo. Сначала он анализирует класс Book, находит метод getTitle, помеченный аннотацией @ImportantBook, и выводит причину важности. Затем перечисляет методы класса Library с указанием их параметров. 7. Выводы В ходе лабораторной работы были изучены и практически применены принципы SOLID, механизм аннотаций и API рефлексии Java. На примере приложения «Библиотека» показано, как с помощью интерфейсов и абстракций добиться гибкости и расширяемости кода, а также как использовать пользовательские аннотации и Reflection API для анализа структуры классов на этапе выполнения. Реализация подтвердила, что соблюдение SOLID - принципов упрощает сопровождение и развитие программного обеспечения. 8. Список использованных источников [1] Принципы SOLID. URL: https://web - creator.ru/articles/solid [2] Принципы SOLID в программировании. URL: https://blog.skillfactory.ru/printsipy - solid - v - programmirovanii/ [3] Официальная документация Oracle по Reflection API и аннотациям.",
      "wordCount": 1246,
      "uploadDate": "2025-11-26T17:50:35.862Z",
      "category": "diploma",
      "minhashSignature": [
        414694,
        321551,
        35456,
        63569,
        255410,
        774298,
        1419586,
        32474,
        692487,
        463133,
        310703,
        166580,
        244215,
        516653,
        87475,
        781702,
        774270,
        80489,
        375486,
        614991,
        420454,
        315235,
        32893,
        233991,
        30160,
        544551,
        52568,
        141314,
        1126017,
        326667,
        2373,
        154981,
        1198814,
        692404,
        685288,
        643395,
        196844,
        514002,
        260915,
        46667,
        120895,
        383870,
        1322590,
        127195,
        491081,
        181929,
        1672881,
        1529290,
        694398,
        12464,
        197435,
        1011640,
        765876,
        590010,
        322072,
        262281,
        320302,
        429139,
        539774,
        79411,
        328632,
        53725,
        136726,
        425987,
        869157,
        569104,
        17621,
        925624,
        100004,
        686839,
        200468,
        1194770,
        338482,
        4509,
        17347,
        60981,
        39245,
        620051,
        1739734,
        151169,
        526692,
        41943,
        46543,
        389716,
        352790,
        10874,
        369610,
        234420,
        516233,
        269742,
        250810,
        157689,
        569104,
        67318,
        128544,
        251282,
        224365,
        306390,
        21971,
        461600,
        1964613,
        805,
        29089,
        53465,
        753519,
        7003,
        456585,
        750597,
        246,
        153133,
        159740,
        151173,
        522062,
        10847,
        630893,
        32343,
        255065,
        499971,
        86312,
        321176,
        868430,
        117086,
        298707,
        1380406,
        410356,
        16049,
        943289,
        500614
      ],
      "shingleCount": 4610
    },
    {
      "id": 11,
      "title": "laba8",
      "author": "Фурсов Артем Валерьевич",
      "filename": "laba8.pdf",
      "filePath": "data/uploads/1764179456623_laba8.pdf",
      "content": "Лабораторная работа №6 «Эффективные принципы проектирования SOLID, аннотации и механизмы API reflection ПО» Вариант 5 1. Цель работы Изучить на практике принципы проектирования SOLID, механизмы аннотаций и API рефлексии в Java. Реализовать консольное приложение «Библиотека», демонстрирующее использование SOLID - подхода, кастомных аннотаций и Reflection API для анализа кода во время выполнения. 2. Краткая теоретическая часть Принципы SOLID — это набор рекомендаций по проектированию объектно - ориентированных систем, предложенный Робертом Мартином. Они включают: SRP (Single Responsibility Principle), OCP (Open/Closed Principle), LSP (Liskov Substitution Principle), ISP (Interface Segregation Principle) и DIP (Dependency Inversion Principle). SRP требует, чтобы у класса была только одна зона ответственности. OCP говорит, что сущности должны быть открыты для расширения, но закрыты для модификации. LSP утверждает, что наследники должны корректно подменять базовые типы. ISP призывает разделять крупные интерфейсы на небольшие специализированные. DIP рекомендует зависеть от абстракций, а не от конкретных реализаций. Аннотации в Java представляют собой механизм добавления метаданных к коду (классам, методам, полям и т.д.). Они объявляются с помощью конструкции @interface и могут иметь область видимости до исходников, до байткода или до времени выполнения (RetentionPolicy.SOURCE, CLASS, RUNTIME). Встроенные аннотации (@Override, @Deprecated) и пользовательские аннотации активно используются во фреймворках и инструментах. Reflection API в Java позволяет анализировать и модифицировать структуру программы во время выполнения. С помощью класса Class и связанных с ним типов (Method, Field, Constructor) можно получать сведения о методах, полях, конструкторах, вызывать их и читать аннотации. Это даёт возможность строить гибкие, расширяемые системы, но требует аккуратного использования из‑за накладных расходов и усложнения кода. 3. Постановка задачи Необходимо разработать консольное приложение для управления книгами в библиотеке. Приложение должно демонстрировать применение принципов SOLID, работу с аннотациями и использование рефлексии. Основные требования к программе: — хранение данных о книгах (название, автор); — поддержка различных стратегий поиска книг (по названию, по автору); — реализация системы уведомлений о новых поступлениях (e‑mail и SMS‑уведомления); — введение пользовательской аннотации @ImportantBook и чтение её через Reflection API; — вывод информации о методах класса Library с помощью Reflection API. 4. Структура и описание программы Программа реализована на языке Java и состоит из следующих основных элементов: 1) Класс Book — модель книги (поля title и author, геттеры). На геттере getTitle используется кастомная аннотация @ImportantBook, помечающая книги, важные для изучения лучших практик. 2) Интерфейс BookSearch — абстракция для стратегий поиска книг (принцип OCP). Имеет один метод List<Book> search(String query). 3) Классы AuthorSearch и TitleSearch — конкретные стратегии поиска по автору и по названию, работающие со списком книг библиотеки (демонстрация SRP, OCP, LSP). 4) Класс Library — инкапсулирует коллекцию книг, отвечает за добавление и поиск книг через переданную стратегию BookSearch. Класс не зависит от конкретных реализаций поиска (LSP, OCP). 5) Интерфейс NotificationService и его реализации EmailNotificationService и SMSNotificationService — узкий интерфейс для отправки уведомлений и две реализации, различающиеся способом оповещения (ISP). 6) Класс NotificationManager — менеджер уведомлений, зависящий от абстракции NotificationService, а не от конкретного класса (демонстрация DIP). Способ уведомления можно легко сменить за счёт передачи другой реализации в конструктор. 7) Аннотация @ImportantBook с политикой хранения RUNTIME — позволяет считывать её во время выполнения через Reflection API. 8) Класс ReflectionDemo — демонстрирует работу Reflection API: анализирует методы класса Book на предмет наличия аннотации @ImportantBook и перечисляет методы класса Library с их параметрами. 9) Класс LibraryApp с методом main — точка входа приложения. Создаёт библиотеку, добавляет тестовые книги, выполняет поиск по названию и автору, отправляет уведомления и запускает примеры работы ReflectionDemo. 5. Листинг основных классов import java.util.ArrayList; import java.util.List; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.reflect.Method; import java.io.PrintStream; import java.nio.charset.StandardCharsets; class Book { private String title; private String author; public Book(String title, String author) { this.title = title; this.author = author; } @ImportantBook(reason = \"Рекомендуется для изучения лучших практик\") public String ge tTitle() { return title; } public String getAuthor() { return author; } } interface BookSearch { List<Book> search(String query); } class AuthorSearch implements BookSearch { private List<Book> books; public AuthorSearch(List<Book> books) { this.books = books; } @Override public List<Book> search(String query) { List<Book> result = new ArrayList<>(); for (Book book : books) { if (book.getAuthor().toLowerCase().conta ins(query.toLowerCase())) { result.add(book); } } return result; } } class TitleSearch implements BookSearch { private List<Book> books; public TitleSearch(List<Book> books) { this.books = books; } @Override public List<Book> search(String query) { List<Book> result = new ArrayList<>(); for (Book book : books) { if (book.getTitle().toLowerCase().contains(query.toLowerCase())) { result.add(book); } } return result; } } class Library { private List<Book> books; public Library() { this.books = new ArrayList<>(); } public void addBook(Book book) { books.add(book); } public List<Book> searchBooks(BookSearch searchStrategy, String query) { return searchStrategy.search(query); } public List<Book> getBooks() { return books; } } interface NotificationService { void notify(String message); } class EmailNotificationSe rvice implements NotificationService { @Override public void notify(String message) { System.out.println(\"Email: \" + message); } } class SMSNotificationService implements NotificationService { @Override public void notify(String message) { System.out.println(\"SMS: \" + message); } } class NotificationManager { private NotificationService notificationService; public NotificationManager(NotificationService notificationService) { this.notificationService = notificationService; } public void sendNotification(String message) { notificationService.notify(message); } } @Retention(RetentionPolicy.RUNTIME) @interface ImportantBook { String reason() default \"Классика\"; } class ReflectionDemo { public static void analyzeBookClass() { Class<Book> bookClass = Book.class; System.out.println(\" \\ nАнализ аннотаций класса Book:\"); for (Method method : bookClass.getDeclaredMethods()) { if (method.isAnnotationPresent(ImportantBook.class)) { ImportantBook annotation = method.getAnnotation(ImportantBook.class); System.out.println(\"Метод \" + method.getName() + \" помечен как важный. Причина: \" + annotation.reason()); } } } public static void listLibraryMethods() { Class<Library> libraryClass = Library.class; System.out.println(\" \\ nМетоды класса Library:\"); for (Method method : libraryClass.getDeclaredMethods()) { System.out.print(method.getName() + \"(\"); Class<?>[] params = method.getParameterTypes(); for (int i = 0; i < params.length; i++) { System.out.print(params[i].getSimpleName()); if (i < params.l ength - 1) System.out.print(\", \"); } System.out.println(\")\"); } } } public class LibraryApp { public static void main(String[] args) throws Exception { System.setOut(new PrintStream(System.out, true, StandardCharsets.UTF_8)); Library library = new Library(); library.addBook(new Book(\"Effective Java\", \"Joshua Bloch\")); library.addBook(new Book(\"Clean Code\", \"Robert C. Martin\")); library.addBook(new Book(\"Java Concurrency in Pra ctice\", \"Brian Goetz\")); BookSearch titleSearch = new TitleSearch(library.getBooks()); List<Book> foundBooks = library.searchBooks(titleSearch, \"Java\"); System.out.println(\" \\ nНайденные книги по заголовку:\"); for (Book book : foundBooks) { System.out.println(book.getTitle() + \" — \" + book.getAuthor()); } BookSearch authorSearch = new AuthorSearch(library.getBooks()); List<Book> foundByAuthor = library.searchBooks(authorSearch, \"Martin\"); System.out.println(\" \\ nНайденные книги по автору:\"); for (Book book : foundByAuthor) { System.out.println(book.getTitle() + \" — \" + book.getAuthor()); } NotificationManager notificationManager = new NotificationManager(new EmailNotificationService()); notificationManager.sendNotification(\"Новая книга поступила в библиотеку!\"); notificationManager = new NotificationManager(new SMSNotificationService()); notificationManager.sendNotification(\"Новая книга доступна для чтения!\"); ReflectionDemo.analyzeBookClass(); ReflectionDemo.listLibraryMethods(); } } 6. Примеры работы программы При запуске программы создаются три книги: \"Effective Java\", \"Clean Code\", \"Java Concurrency in Practice\". Далее демонстрируются два варианта поиска: — поиск по заголовку с запросом \"Java\" — выводятся книги, в названии которых есть подсрока \"Java\"; — поиск по автору с запросом \"Martin\" — выводится список книг, автор которых содержит \"Martin\". Затем демонстрируется работа системы уведомлений: сначала отправляется уведомление по e‑mail, затем по SMS. В консоль выводятся соответствующие строки с префиксами \"Email:\" и \"SMS:\". Далее запускается модуль ReflectionDemo. Сначала он анализирует класс Book, находит метод getTitle, помеченный аннотацией @ImportantBook, и выводит причину важности. Затем перечисляет методы класса Library с указанием их параметров. 7. Выводы В ходе лабораторной работы были изучены и практически применены принципы SOLID, механизм аннотаций и API рефлексии Java. На примере приложения «Библиотека» показано, как с помощью интерфейсов и абстракций добиться гибкости и расширяемости кода, а также как использовать пользовательские аннотации и Reflection API для анализа структуры классов на этапе выполнения. Реализация подтвердила, что соблюдение SOLID - принципов упрощает сопровождение и развитие программного обеспечения. 8. Список использованных источников [1] Принципы SOLID. URL: https://web - creator.ru/articles/solid [2] Принципы SOLID в программировании. URL: https://blog.skillfactory.ru/printsipy - solid - v - programmirovanii/ [3] Официальная документация Oracle по Reflection API и аннотациям.",
      "wordCount": 1246,
      "uploadDate": "2025-11-26T17:50:56.666Z",
      "category": "diploma",
      "minhashSignature": [
        414694,
        321551,
        35456,
        63569,
        255410,
        774298,
        1419586,
        32474,
        692487,
        463133,
        310703,
        166580,
        244215,
        516653,
        87475,
        781702,
        774270,
        80489,
        375486,
        614991,
        420454,
        315235,
        32893,
        233991,
        30160,
        544551,
        52568,
        141314,
        1126017,
        326667,
        2373,
        154981,
        1198814,
        692404,
        685288,
        643395,
        196844,
        514002,
        260915,
        46667,
        120895,
        383870,
        1322590,
        127195,
        491081,
        181929,
        1672881,
        1529290,
        694398,
        12464,
        197435,
        1011640,
        765876,
        590010,
        322072,
        262281,
        320302,
        429139,
        539774,
        79411,
        328632,
        53725,
        136726,
        425987,
        869157,
        569104,
        17621,
        925624,
        100004,
        686839,
        200468,
        1194770,
        338482,
        4509,
        17347,
        60981,
        39245,
        620051,
        1739734,
        151169,
        526692,
        41943,
        46543,
        389716,
        352790,
        10874,
        369610,
        234420,
        516233,
        269742,
        250810,
        157689,
        569104,
        67318,
        128544,
        251282,
        224365,
        306390,
        21971,
        461600,
        1964613,
        805,
        29089,
        53465,
        753519,
        7003,
        456585,
        750597,
        246,
        153133,
        159740,
        151173,
        522062,
        10847,
        630893,
        32343,
        255065,
        499971,
        86312,
        321176,
        868430,
        117086,
        298707,
        1380406,
        410356,
        16049,
        943289,
        500614
      ],
      "shingleCount": 4610
    },
    {
      "id": 27,
      "title": "stsr",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "stsr.pdf",
      "filePath": "data/uploads/1769469845401_stsr.pdf",
      "content": ". 1 Классификация фреймворков сборки. Жизненный цикл. Maven Фреймворки автоматизированной сборки предназначены для управления процессом компиляции, тестирования, упаковки и развёртывания программного обеспечения . Они позволяют стандартизировать сборку проекта и исключить ручные действия. По принципу работы фреймворки сборки делятся на: • Скриптовые ( Ant) — сборка описывается последовательностью шагов • Декларативные ( Maven, Gradle) — описывается структура проекта и зависимости Apache Maven является декларативным фреймворком и основан на понятии жизненного цикла сборки . Жизненный цикл — это строго определённая последовательность фаз, которые выполняются при сборке проекта: • validate • compile • test • package • install • deploy Maven широко применяется в промышленной разработке благодаря: • централизованному управлению зависимостями • повторяемости сборки • поддержке CI/CD • большому количеству плагинов Пример pom.xml <project> <modelVersion>4.0.0</modelVersion> <groupId>org.example</groupId> <artifactId>demo - app</artifactId> <version>1.0.0</version> <packaging>jar</packaging> </project> 2 . pom.xml, команды Maven, плагины и архетипы Файл pom.xml (Project Object Model) является центральным конфигурационным файлом Maven. В нём описываются: • координаты проекта • зависимости • плагины • жизненный цикл сборки Основные команды Maven: • mvn clean — очистка сборки • mvn compile — компиляция • mvn test — запуск тестов • mvn package — упаковка ( JAR/WAR) Архетипы Maven — это шаблоны проектов, которые позволяют быстро создать стандартную структуру приложения. Плагины Maven расширяют возможности сборки и выполняют конкретные задачи Пример плагина компиляции <build> <plugins> <plugin> <artifactId>maven - compiler - plugin</artifactId> . <version>3.10.1</version> <configuration> <source>8</source> <target>8</target> </configuration> </plugin> </plugins></build> 3 Понятие персистенции. Отличие от сериализации и маршаллинга Персистенция — это способность объекта сохранять своё состояние между запусками приложения, как правило, путём хранения в базе данных. Отличия: • Персистенция — долговременное хранение (БД) • Сериализация — преобразование объекта в поток байт (файл, сеть) • Маршаллинг — преобразование объекта в формат обмена ( XML, JSON) Персистенция обычно реализуется через ORM - фреймворки (Hibernate, JPA), которые автоматически отображают объектную модель на реляционную БД. Пример персистентного класса @Entity public class User { @Id @GeneratedValue private Long id; private String username; } 4. Роль DAO. JDBC и ODBC Data Access Object (DAO) — шаблон проектирования, который инкапсулирует логику доступа к данным и отделяет бизнеслогику от работы с БД. Преимущества DAO: • упрощение поддержки кода • изоляция SQL • возможность замены источника данных JDBC (Java Database Connectivity) — стандарт Java для работы с БД. ODBC (Open Database Connectivity) — универсальный интерфейс, независимый от языка программирования. JDBC: • ориентирован на Java • типобезопасен • быстрее и удобнее в Java - приложениях Пример DAO public class UserDAO { private Connection connection; public User findById(long id) { return null; } } 5. Statement, PreparedStatement, CallableStatement В JDBC существуют три основных интерфейса для выполнения SQL - запросов: • Statement — используется для простых SQL - запросов • PreparedStatement — поддерживает параметры, защищает от SQL - инъекций • CallableStatement — предназначен для вызова хранимых процедур PreparedStatement предпочтительнее, так как: • повышает производительность . • безопасен • поддерживает повторное использование Пример PreparedStatement PreparedStatement ps = connection.prepareStatement( \"SELECT * FROM users WHERE id = ?\" ); ps.setLong(1, 10); ResultSet rs = ps.executeQuery(); 6 Цель и возможности управления персистентностью. Транзакции в JDBC Управление персистентностью направлено на обеспечение корректного, надёжного и согласованного хранения данных между запусками приложения. Основные цели: • сохранение целостности данных; • контроль изменений объектов; • поддержка атомарности операций; • обработка ошибок при работе с БД. Транзакция в JDBC — это логическая единица работы, состоящая из нескольких SQL - операций, которые должны выполниться либо полностью, либо не выполниться вовсе. По умолчанию JDBC работает в режиме autoCommit = true , при котором каждая операция фиксируется автоматически. Основные операции управления транзакциями: • setAutoCommit(false) • commit() • rollback() Пример транзакции JDBC Connection con = dataSource.getConnection(); con.setAutoCommit(false); Statement st = con.createStatement(); st.executeUpdate(\"INSERT INTO users VALUES (1,'Alex')\"); st.executeUpdate(\"INSERT INTO profiles VALUES (1,'admin')\"); con.commit(); con.close(); 7 . Выборка и хранение данных с использованием ResultSet ResultSet — это объект JDBC, представляющий результат выполнения SQL - запроса SELECT . Он позволяет построчно получать данные из результата запроса. Основные возможности ResultSet: • последовательный доступ к данным ( next() ); • получение значений по имени или индексу столбца; • поддержка разных режимов прокрутки ( forward - only, scrollable); • обновление данных напрямую из ResultSet ( при соответствующей конфигурации). ResultSet тесно связан с Statement и Connection, и существует только пока они открыты. Пример работы с ResultSet Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT id, name FROM users\"); while (rs.next()) { long id = rs.getLong(\"id\"); String name = rs.getString(\"name\"); System.out.println(id + \" \" + name); } 8 . Современные форматы данных. XML. Маршаллинг и JAXB XML долгое время являлся основным форматом обмена данными между системами. Его преимущества — строгая структура и расширяемость, недостатки — избыточность и большой объём. Маршаллинг ( marshalling) — процесс преобразования объекта в формат передачи данных ( XML или JSON). JAXB (Java Architecture for XML Binding) — стандарт Java для преобразования Java - объектов в XML и обратно. JAXB использует аннотации для описания соответствия между классами и XML - структурой. Пример JAXB маршаллинга JAXBContext context = JAXBContext.newInstance(User.class); Marshaller marshaller = context.createMarshaller(); marshaller.setProperty( Marshaller.JAXB_FORMATTED_OUTPUT, true ); marshaller.marshal(user, System.out); 9. Современные форматы данных. JSON. Маршаллинг и Gson JSON постепенно вытеснил XML благодаря компактности, простоте чтения и лёгкой интеграции с web - приложениями. Gson — библиотека Google для сериализации и десериализации Java - объектов в JSON. Она: • не требует аннотаций по умолчанию; • легко интегрируется с REST API; • поддерживает коллекции и вложенные объекты. Gson активно используется в клиент - серверных и микросервисных архитектурах. Пример использования Gson Gson gson = new Gson(); User user = new User(1L, \"Alex\"); String json = gson.toJson(user); User parsedUser = gson.fromJson(json, User.class); 10. Назначение, форматы и специфика применения JSON JSON (JavaScript Object Notation) — текстовый формат обмена данными, широко применяемый в web - приложениях, REST API и микросервисах. Основные особенности JSON: • структура «ключ – значение»; • поддержка массивов и вложенных объектов; • независимость от языка программирования; • компактность по сравнению с XML. JSON чаще всего используется: • при обмене данными между frontend и backend; • в REST - сервисах; • при передаче конфигураций и сообщений. Пример JSON - объекта и обработки в Java String json = \"{ \\ \"id \\ \":1, \\ \"name \\ \": \\ \"Alex \\ \"}\"; JsonObject obj = JsonParser.parseString(json) .getAsJsonObject(); System.out.println(obj.get(\"name\").getAsString()); 11. Применение событийного парсера XML документов Событийный парсер XML используется для обработки XML документов без загрузки всего файла в память . Это особенно важно при работе с большими XML - файлами. В Java наиболее распространённым событийным парсером является SAX (Simple API for XML) . Принцип работы SAX - парсера основан на событиях: • начало элемента ( startElement ) • конец элемента ( endElement ) • обработка текстовых данных ( characters ) Основное преимущество SAX — высокая производительность и минимальное потребление памяти. Недостатком является сложность логики обработки, так как данные обрабатываются последовательно. Пример SAX - парсера SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser parser = factory.newSAXParser(); DefaultHandler handler = new DefaultHandler() { public void startElement(String uri, String local, String qName, Attributes a) { System.out.println(\"Start: \" + qName); } }; parser.parse(new File(\"data.xml\"), handler); 12. Классификация и возможности систем контроля версий Система контроля версий (СКВ) — это программный инструмент, предназначенный для управления изменениями в исходном коде и документации. СКВ классифицируются на: 1. Локальные — история хранится локально ( RCS) 2. Централизованные — единый сервер ( SVN, CVS) 3. Распределённые — у каждого разработчика полный репозиторий ( Git, Mercurial) Распределённые СКВ обладают преимуществами: • автономная работа • высокая надёжность • гибкое ветвление Пример инициализации Git - репозитория git init git status git add . git commit - m \"Initial commit\" 13 . Хостинг репозиториев GitHub и его возможности GitHub — облачная платформа для хостинга Git - репозиториев и совместной разработки ПО. Основные возможности GitHub: • хранение репозиториев; • Pull Request и Code Review; • управление задачами ( Issues); • CI/CD через GitHub Actions; • контроль доступа и ролей. GitHub широко используется в командной разработке и opensource проектах. Пример отправки проекта на GitHub git remote add origin https://github.com/user/repo.git git branch - M main git push - u origin main 14 . Применение репозитория Git. Основные команды Git — распределённая система контроля версий, позволяющая эффективно управлять разработкой ПО. Основные команды Git: • clone — клонирование репозитория • add — добавление файлов в индекс • commit — фиксация изменений • pull — получение обновлений • push — отправка изменений Git обеспечивает безопасную и параллельную работу нескольких разработчиков. Пример стандартного рабочего процесса git clone https://github.com/user/repo.git cd repo git add src/Main.java git commit - m \"Add main class\" git pull git push 15. Понятие ветвей Git. Слияние ветвей Ветка ( branch) в Git — это независимая линия разработки, позволяющая разрабатывать функциональность параллельно с основной версией проекта. Основные операции с ветками: • создание ветки; • переключение между ветками; • слияние ( merge); • разрешение конфликтов. Ветки обеспечивают безопасную разработку новых функций без риска повредить основной код. Пример работы с ветками git branch feature - auth git checkout feature - auth git commit - am \"Add auth logic\" git checkout main git merge feature - auth 16. Назначение и возможности Java Persistence API (JPA). POJO и Entity Java Persistence API (JPA) — это спецификация Java, предназначенная для управления персистентностью объектов и их хранения в реляционных базах данных. JPA определяет набор интерфейсов и аннотаций, но не является конкретной реализацией. Реализациями JPA являются Hibernate, EclipseLink и другие. POJO (Plain Old Java Object) — это обычный Java - класс без зависимостей от фреймворков. Такие классы удобны для тестирования и повторного использования. Чтобы объект стал персистентным, POJO необходимо преобразовать в Entity , добавив аннотации JPA. Entity - класс: • соответствует таблице БД; • имеет уникальный идентификатор; • управляется JPA - контейнером. Пример преобразования POJO в Entity @Entity @Table(name = \"clients\") public class Client { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; } 17 . Персистенция объектов. ORM. Сравнение JPA и JDBC Object - Relational Mapping (ORM) — технология, которая автоматически связывает объектную модель приложения с реляционной моделью базы данных. ORM скрывает SQL - код и позволяет работать с БД через объекты. JPA использует ORM - подход и предоставляет: • автоматическое управление SQL; • кэширование; • управление транзакциями; • декларативные связи между сущностями. JDBC , в отличие от JPA: • требует ручного написания SQL; • не управляет объектным состоянием; • даёт более низкоуровневый контроль. JPA упрощает разработку, JDBC используется там, где нужен максимальный контроль. Пример сохранения объекта через JPA EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); Client client = new Client(); client.setName(\"Alex\"); em.persist(client); em.getTransaction().commit(); 18 . Hibernate как реализация ORM. Компоненты. HQL Hibernate — наиболее популярная реализация спецификации JPA. Он предоставляет расширенные возможности по сравнению с чистым JPA. Основные компоненты Hibernate: • SessionFactory — фабрика сессий; • Session — контекст работы с БД; • Transaction — управление транзакциями; • Query — выполнение запросов. Hibernate поддерживает HQL (Hibernate Query Language) — объектно - ориентированный язык запросов, независимый от конкретной СУБД. Пример HQL - запроса Session session = sessionFactory.openSession(); Query<Client> query = session.createQuery(\"from Client\", Client.class); List<Client> clients = query.list(); session.close(); 19 . EntityManager и SessionFactory. CRUD операции EntityManager — основной интерфейс JPA для управления жизненным циклом сущностей. SessionFactory — объект Hibernate, создающий сессии для работы с БД. CRUD - операции: • Create — persist • Read — find , get • Update — merge • Delete — remove EntityManager автоматически отслеживает изменения сущностей в рамках транзакции. Пример CRUD через EntityManager EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); Client client = em.find(Client.class, 1L); client.setName(\"Updated Name\"); em.getTransaction().commit(); em.close(); 20. Транзакции и состояния объектов. Criteria API В JPA и Hibernate объект может находиться в одном из состояний: • Transient — не связан с БД • Persistent — управляется контекстом • Detached — отсоединён от контекста • Removed — помечен на удаление Criteria API предназначен для создания типобезопасных запросов без использования строкового HQL или SQL. Он удобен для динамического построения запросов. Пример запроса Criteria API CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery<Client> cq = cb.createQuery(Client.class); Root<Client> root = cq.from(Client.class); cq.select(root).where(cb.equal(root.get(\"name\"), \"Alex\")); List<Client> result = em.createQuery(cq).getResultList(); 21. Осуществление запросов в базу данных посредством стандартных методов Hibernate Hibernate предоставляет несколько способов выполнения запросов к базе данных, что позволяет выбирать оптимальный вариант в зависимости от задачи. Основные подходы: • HQL (Hibernate Query Language) — объектноориентированный язык запросов; • Criteria API — типобезопасный программный способ построения запросов; • Native SQL — выполнение «чистых» SQL - запросов. Преимущество Hibernate - запросов заключается в том, что разработчик оперирует сущностями и их свойствами , а не таблицами и колонками, что повышает переносимость кода между СУБД. Пример HQL - запроса Session session = sessionFactory.openSession(); Query<Client> query = session.createQuery(\"from Client where age > :age\", Client.class); query.setParameter(\"age\", 18); List<Client> clients = query.list(); session.close(); 22. Маппинг классов и связи 1:1, 1:М, М:1 Маппинг — это процесс сопоставления Java - классов с таблицами базы данных. В JPA/Hibernate связи между сущностями задаются с помощью аннотаций. Основные типы связей: • One - to - One (1:1) — один объект соответствует одному; • One - to - Many (1:М) — один объект связан с несколькими; • Many - to - One ( М:1) — несколько объектов связаны с одним. Корректный маппинг связей позволяет Hibernate автоматически управлять внешними ключами и загрузкой данных. Пример связи One - to - Many @Entity class Trainer { @Id @GeneratedValue Long id; @OneToMany(mappedBy = \"trainer\") List<Client> clients; } 23. Маппинг классов и связи М:М (Many - to - Many) Связь Many - to - Many означает, что нескольким объектам одного класса соответствуют несколько объектов другого класса. В реляционных БД такая связь реализуется через промежуточную таблицу . В Hibernate для этого используется аннотация @ ManyToMany , а также @JoinTable для указания таблицы связей. Связь М:М часто применяется, например, между пользователями и ролями. Пример связи Many - to - Many @Entity class User { @Id @GeneratedValue Long id; @ManyToMany @JoinTable( name = \"user_roles\", joinColumns = @JoinColumn(name = \"user_id\"), inverseJoinColumns = @JoinColumn(name = \"role_id\") ) Set<Role> roles; } 24. Отладка и тестирование в IDE. Точки останова Отладка ( debugging) — процесс поиска и исправления ошибок в программе с использованием инструментов среды разработки (IntelliJ IDEA, Eclipse). Основные возможности отладки: • установка точек останова ( breakpoints) ; • пошаговое выполнение кода; • просмотр значений переменных; • анализ стека вызовов. Преимущество отладки — точное понимание поведения программы. Недостаток — невозможность выявить все логические ошибки без тестирования. Пример кода с точкой останова public void calculate() { int a = 10; // breakpoint int b = 5; int result = a / b; System.out.println(result); } 25. Модульное тестирование. Reflection API и JUnit Модульное тестирование направлено на проверку отдельных компонентов (методов, классов) программы в изоляции. JUnit — основной фреймворк для модульного тестирования в Java. Он позволяет: • автоматизировать тестирование; • проверять ожидаемые результаты; • интегрироваться с Maven и CI - системами. Reflection API может использоваться для тестирования приватных методов и анализа структуры классов, однако применять его следует осторожно. Пример JUnit - теста class CalculatorTest { @Test void sumTest() { Calculator calc = new Calculator(); int result = calc.sum(2, 3); assertEquals(5, result); } } 26. Параметризованные тесты. TDD. Мутационное тестирование Параметризованные тесты позволяют запускать один тест с разными входными данными. TDD (Test Driven Development) — разработка через тесты: тест → код → рефакторинг. Мутационные тесты проверяют качество тестов путём внесения ошибок в код. Пример параметризованного теста @ParameterizedTest @ValueSource(ints = {1, 2, 3}) void testPositive(int value) { assertTrue(value > 0); } 27 . Уровни OSI. HTTP Модель OSI состоит из 7 уровней. HTTP относится к прикладному уровню и используется для передачи данных в web - приложениях. Основные HTTP - методы: • GET • POST • PUT • DELETE Пример HTTP - запроса GET /api/users HTTP/1.1 Host: localhost:8080 Accept: application/json 28 . Структура HTTP - запроса и ответа HTTP - запрос состоит из: • стартовой строки; • заголовков; • тела (опционально). HTTP - ответ содержит: • статус - код; • заголовки; • тело ответа. Пример HTTP - ответа HTTP/1.1 200 OK Content - Type: application/json {\"id\":1,\"name\":\"Alex\"} 29. Java EE серверы. SOAP, RPC, gRPC Java EE серверы ( WildFly, GlassFish) предоставляют: • управление транзакциями; • безопасность; • web - сервисы. SOAP — XML - based web - сервисы. RPC / gRPC — удалённый вызов процедур, gRPC использует protobuf. Пример SOAP - сервиса @WebService public class PaymentService { public String pay() { return \"OK\"; } } 30 . Web - приложение. Обработка HTTP - запросов Web - приложение — серверное ПО, доступное через браузер по HTTP. Основная задача — обработка запросов и формирование ответов. В Java это реализуется через сервлеты или Spring MVC. Пример обработки запроса @WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.getWriter().write(\"Hello World\"); } } 31 . Создание сервлетов и обеспечение доступа к ним. Жизненный цикл сервлета Сервлет — это Java - класс, предназначенный для обработки HTTP - запросов и формирования HTTP - ответов в web приложении. Сервлеты работают на стороне сервера и являются основой Java - web - разработки. Доступ к сервлету обеспечивается: • через аннотацию @ WebServlet • либо через конфигурацию в web.xml Жизненный цикл сервлета управляется контейнером сервлетов ( Tomcat): 1. init() — инициализация сервлета (вызывается один раз) 2. service() → doGet() , doPost() — обработка запросов 3. destroy() — освобождение ресурсов Пример сервлета @WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.getWriter().write(\"Hello World\"); } } 32 . Основные элементы и классы сервлетов Основные классы и интерфейсы сервлетов: • HttpServlet — базовый класс • HttpServletRequest — объект запроса • HttpServletResponse — объект ответа • ServletConfig — конфигурация сервлета • ServletContext — контекст приложения Сервлет получает данные из запроса (параметры, заголовки, тело) и формирует ответ клиенту. Пример использования Request и Response public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String name = req.getParameter(\"name\"); resp.setContentType(\"text/plain\"); resp.getWriter().write(\"Hello \" + name); } 33 . Подходы к созданию web архитектуры. Request и Response Современные web - приложения строятся на основе клиентсерверной архитектуры . Клиент отправляет HTTP - запрос, сервер обрабатывает его и возвращает HTTP - ответ. Основные подходы: • монолитные web - приложения • MVC - архитектура • REST - архитектура Request содержит: • URL • HTTP - метод • параметры • заголовки Response содержит: • статус ответа • заголовки • тело ответа Пример обработки запроса String method = req.getMethod(); String uri = req.getRequestURI(); resp.setStatus(200); resp.getWriter().write(\"Method: \" + method); 34 . Дескриптор развёртывания. Cookies, cache, filters Дескриптор развёртывания ( web.xml ) — XML - файл, описывающий конфигурацию web - приложения: сервлеты, фильтры, маппинги, безопасность. Cookies используются для хранения данных на стороне клиента (сессии, настройки). Кэширование повышает производительность. Фильтры ( Filter) позволяют перехватывать запросы и ответы (логирование, авторизация). Пример фильтра @WebFilter(\"/*\") public class LogFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { System.out.println(\"Request received\"); chain.doFilter(req, res); } } 35 . Перенаправление запросов между сервлетами Перенаправление используется для передачи управления между сервлетами или страницами. Существует два основных механизма: • Redirect ( sendRedirect ) — клиент делает новый запрос • Forward ( RequestDispatcher.forward ) — перенаправление внутри сервера Redirect используется при смене URL, Forward — для внутренней логики. Пример redirect и forward // Redirect resp.sendRedirect(\"/login\"); // Forward RequestDispatcher rd = req.getRequestDispatcher(\"/home\"); rd.forward(req, resp); 36 . Паттерн проектирования MVC и его реализация в web приложении MVC (Model – View – Controller) — архитектурный паттерн, разделяющий приложение на три компонента: • Model — бизнес - логика и данные (например, JPA сущности) • View — представление пользователю ( JSP, Thymeleaf) • Controller — обработка запросов, маршрутизация, вызов сервисов Преимущества: • упрощение поддержки кода • повторное использование компонентов • разделение обязанностей Пример Spring MVC Controller @Controller @RequestMapping(\"/users\") public class UserController { @GetMapping public String list(Model model) { model.addAttribute(\"users\", userService.findAll()); return \"users/list\"; } } 37. Взаимодействие сервлетов с представлением. JSP, Bootstrap, Thymeleaf, JSTL JSP (Java Server Pages) — технология генерации HTML на сервере с возможностью вставки Java - кода. Thymeleaf — современный серверный шаблонизатор, интегрируется с Spring. JSTL — библиотека тегов для JSP, упрощает цикл, условие и работу с коллекциями. Bootstrap — CSS - фреймворк для красивого оформления страниц. Пример JSTL + Thymeleaf <c:forEach var=\"u\" items=\"${users}\"> <p>${u.name}</p> </c:forEach> 38 . Понятие REST и особенности построения приложения на его основе REST (Representational State Transfer) — архитектурный стиль для построения web - сервисов. Основные принципы: • ресурсы идентифицируются URI • операции ограничены HTTP - методами: GET, POST, PUT, DELETE • stateless ( без состояния) • использование стандартных форматов данных ( JSON, XML) RESTful API — сервис, строго соответствующий принципам REST. Плюсы: • простота интеграции с клиентами • совместимость с веб - приложениями • поддержка масштабирования Пример REST - контроллера в Spring @RestController @RequestMapping(\"/api/users\") public class UserRestController { @GetMapping(\"/{id}\") public User getUser(@PathVariable Long id) { return userService.findById(id); } } 39. Степень соответствия приложения правилам REST Для того чтобы приложение соответствовало REST: • URI должны идентифицировать ресурсы ( / users/1 ) • HTTP - методы должны отражать действие ( GET , POST , PUT , DELETE ) • Статусы HTTP должны быть корректными ( 200 OK , 404 Not Found ) • Использовать HATEOAS ( по желанию) для навигации между ресурсами Проверка соответствия REST помогает поддерживать совместимость и удобство API для клиентов. Пример REST - метода @PostMapping @ResponseStatus(HttpStatus.CREATED) public User createUser(@RequestBody User user) { return userService.save(user); } 40. Обзор принципов SOLID SOLID — пять принципов объектно - ориентированного проектирования: 1. S (Single Responsibility Principle) — один класс, одна ответственность 2. O (Open/Closed Principle) — открыто для расширения, закрыто для изменения 3. L (Liskov Substitution Principle) — объекты подклассов должны заменять объекты суперкласса 4. I (Interface Segregation Principle) — маленькие, специализированные интерфейсы 5. D (Dependency Inversion Principle) — зависимость от абстракций, а не от конкретных реализаций Следование SOLID делает код: • более модульным • тестируемым • сопровождаемым Пример применения DIP и SRP interface PaymentService { void pay(double sum); } class CreditCardPayment implements PaymentService { public void pay(double sum) { System.out.println(\"Pay \" + sum); } } class Order { private PaymentService paymentService; public Order(PaymentService ps) { this.paymentService = ps; } public void checkout() { paymentService.pay(100); } } 41 . Назначение и возможности интеграции фреймворка Spring Spring Framework — это мощный фреймворк для разработки Java - приложений, который обеспечивает: • управление зависимостями и конфигурацией приложений через IoC - контейнер ; • интеграцию с базами данных, веб - сервисами и безопасностью; • поддержку различных модулей: Spring Core, Spring MVC, Spring Data, Spring Security, Spring Boot. Контекст ( ApplicationContext) — центральный контейнер Spring, который управляет жизненным циклом бинов и их зависимостями. Пример создания контекста ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); MyService service = context.getBean(MyService.class); service.run(); 42 . Понятие и назначение бина (Bean) приложения Bean — объект, управляемый Spring IoC контейнером. Особенности бина: • создаётся контейнером, а не вручную; • может иметь зависимости, которые внедряются автоматически; • жизненный цикл управляется Spring ( инициализация, уничтожение). Пример бина @Component public class UserService { public void greet() { System.out.println(\"Hello!\"); } } 43. Spring Core и базовые механизмы Spring Core предоставляет: • IoC (Inversion of Control) — контейнер управляет зависимостями; • DI (Dependency Injection) — внедрение зависимостей через конструктор, сеттер или поле; • конфигурацию через XML, аннотации или Java Config. Пример внедрения зависимостей @Service public class OrderService { @Autowired private PaymentService paymentService; public void checkout() { paymentService.pay(100); } } 44. Inversion of Control (IoC) и Dependency Injection (DI) IoC — принцип, при котором контейнер управляет созданием и жизненным циклом объектов. DI — способ реализации IoC, внедряющий зависимости через: • конструктор • сеттер • поле DI позволяет: • уменьшить связность компонентов; • упростить тестирование; • гибко конфигурировать приложение. Пример DI через конструктор @Service public class OrderService { private final PaymentService paymentService; public OrderService(PaymentService paymentService) { this.paymentService = paymentService; } } 45. IoC контейнер и жизненный цикл бина Жизненный цикл бина в Spring: 1. Создание экземпляра 2. Внедрение зависимостей 3. Инициализация (методы @ PostConstruct) 4. Работа бина 5. Уничтожение (методы @ PreDestroy) Контейнер управляет всеми этапами, обеспечивая консистентность и контроль зависимостей. Пример методов жизненного цикла @Component public class MyBean { @PostConstruct public void init() { System.out.println(\"Init\"); } @PreDestroy public void destroy() { System.out.println(\"Destroy\"); } } 46. Конфигурация бина через XML Ранее Spring широко использовал XML для определения бинов: <beans xmlns=\"http://www.springframework.org/schema/beans\"> <bean id=\"userService\" class=\"com.example.UserService\"/> </beans> Преимущества: • централизованная конфигурация • возможность менять реализацию без перекомпиляции 47. Spring Boot и его возможности Spring Boot — надстройка над Spring, упрощающая конфигурацию: • автоконфигурация • встроенный сервер ( Tomcat) • упрощённая работа с зависимостями • быстрое создание REST и web - приложений Пример основного класса Spring Boot @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 48. Реализация приложений на Spring Boot и Spring MVC Spring MVC интегрирован в Spring Boot. Контроллеры управляют запросами и возвращают представление. Пример контроллера @Controller @RequestMapping(\"/users\") public class UserController { @GetMapping public String list(Model model) { model.addAttribute(\"users\", userService.findAll()); return \"users/list\"; } } 49 . Интеграция Spring Data, CRUDRepository и JPARepository Spring Data упрощает работу с базой данных, предоставляя интерфейсы CrudRepository и JpaRepository : • CRUD операции без написания SQL • Поддержка пагинации и сортировки • Расширение через кастомные методы Пример репозитория public interface UserRepository extends JpaRepository<User, Long> { List<User> findByName(String name); } 50 . Возможности применения Spring Security при разграничении прав доступа пользователей системы Spring Security предоставляет комплексные возможности для управления правами доступа: - Аутентификация и авторизация на основе ролей ( ROLE _ ADMIN , ROLE _ USER ) - Защита URL - путей с помощью аннотаций @ PreAuthorize , @ PostAuthorize - Метод - левел безопасность для контроля доступа к методам сервисов - Интеграция с JWT для stateless - аутентификации в REST API Кастомизация правил доступа через SecurityConfig с использованием HttpSecurity - Поддержка OAuth 2 для внешней аутентификации ( Google , GitHub и др.) - Возможность создания сложных правил доступа на основе SpEL выражений Пример конфигурации доступа: @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authz - > authz .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\") .requestMatchers(\"/user/**\").hasAnyRole(\"USER\", \"ADMIN\") .anyRequest().authenticated() ) .formLogin(Customizer.withDefaults()); return http.build(); } }",
      "wordCount": 4200,
      "uploadDate": "2026-01-26T23:24:05.516Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        23179,
        321551,
        447012,
        63569,
        30795,
        53090,
        206744,
        134434,
        72007,
        99217,
        135514,
        148878,
        80905,
        50633,
        982022,
        494538,
        14847,
        80489,
        17907,
        99793,
        43274,
        224245,
        185551,
        41365,
        179789,
        18327,
        27226,
        141314,
        474145,
        316326,
        123530,
        82281,
        114802,
        141487,
        105690,
        215639,
        128606,
        92559,
        43922,
        44225,
        67600,
        9763,
        558694,
        62048,
        64093,
        488237,
        298217,
        272110,
        52576,
        12464,
        135826,
        29394,
        355005,
        36331,
        117786,
        59453,
        303098,
        37758,
        144323,
        364584,
        46078,
        53725,
        122991,
        46854,
        261438,
        126907,
        2274,
        53173,
        134646,
        43911,
        145455,
        173350,
        13049,
        4509,
        17347,
        60981,
        39245,
        285708,
        258760,
        104581,
        317186,
        53068,
        46543,
        26384,
        102984,
        10874,
        199562,
        104673,
        56438,
        178440,
        423243,
        157689,
        569104,
        67318,
        98880,
        119660,
        428702,
        170258,
        27602,
        221872,
        163919,
        805,
        404804,
        319403,
        338776,
        7003,
        121473,
        231004,
        69237,
        108284,
        237295,
        119348,
        392937,
        36293,
        50060,
        129544,
        121940,
        499971,
        26134,
        101195,
        321005,
        117086,
        298707,
        568017,
        62627,
        197382,
        53574,
        37535
      ],
      "shingleCount": 12784
    },
    {
      "id": 29,
      "title": "EF4e Pre-int End of course test A answer sheet",
      "author": "Furs Art Val",
      "filename": "EF4e Pre-int End of course test A answer sheet.pdf",
      "filePath": "data/uploads/1769469970659_EF4e_Pre-int_End_of_course_test_A_answer_sheet.pdf",
      "content": "1 NAME C L ASS End-of-course Test Answer Sheet A English File fourth edition Pre-intermediate Photocopiable © Oxford University Press 2019 VOCABULARY Exercise 5 1 curly __________ 2 buy __________ 3 asleep __________ 4 divorced __________ 5 download __________ Exercise 6 1 ____________________ 2 ____________________ 3 ____________________ 4 ____________________ 5 ____________________ 6 ____________________ 7 ____________________ Exercise 7 1 ____________________ 4 ____________________ 2 ____________________ 5 ____________________ 3 ____________________ 6 ____________________ Exercise 8 1 ____________________ 5 ____________________ 2 ____________________ 6 ____________________ 3 ____________________ 7 ____________________ 4 ____________________ Exercise 9 1 load / dust / do 6 tell / speak / say 2 get / meet / wait 7 catch / throw / go 3 play / get / have 8 work / play / do 4 listen / look / see 9 meet / look for / know 5 shop / be / make 10 fall / open / have Exercise 10 1 ____________________ 2 ____________________ 3 ____________________ 4 ____________________ 5 ____________________ 40 GRAMMAR Exercise 1 1 _____________________________________________ 2 _____________________________________________ 3 _____________________________________________ 4 _____________________________________________ 5 _____________________________________________ 6 _____________________________________________ Exercise 2 1 ____________________ 2 ____________________ 3 ____________________ 4 ____________________ 5 ____________________ 6 _________ __________ 7 ____________________ 8 ____________________ 9 ____________________ 10 ____________________ 11 ____________________ 12 ____________________ Exercise 3 1 ____________________ 6 ____________________ 2 ____________________ 7 ____________________ 3 ____________________ 8 ____________________ 4 ____________________ 9 ____________________ 5 ____________________ 10 ____________________ Exercise 4 1 worst / worse 7 Swimming / Swim 2 yet / just 8 don’t have to / should 3 too many / too much 9 might / must 4 mustn’t / don’t have to 10 won’t / wouldn’t 5 enough / too 11 somebody / anyone 6 anything / nothing 12 later / next 40 2 NAME C L ASS End-of-course Test Answer Sheet A English File fourth edition Pre-intermediate Photocopiable © Oxford University Press 2019 LISTENING Exercise 1 1 A ■ B ■ 4 A ■ B ■ 2 A ■ B ■ 5 A ■ B ■ 3 A ■ B ■ Exercise 2 1 _____ 2 _____ 3 _____ 4 _____ 5 _____ 10 Listening and Speaking total 25 PRONUNCIATION Exercise 11 1 fl ew _ lose____ ________ 2 l u nch _ done___ ________ 3 ch eap ________ ________ 4 p u t ________ ________ 5 c ustomer ________ ________ 6 g o ________ ________ Exercise 12 1 a|ssis|tant 2 dish|wa|sher 3 con|fu|sion 4 mou|stache 5 to|wards 6 e|ner|ge|tic 7 in|fe|rior 8 je|lly|fish 9 be|long 10 ath|le|tics 20 GVP total 100 READING Exercise 1 1 A ■ B ■ C ■ 6 A ■ B ■ C ■ 2 A ■ B ■ C ■ 7 A ■ B ■ C ■ 3 A ■ B ■ C ■ 8 A ■ B ■ C ■ 4 A ■ B ■ C ■ 9 A ■ B ■ C ■ 5 A ■ B ■ C ■ 10 A ■ B ■ C ■ Exercise 2 1 _____________________________________________ 2 _____________________________________________ 3 _____________________________________________ 4 _____________________________________________ 5 _____________________________________________ 15 Reading and Writing total 25",
      "wordCount": 503,
      "uploadDate": "2026-01-26T23:26:10.674Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        1184322,
        2793886,
        439423,
        1692408,
        688326,
        2509156,
        3587211,
        2343249,
        1062970,
        1653696,
        3539479,
        1427790,
        2368967,
        6871745,
        11622637,
        1271992,
        284240,
        2495796,
        410334,
        212548,
        108463,
        1269849,
        2176474,
        359846,
        2296974,
        414428,
        5185161,
        1080748,
        4116064,
        6566142,
        2048857,
        172244,
        1235288,
        5254607,
        63202,
        2310041,
        442397,
        178566,
        5483635,
        1751857,
        49285,
        361112,
        1987823,
        62048,
        2910809,
        813338,
        2636384,
        2701688,
        3204346,
        1544684,
        4056455,
        829922,
        3843239,
        853273,
        1290622,
        101583,
        3475114,
        1645209,
        2320811,
        539826,
        1460027,
        2410174,
        128764,
        5464544,
        710791,
        3921788,
        3938288,
        993772,
        578521,
        3908109,
        57687,
        718443,
        4107016,
        5431575,
        6336866,
        3219686,
        348975,
        407603,
        787278,
        3564337,
        312945,
        427796,
        69441,
        1844562,
        6374060,
        1448307,
        199562,
        2495834,
        4383091,
        2513784,
        6163054,
        2698944,
        351548,
        2966241,
        6482179,
        2505214,
        1635610,
        2330513,
        357767,
        242729,
        112254,
        240636,
        882090,
        6060912,
        2138624,
        2363099,
        1300285,
        1636097,
        2660720,
        2044661,
        4029075,
        418631,
        7740518,
        2474631,
        2939403,
        1540868,
        121940,
        931100,
        2544741,
        3346350,
        519869,
        843516,
        1861733,
        346745,
        115781,
        321786,
        565048,
        542934
      ],
      "shingleCount": 1033
    },
    {
      "id": 31,
      "title": "EF4e Pre-int End of course test A answer sheet",
      "author": "Furs Art Val",
      "filename": "EF4e Pre-int End of course test A answer sheet.pdf",
      "filePath": "data/uploads/1769470322405_EF4e_Pre-int_End_of_course_test_A_answer_sheet.pdf",
      "content": "1 NAME C L ASS End-of-course Test Answer Sheet A English File fourth edition Pre-intermediate Photocopiable © Oxford University Press 2019 VOCABULARY Exercise 5 1 curly __________ 2 buy __________ 3 asleep __________ 4 divorced __________ 5 download __________ Exercise 6 1 ____________________ 2 ____________________ 3 ____________________ 4 ____________________ 5 ____________________ 6 ____________________ 7 ____________________ Exercise 7 1 ____________________ 4 ____________________ 2 ____________________ 5 ____________________ 3 ____________________ 6 ____________________ Exercise 8 1 ____________________ 5 ____________________ 2 ____________________ 6 ____________________ 3 ____________________ 7 ____________________ 4 ____________________ Exercise 9 1 load / dust / do 6 tell / speak / say 2 get / meet / wait 7 catch / throw / go 3 play / get / have 8 work / play / do 4 listen / look / see 9 meet / look for / know 5 shop / be / make 10 fall / open / have Exercise 10 1 ____________________ 2 ____________________ 3 ____________________ 4 ____________________ 5 ____________________ 40 GRAMMAR Exercise 1 1 _____________________________________________ 2 _____________________________________________ 3 _____________________________________________ 4 _____________________________________________ 5 _____________________________________________ 6 _____________________________________________ Exercise 2 1 ____________________ 2 ____________________ 3 ____________________ 4 ____________________ 5 ____________________ 6 _________ __________ 7 ____________________ 8 ____________________ 9 ____________________ 10 ____________________ 11 ____________________ 12 ____________________ Exercise 3 1 ____________________ 6 ____________________ 2 ____________________ 7 ____________________ 3 ____________________ 8 ____________________ 4 ____________________ 9 ____________________ 5 ____________________ 10 ____________________ Exercise 4 1 worst / worse 7 Swimming / Swim 2 yet / just 8 don’t have to / should 3 too many / too much 9 might / must 4 mustn’t / don’t have to 10 won’t / wouldn’t 5 enough / too 11 somebody / anyone 6 anything / nothing 12 later / next 40 2 NAME C L ASS End-of-course Test Answer Sheet A English File fourth edition Pre-intermediate Photocopiable © Oxford University Press 2019 LISTENING Exercise 1 1 A ■ B ■ 4 A ■ B ■ 2 A ■ B ■ 5 A ■ B ■ 3 A ■ B ■ Exercise 2 1 _____ 2 _____ 3 _____ 4 _____ 5 _____ 10 Listening and Speaking total 25 PRONUNCIATION Exercise 11 1 fl ew _ lose____ ________ 2 l u nch _ done___ ________ 3 ch eap ________ ________ 4 p u t ________ ________ 5 c ustomer ________ ________ 6 g o ________ ________ Exercise 12 1 a|ssis|tant 2 dish|wa|sher 3 con|fu|sion 4 mou|stache 5 to|wards 6 e|ner|ge|tic 7 in|fe|rior 8 je|lly|fish 9 be|long 10 ath|le|tics 20 GVP total 100 READING Exercise 1 1 A ■ B ■ C ■ 6 A ■ B ■ C ■ 2 A ■ B ■ C ■ 7 A ■ B ■ C ■ 3 A ■ B ■ C ■ 8 A ■ B ■ C ■ 4 A ■ B ■ C ■ 9 A ■ B ■ C ■ 5 A ■ B ■ C ■ 10 A ■ B ■ C ■ Exercise 2 1 _____________________________________________ 2 _____________________________________________ 3 _____________________________________________ 4 _____________________________________________ 5 _____________________________________________ 15 Reading and Writing total 25",
      "wordCount": 503,
      "uploadDate": "2026-01-26T23:32:02.446Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        1184322,
        2793886,
        439423,
        1692408,
        688326,
        2509156,
        3587211,
        2343249,
        1062970,
        1653696,
        3539479,
        1427790,
        2368967,
        6871745,
        11622637,
        1271992,
        284240,
        2495796,
        410334,
        212548,
        108463,
        1269849,
        2176474,
        359846,
        2296974,
        414428,
        5185161,
        1080748,
        4116064,
        6566142,
        2048857,
        172244,
        1235288,
        5254607,
        63202,
        2310041,
        442397,
        178566,
        5483635,
        1751857,
        49285,
        361112,
        1987823,
        62048,
        2910809,
        813338,
        2636384,
        2701688,
        3204346,
        1544684,
        4056455,
        829922,
        3843239,
        853273,
        1290622,
        101583,
        3475114,
        1645209,
        2320811,
        539826,
        1460027,
        2410174,
        128764,
        5464544,
        710791,
        3921788,
        3938288,
        993772,
        578521,
        3908109,
        57687,
        718443,
        4107016,
        5431575,
        6336866,
        3219686,
        348975,
        407603,
        787278,
        3564337,
        312945,
        427796,
        69441,
        1844562,
        6374060,
        1448307,
        199562,
        2495834,
        4383091,
        2513784,
        6163054,
        2698944,
        351548,
        2966241,
        6482179,
        2505214,
        1635610,
        2330513,
        357767,
        242729,
        112254,
        240636,
        882090,
        6060912,
        2138624,
        2363099,
        1300285,
        1636097,
        2660720,
        2044661,
        4029075,
        418631,
        7740518,
        2474631,
        2939403,
        1540868,
        121940,
        931100,
        2544741,
        3346350,
        519869,
        843516,
        1861733,
        346745,
        115781,
        321786,
        565048,
        542934
      ],
      "shingleCount": 1033
    },
    {
      "id": 34,
      "title": "Лабораторная работа 1",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "Лабораторная работа 1.docx",
      "filePath": "data/uploads/1769471216020_Лабораторная_работа_1.docx",
      "content": "Задания к лабораторной работе 1 Задание 1 Задайте вектора x и y следующим образом: rand <- rnorm(20) NAs <- rep(NA, 20) x <- sample(c(rand, NAs), 20) y <- x[!is.na(x)] Сравните результаты x[x > 0] , y[y > 0] . Объясните почему они не совпадают. Получите вектор эквивалентный y[y > 0] , но без использования дополнительной переменной y (т.е. Вам дан x и Вы хотите извлечь из него все положительные числа не создавая новых переменных). Задание 2 Предскажите тип полученного вектора в результате следующих операций: c(1, FALSE) c(\"a\", 1) c(TRUE, 1L) Задание 3 Функция diag() имеет больше вариантов использования, чем было указано в теории. Найдите и прочитайте по ней справку. После чего используйте её для создания матрицы 15 на -15 с нулевыми недиагональными элементами и со следующей диагональю: 7, …,1,0,1,…,7. Задание 4 n-ое треугольное число задается формулой: . Создайте последовательность 20 треугольных чисел. В R есть встроенный вектор letters, содержащий буквы английского алфавита. Назовите элементы созданного вами вектора первыми 20-ю буквами алфавита. Выберете только треугольные числа, названные гласными буквами. . Контрольные вопросы 1. Что такое язык R и для каких задач он используется? 2. Какие основные типы данных существуют в языке R? 3. Что такое вектор в R и какие виды векторов бывают? 4. Чем отличается список (list) от вектора? 5. Что такое data frame и для чего он используется? 6. Как в R осуществляется индексация элементов объектов? 7. Что такое пропущенные значения NA и почему они важны? 8. В чём заключается принцип векторизации в R? 9. Для чего используются пакеты и библиотеки в R? 10. Что такое рабочая среда RStudio и какие задачи она упрощает?",
      "wordCount": 265,
      "uploadDate": "2026-01-26T23:46:56.036Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        822455,
        1424149,
        2068140,
        3516651,
        10663390,
        2732580,
        1015254,
        2057124,
        1996230,
        53874,
        235163,
        166580,
        3210264,
        540587,
        811686,
        4051406,
        2928489,
        1559315,
        1196462,
        368069,
        5174458,
        1517389,
        91694,
        8253661,
        5344159,
        4580718,
        348000,
        4046916,
        631393,
        4756584,
        1563321,
        2618140,
        1385294,
        393622,
        865153,
        4110547,
        1813197,
        2737835,
        1117907,
        5100681,
        1160305,
        3847589,
        5874635,
        95321,
        825145,
        5206501,
        2257496,
        762652,
        1676586,
        2367234,
        1715453,
        24334,
        717837,
        1310247,
        1707060,
        346820,
        319540,
        2370977,
        752376,
        578363,
        2848123,
        2419816,
        357555,
        702333,
        274877,
        26362,
        1673136,
        5297790,
        395779,
        112364,
        1691045,
        1205416,
        1607672,
        5304178,
        1111825,
        104103,
        771410,
        1167137,
        5852391,
        1007039,
        317186,
        1369904,
        106677,
        389716,
        1902940,
        861043,
        731058,
        289423,
        860044,
        1337533,
        994264,
        843956,
        1876301,
        3887245,
        141961,
        119660,
        426772,
        306390,
        4568700,
        621036,
        865694,
        1635642,
        1835704,
        945648,
        2391163,
        2083573,
        68407,
        47919,
        56862,
        1327442,
        300649,
        2969024,
        586384,
        178704,
        1875059,
        4876117,
        344161,
        4148363,
        1554118,
        1409062,
        795170,
        117086,
        788758,
        6329051,
        2812450,
        349054,
        611006,
        28902
      ],
      "shingleCount": 1282
    },
    {
      "id": 45,
      "title": "5 Junit",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "5 Junit.docx",
      "filePath": "data/uploads/1769641204044_5_Junit.docx",
      "content": "Лабораторная работа №5 Тестирование приложений с применением JUnit 5 Тестирование программного обеспечения — проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённым образом [1]. Программисты, которые занимаются тестированием готового ПО, называют Quality Assurance инженерами. Тестирование кода может производиться вручную либо с помощью инструментов автоматизации тестирования. JUnit - это фреймворк для написания модульных тестов. С помощью этого фреймворка мы можем писать методы, которые будут проверять работу кусков нашей программы на соответствие ожидаемого результата. Тестирование CRUD-операций JDBC Создадим БД и добавим в нее таблицy employee: CREATE DATABASE testdb; USE testdb; CREATE TABLE employee ( employee_id INT PRIMARY KEY AUTO_INCREMENT, empl_name VARCHAR(30) NOT NULL CHECK (CHAR_LENGTH(empl_name) != 0), empl_dob DATE NOT NULL CHECK (empl_dob < '2006-01-01'), empl_salary DECIMAL(10, 2) CHECK (empl_salary > 0) ); Эту базу данных мы будем использовать на протяжении всего выполнения лабораторной. Создадим Maven-проект со следующей структурой: Подключим следующие зависимости в pom.xml: <dependencies> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-params</artifactId> <version>5.11.3</version> <scope>test</scope> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>9.0.0</version> </dependency> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-api</artifactId> <version>5.11.3</version> <scope>test</scope> </dependency> </dependencies> Теперь напишем код, который мы будем тестировать. Класс Employee package com.jdbc.junit; import java.math.BigDecimal; import java.sql.Date; public class Employee { private int employeeId; private String emplName; private Date emplDob; private BigDecimal emplSalary; public Employee() { } public Employee(String emplName, Date emplDob, BigDecimal emplSalary) { this.emplName = emplName; this.emplDob = emplDob; this.emplSalary = emplSalary; } public Employee(int employeeId, String emplName, Date emplDob, BigDecimal emplSalary) { this.employeeId = employeeId; this.emplName = emplName; this.emplDob = emplDob; this.emplSalary = emplSalary; } public int getEmployeeId() { return employeeId; } public void setEmployeeId(int employeeId) { this.employeeId = employeeId; } public String getEmplName() { return emplName; } public void setEmplName(String emplName) { this.emplName = emplName; } public Date getEmplDob() { return emplDob; } public void setEmplDob(Date emplDob) { this.emplDob = emplDob; } public BigDecimal getEmplSalary() { return emplSalary; } public void setEmplSalary(BigDecimal emplSalary) { this.emplSalary = emplSalary; } @Override public String toString() { return \"Employee{\" + \"employeeId=\" + employeeId + \", emplName='\" + emplName + '\\'' + \", emplDob=\" + emplDob + \", emplSalary=\" + emplSalary + '}'; } } Класс CRUD package com.jdbc.junit; import java.sql.Date; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class CRUD { public void createEmployee(String empl_name, Date empl_dob, Integer empl_salary) throws SQLException { String query = \"INSERT INTO employee (empl_name, empl_dob, empl_salary) VALUES (?,?,?);\"; PreparedStatement statement = ConfigClass.getConnection().prepareStatement(query); statement.setString(1, empl_name); statement.setDate(2, empl_dob); statement.setInt(3, empl_salary); statement.executeUpdate(); } public void createEmployee(Employee empl) throws SQLException { String query = \"INSERT INTO employee (empl_name, empl_dob, empl_salary) VALUES (?,?,?);\"; PreparedStatement statement = ConfigClass.getConnection().prepareStatement(query); statement.setString(1, empl.getEmplName()); statement.setDate(2, empl.getEmplDob()); statement.setBigDecimal(3, empl.getEmplSalary()); statement.executeUpdate(); } public void deleteEmployee(Integer id) throws SQLException { String query = \"DELETE FROM employee WHERE employee_id=?;\"; PreparedStatement pstmt = ConfigClass.getConnection().prepareStatement(query); pstmt.setInt(1, id); pstmt.executeUpdate(); } public ResultSet readTable() throws SQLException { Statement stmt = ConfigClass.getConnection().createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM employee\"); return rs; } public void updateEmployee(Integer id, String empl_name, Date empl_dob, Integer empl_salary) throws SQLException { String query = \"UPDATE employee SET empl_name=?, empl_dob=?, empl_salary=? WHERE employee_id=?;\"; PreparedStatement statement = ConfigClass.getConnection().prepareStatement(query); statement.setString(1, empl_name); statement.setDate(2, empl_dob); statement.setInt(3, empl_salary); statement.setInt(4, id); statement.executeUpdate(); } } Класс ConfigClass package com.jdbc.junit; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; public class ConfigClass { private static Connection connection; private Statement statement; private static String driver = \"com.mysql.cj.jdbc.Driver\"; private static String username = \"ВАШ_USERNAME\"; private static String password = \"ВАШ_ПАРОЛЬ\"; private static String url = \"jdbc:mysql://localhost:3306/testdb\"; public ConfigClass() throws ClassNotFoundException, SQLException { Class.forName(driver); connection = DriverManager.getConnection(url, username, password); statement = connection.createStatement(); } public static Connection getConnection() { return connection; } public void closeConnection() throws SQLException { connection.close(); } } Не забудьте в этом классе поменять username и password в соответствии со своими данными. Приступим к тестированию! Тест-класс JDBCTest package com.jdbc.junit; import static org.junit.jupiter.api.Assertions.assertNotEquals; import static org.junit.jupiter.api.Assertions.assertNotNull; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.fail; import java.math.BigDecimal; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.stream.Stream; import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource; public class JDBCTest { static ConfigClass config; static CRUD database; static Stream<Employee> OKempl() { return Stream.of(new Employee(\"Vasya\", new Date(945153510963l), new BigDecimal(\"1000\")), new Employee(\"Maksim\", new Date(988349168640l), new BigDecimal(\"1500\")), new Employee(\"Vova\", new Date(1022131568640l), new BigDecimal(\"1000\"))); } static Stream<Employee> BADempl() { return Stream.of(new Employee(\"Vasya\", new Date(1734158310963l), new BigDecimal(\"1000\")), // wrong date new Employee(\"\", new Date(988349168640l), new BigDecimal(\"1500\")), // wrong name new Employee(\"Vova\", new Date(1022131568640l), new BigDecimal(\"-3\"))); // salary below 0 } @BeforeAll static void createConfigInstance() throws ClassNotFoundException, SQLException { config = new ConfigClass(); database = new CRUD(); } @AfterAll static void closeContext() { try { config.closeConnection(); } catch (SQLException e) { e.printStackTrace(); } } @ParameterizedTest @MethodSource(\"OKempl\") void testCreateSuccesful(Employee employee) { try { database.createEmployee(employee); } catch (SQLException e) { e.printStackTrace(); fail(\"SQLException\"); } } @ParameterizedTest @MethodSource(\"BADempl\") void testCreateSQLexception(Employee employee) { assertThrows(SQLException.class, () -> database.createEmployee(employee)); } @Test void testDelete() { try { database.deleteEmployee(1); } catch (SQLException e) { fail(\"Employee is not found\"); } } @Test void testRead() { try { ResultSet rs = database.readTable(); assertNotNull(rs); assertNotEquals(rs.getMetaData().getColumnCount(), 0); } catch (SQLException e) { fail(\"SQLException\"); } } } Итак, давайте на примере этих тестов рассмотрим основные аннотации и методы, используемые во время тестирования. Аннотацией @Test мы помечаем методы, описывающие тестовые сценарии. Внутри тестовых методов мы описываем, какое поведение программы мы ожидаем. Например, взглянем на два метода - testCreateSuccesfull и testCreateSQLException. В первом, как гласит название, мы ожидаем, что работник успешно добавится в БД. Во втором мы ожидаем, что БД не даст создать такого работника. А как мы проверяем на соответствие ожидаемому результату? С помощью предположений или же Assert’ов. assertThrows(SQLException.class, () -> database.createEmployee(employee)); Например, здесь мы предполагаем, что должно выброситься исключение. Тест пройдет, если исключение выбросится, тогда тест проходит успешно. Все доступные методы assert’а можно найти тут: https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html Вы могли заметить, что кое-где вместо аннотации @Test мы используем @ParameterizedTests. Эта аннотация позволяет проводить один и тот же тест несколько раз с разными параметрами. Параметры могут поставляться различными аннотациями извне: @FieldSource, @ValueSource и т.д. (Подробнее об этом можно почитать тут: https://www.baeldung.com/parameterized-tests-junit-5) В данном примере мы используем @MethodSource - эта аннотация поставляет в метод поток из возвращаемого функцией значения. Последнее, что нас интересует, это аннотации BeforeEach, BeforeAll, AfterEach и AfterAll. Они представлены в Junit 5 (поэтому вы можете встретить еще аннотации After, BeforeClass, эти аннотации представлены в Junit 4). Эти классы нужны, если перед запуском тестов нам необходимо описать какую-то логику выполнения: инициализация, закрытие ресурсов и т.д. Методы, помеченные этими аннотациями, НЕ являются тестами. @BeforeEach - указывает на то, что метод будет выполнятся перед каждым тестируемым методом @AfterEach - указывает на то что метод будет выполнятся после каждого тестируемого метода @BeforeAll - выполняется только один раз перед запуском тестов @AfterAll - выполняется один раз после всех тестов Запускаем! Тестирование маршалинга на основе файлов формата XML Создадим следующую структуру проекта: Загрузите в директорию resources/files файлы из диска. Если вдруг по какой-то причине их не оказалось на диске, в самом конце методички есть текст из файлов. Для текущих тестов будем использовать Hibernate. Настроим подключение к БД (hibernate.cfg.xml): <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE hibernate-configuration SYSTEM \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"hibernate.connection.driver_class\"> org.hibernate.dialect.MySQLDialect</property> <property name=\"hibernate.connection.url\"> jdbc:mysql://localhost:3306/testdb </property> <property name=\"hibernate.connection.username\"> ВАШ_USERNAME </property> <property name=\"hibernate.connection.password\"> ВАШ_ПАРОЛЬ </property> <property name=\"hibernate.current_session_context_class\">thread</property> <property name=\"show_sql\">true</property> </session-factory> </hibernate-configuration> Не забудьте поменять username и password в соответствии со своими данными. Загрузим в проект зависимости: <dependencies> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-params</artifactId> <version>5.11.3</version> <scope>test</scope> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>9.0.0</version> </dependency> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-api</artifactId> <version>5.11.3</version> <scope>test</scope> </dependency> <dependency> <groupId>org.hibernate.orm</groupId> <artifactId>hibernate-core</artifactId> <version>6.6.1.Final</version> </dependency> <dependency> <groupId>com.google.code.gson</groupId> <artifactId>gson</artifactId> <version>2.11.0</version> </dependency> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>4.0.2</version> </dependency> <dependency> <groupId>jakarta.xml.bind</groupId> <artifactId>jakarta.xml.bind-api</artifactId> <version>4.0.2</version> </dependency> <dependency> <groupId>jakarta.activation</groupId> <artifactId>jakarta.activation-api</artifactId> <version>2.1.3</version> </dependency> </dependencies> Класс HibernateConfig package xml.junit.marshalling; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; import xml.junit.marshalling.model.Employee; public class HibernateConfig { private static HibernateConfig sc; final SessionFactory sessionFactory; private HibernateConfig() { sessionFactory = new Configuration().addAnnotatedClass(Employee.class).configure().buildSessionFactory(); } public SessionFactory getSessionFactory() { return sessionFactory; } public static HibernateConfig getInstanceOfSeccionFactory() { if (sc == null) sc = new HibernateConfig(); return sc; } } Класс EmployeeDAO package xml.junit.marshalling.dao; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.Reader; import java.io.StringReader; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; import org.hibernate.Session; import org.hibernate.Transaction; import org.hibernate.exception.ConstraintViolationException; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import jakarta.xml.bind.JAXBContext; import jakarta.xml.bind.JAXBException; import jakarta.xml.bind.Unmarshaller; import xml.junit.marshalling.HibernateConfig; import xml.junit.marshalling.model.Employee; public class EmployeeDAO { private static HibernateConfig config = null; public EmployeeDAO() { config = HibernateConfig.getInstanceOfSeccionFactory(); } public Employee getEmployeeFromXML(String filename) throws IOException, JAXBException { StringBuilder strbldr = new StringBuilder(); ArrayList<String> lines = (ArrayList<String>) Files.readAllLines(Paths.get(filename), StandardCharsets.UTF_8); for (String line : lines) { strbldr.append(line); } JAXBContext jaxbContext = JAXBContext.newInstance(Employee.class); Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller(); return (Employee) jaxbUnmarshaller.unmarshal(new StringReader(strbldr.toString())); } public Employee saveEmployee(Employee entity) { Session session = config.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Employee emp; try { session.persist(entity); emp = session.find(Employee.class, entity.getEmployeeId()); } catch (ConstraintViolationException e) { throw e; } finally { transaction.commit(); session.close(); } return emp; } public Employee findEmployeeByID(Integer id) { Session session = config.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Employee employee = session.get(Employee.class, id); transaction.commit(); session.close(); return employee; } public Employee updateEmployee(Employee newEmpl, Integer id) { Session session = config.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Employee oldEmp; try { oldEmp = session.get(Employee.class, id); oldEmp.setEmplName(newEmpl.getEmplName()); oldEmp.setEmplDob(newEmpl.getEmplDob()); oldEmp.setEmplSalary(newEmpl.getEmplSalary()); } catch (ConstraintViolationException e) { throw e; } finally { transaction.commit(); session.close(); } return oldEmp; } public List<Employee> getEmployees() { Session session = config.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); List<Employee> empl = session.createQuery(\"FROM Employee\", Employee.class).list(); transaction.commit(); session.close(); return empl; } public void removeEmployee(Integer id) { Session session = config.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Employee empl; try { empl = session.get(Employee.class, id); session.remove(empl); } catch (ConstraintViolationException e) { throw e; } finally { transaction.commit(); session.close(); } } public Employee getEmployeeFromJson(String filename) throws IOException { Gson gson = new GsonBuilder().setPrettyPrinting().setDateFormat(\"yyyy-MM-dd\").create(); Reader reader = null; Employee employee; try { reader = new FileReader(filename); employee = gson.fromJson(reader, Employee.class); } catch (FileNotFoundException ex) { throw ex; } finally { reader.close(); } return employee; } public void dumpEmployeeToJson(String filename, Employee employee) throws Exception { Gson gson = new GsonBuilder().setPrettyPrinting().setDateFormat(\"yyyy-MM-dd\").create(); FileWriter writer = null; try { writer = new FileWriter(filename); gson.toJson(employee, writer); } catch (Exception ex) { throw ex; } finally { writer.close(); } } } Класс DateTimeAdapter public class DateTimeAdapter extends XmlAdapter<String, Date> { @Override public Date unmarshal(String v) throws Exception { return Date.valueOf(v); } @Override public String marshal(Date v) throws Exception { return new SimpleDateFormat(\"yyyy-MM-dd\").format(v); } } Класс Employee package xml.junit.marshalling.model; import java.math.BigDecimal; import java.sql.Date; import java.util.Objects; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; import jakarta.persistence.Temporal; import jakarta.persistence.TemporalType; import jakarta.xml.bind.annotation.XmlAccessType; import jakarta.xml.bind.annotation.XmlAccessorType; import jakarta.xml.bind.annotation.XmlRootElement; import jakarta.xml.bind.annotation.XmlTransient; import jakarta.xml.bind.annotation.XmlType; import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter; import xml.junit.marshalling.config.DateTimeAdapter; @Entity @Table(name = \"employee\") @XmlType(name = \"employee\") @XmlAccessorType(XmlAccessType.FIELD) @XmlRootElement public class Employee { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"employee_id\") @XmlTransient private int employeeId; @Column(name = \"empl_name\", nullable = false, length = 30) private String emplName; @Column(name = \"empl_dob\", nullable = false) @Temporal(TemporalType.DATE) @XmlJavaTypeAdapter(DateTimeAdapter.class) private Date emplDob; @Column(name = \"empl_salary\", precision = 10, scale = 2) private BigDecimal emplSalary; public Employee() { } public Employee(String emplName, Date emplDob, BigDecimal emplSalary) { this.emplName = emplName; this.emplDob = emplDob; this.emplSalary = emplSalary; } public Employee(int employeeId, String emplName, Date emplDob, BigDecimal emplSalary) { this.employeeId = employeeId; this.emplName = emplName; this.emplDob = emplDob; this.emplSalary = emplSalary; } public int getEmployeeId() { return employeeId; } public void setEmployeeId(int employeeId) { this.employeeId = employeeId; } public String getEmplName() { return emplName; } public void setEmplName(String emplName) { this.emplName = emplName; } public Date getEmplDob() { return emplDob; } public void setEmplDob(Date emplDob) { this.emplDob = emplDob; } public BigDecimal getEmplSalary() { return emplSalary; } public void setEmplSalary(BigDecimal emplSalary) { this.emplSalary = emplSalary; } @Override public String toString() { return \"Employee{\" + \"employeeId=\" + employeeId + \", emplName='\" + emplName + '\\'' + \", emplDob=\" + emplDob + \", emplSalary=\" + emplSalary + '}'; } @Override public int hashCode() { return Objects.hash(emplDob, emplName, emplSalary, employeeId); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; return Objects.equals(emplDob, other.emplDob) && Objects.equals(emplName, other.emplName) && Objects.equals(emplSalary, other.emplSalary) && employeeId == other.employeeId; } } Теперь, когда все готово, напишем тестики и разберем их. Тест-класс MarshallingTest package xml.junit.marshalling; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.junit.jupiter.api.Assertions.fail; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import org.hibernate.exception.ConstraintViolationException; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.MethodOrderer; import org.junit.jupiter.api.Order; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestMethodOrder; import jakarta.xml.bind.JAXBContext; import jakarta.xml.bind.JAXBException; import jakarta.xml.bind.Marshaller; import xml.junit.marshalling.dao.EmployeeDAO; import xml.junit.marshalling.model.Employee; @TestMethodOrder(MethodOrderer.OrderAnnotation.class) public class MarshallingTest { private static EmployeeDAO employeeDAO; private static HibernateConfig config = null; @BeforeAll static void configure() { employeeDAO = new EmployeeDAO(); } @Test @Order(1) void createValidEmployeeTest() { try { Employee empl = employeeDAO.getEmployeeFromXML(\"src/main/resources/files/emp1.xml\"); employeeDAO.saveEmployee(empl); } catch (IOException | JAXBException e) { fail(e.getLocalizedMessage()); } } @Test @Order(2) void createInvalidEmployeeTest() { try { Employee empl = employeeDAO.getEmployeeFromXML(\"src/main/resources/files/emp2.xml\"); assertThrows(ConstraintViolationException.class, () -> employeeDAO.saveEmployee(empl)); } catch (IOException | JAXBException e) { fail(e.getLocalizedMessage()); } } @Test @Order(3) void updateEmployeeTest() { try { Employee empl = employeeDAO.getEmployeeFromXML(\"src/main/resources/files/emp3.xml\"); employeeDAO.updateEmployee(empl, 3); } catch (IOException | JAXBException e) { fail(e.getLocalizedMessage()); } } @Test @Order(4) void employeeToXMLTest() { Employee emp = employeeDAO.findEmployeeByID(5); try { JAXBContext context = JAXBContext.newInstance(Employee.class); Marshaller marshaller = context.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE); BufferedWriter writer = new BufferedWriter(new FileWriter(\"src/main/resources/files/out.xml\")); marshaller.marshal(emp, writer); writer.close(); } catch (JAXBException | IOException e) { fail(); } } @Test @Order(5) void toJsonTest() throws Exception { employeeDAO.dumpEmployeeToJson(\"src/main/resources/files/out.json\", employeeDAO.findEmployeeByID(3)); } @Test @Order(6) void jsontest() throws IOException { employeeDAO.saveEmployee(employeeDAO.getEmployeeFromJson(\"src/main/resources/files/in.json\")); } } По умолчанию, у тестов есть свой определенный, но неочевидный порядок исполнения. Благодаря аннотации @TestMethodOrder мы можем настроить порядок выполнения тестов с помощью аннотации @Order. Хотелось бы заметить, что тесты исполняются в порядке от меньшей цифры до большей (т.е. если у нас в трех тестах Order будет 5, 13, 8, выполняться они будут в порядке возрастания от 5 до 13, отсутствие промежуточных цифр допускается). Запустим тесты: Задание Добавьте во второй проект тестовый класс HibernateTest. На основе знаний, полученных за первые два задания, напишите тесты для класса EmployeeDAO на проверку добавления нескольких валидных и невалидных сотрудников (метод saveEmployee), метод поиска сотрудников по ID (findEmployeeByID, если сотрудник не найден, возвращается null). Проверьте обновление(updateEmployee) и удаление сотрудников(removeEmployee). Изменения в классе EmployeeDAO приветствуются, если вы хотите написать другую логику поведения DAO-слоя. Мок-тестирование сервисного слоя с использованием Hibernate (Факультативная информация) До сих пор мы писали тесты, которые взаимодействовали с базой данной. Однако когда мы занимаемся тестированием реального продукта, мы не хотим добавлять в БД какие-либо записи, и так то мы тестируем на самом деле бизнес-логику. Чтобы тестировать не всю систему целиком, а только один ее компонент, есть мок-тесты. Мок-тест - это тест, в котором поведение какого-то компонента (в нашем случае, класса) заменяется актером/прокси-классом, которому мы расскажем, как себя вести, когда к нему обращаются. Соответственно, Mockito - это фреймворк, позволяющий создавать поведенческих актеров. Прежде чем написать тесты, давайте создадим проект. Базу данных мы всё ещё используем ту же, так что hibernate.cfg.xml просто скопируйте из прошлого проекта (ну или сделайте hibernate.properties, если вы читаете этот текст, наверное, вы это уже умеете делать). Структура у проекта будет следующая: Давайте в пару словах, что это за архитектура такая. В тестах выше мы просто делали DAO класс, однако в проектах зачастую используется паттерн проектирования Repository и луковичная архитектура. Об луковичной архитектуре подробнее можно почитать тут: https://habr.com/ru/articles/672328/ Добавим классы по папкам. Загрузим зависимости и приступим к коду! <dependencies> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-params</artifactId> <version>5.11.3</version> <scope>test</scope> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>9.0.0</version> </dependency> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-api</artifactId> <version>5.11.3</version> <scope>test</scope> </dependency> <dependency> <groupId>org.hibernate.orm</groupId> <artifactId>hibernate-core</artifactId> <version>6.6.1.Final</version> </dependency> <dependency> <groupId>jakarta.validation</groupId> <artifactId>jakarta.validation-api</artifactId> <version>3.1.0</version> </dependency> <dependency> <groupId>org.hibernate.validator</groupId> <artifactId>hibernate-validator</artifactId> <version>8.0.0.Final</version> </dependency> <dependency> <groupId>org.glassfish</groupId> <artifactId>jakarta.el</artifactId> <version>4.0.2</version> </dependency> <dependency> <groupId>org.mockito</groupId> <artifactId>mockito-junit-jupiter</artifactId> <version>5.14.2</version> <scope>test</scope> </dependency> </dependencies> Класс Employee package com.junit.mock.model; import java.math.BigDecimal; import java.sql.Date; import java.util.Objects; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; import jakarta.persistence.Temporal; import jakarta.persistence.TemporalType; import jakarta.validation.constraints.NotEmpty; import jakarta.validation.constraints.NotNull; import jakarta.validation.constraints.Past; import jakarta.validation.constraints.Pattern; import jakarta.validation.constraints.Positive; @Entity @Table(name = \"employee\") public class Employee { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"employee_id\") private int employeeId; @Column(name = \"empl_name\", nullable = false, length = 30) @Pattern (regexp = \"[А-ЯЁ][-А-яЁё]+ [А-ЯЁ][-А-яЁё]+ [А-ЯЁ][-А-яЁё]+\", message = \"Некорректный ввод ФИО\") @NotEmpty (message = \"Имя не может быть пустым\") private String emplName; @Column(name = \"empl_dob\", nullable = false) @Temporal(TemporalType.DATE) @Past (message = \"Время не может быть в будущем\") @NotNull (message = \"Дата рождения не может быть пустой\") private Date emplDob; @Column(name = \"empl_salary\", precision = 10, scale = 2) @Positive (message = \"Зарплата должна быть положительной\") private BigDecimal emplSalary; public Employee() { } public Employee(String emplName, Date emplDob, BigDecimal emplSalary) { this.emplName = emplName; this.emplDob = emplDob; this.emplSalary = emplSalary; } public Employee(int employeeId, String emplName, Date emplDob, BigDecimal emplSalary) { this(emplName, emplDob, emplSalary); this.employeeId = employeeId; } public int getEmployeeId() { return employeeId; } public Employee setEmployeeId(int employeeId) { this.employeeId = employeeId; return this; } public String getEmplName() { return emplName; } public Employee setEmplName(String emplName) { this.emplName = emplName; return this; } public Date getEmplDob() { return emplDob; } public Employee setEmplDob(Date emplDob) { this.emplDob = emplDob; return this; } public BigDecimal getEmplSalary() { return emplSalary; } public Employee setEmplSalary(BigDecimal emplSalary) { this.emplSalary = emplSalary; return this; } @Override public String toString() { return \"Employee{\" + \"employeeId=\" + employeeId + \", emplName='\" + emplName + '\\'' + \", emplDob=\" + emplDob + \", emplSalary=\" + emplSalary + '}'; } @Override public int hashCode() { return Objects.hash(emplDob, emplName, emplSalary, employeeId); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; return Objects.equals(emplDob, other.emplDob) && Objects.equals(emplName, other.emplName) && Objects.equals(emplSalary, other.emplSalary) && employeeId == other.employeeId; } } В парочке словах, если слово валидация для вас звучит новым и страшным: это когда мы проверяем, насколько у нас правильные данные. Например, положительный ли у человека возраст, не пытается ли кто-то положить в номер телефона буквы и т.д. Для валидации данных мы будем использовать Validation API. Этот API позволяет не писать нам логику валидации данных ручками и вместо этого пользоваться уже написанными за нас методами. Большинство аннотаций этого фреймворка можно найти в этой статье: https://medium.com/@tanersahin/java-bean-validation-with-javax-validation-5c11d9ebc409 Скорее всего, при прочтение данного класса модели все аннотации так или иначе оказались для вас понятными из-за говорящих названий (Past - дата в прошлом, NotNull - значение не должно быть null и т.д.). Единственная аннотация, которая могла вас напугать, это @Pattern. В качестве параметра она принимает регулярное выражение (regular expression) - это язык, который позволяет описывать какие-либо паттерны в тексте, и в этом примере, например, паттерн описывает, как должно выглядеть типичное русское ФИО. Подробно в тему регулярных выражений мы в этой лабораторной углубляться не будем :( Класс EmployeeNotFoundException public class EmployeeNotFoundException extends RuntimeException{ public EmployeeNotFoundException(int id) { super(String.format(\"Employee with ID %d is not found.\", id)); } } Хорошей практикой является описывать пользовательские исключения, чтобы более гибко вылавливать и обрабатывать их. Данное исключение будет выбрасываться если мы не найдем сотрудника в БД (в случае мок-тестов, если актер скажет, что он ничего не нашел). Класс EmployeeRepository package com.junit.mock.repository; import java.util.List; import java.util.Optional; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import org.hibernate.cfg.Configuration; import com.junit.mock.model.Employee; public class EmployeeRepository { private static SessionFactory sessionFactory = null; public EmployeeRepository() { sessionFactory = new Configuration().addAnnotatedClass(Employee.class).configure().buildSessionFactory(); } public void save(Employee employee) { Session session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); session.persist(employee); transaction.commit(); session.close(); } public Optional<Employee> findById(Integer id) { Session session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); Optional<Employee> employee = Optional.ofNullable(session.find(Employee.class, id)); transaction.commit(); session.close(); return employee; } public void delete(Employee employee) { Session session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); session.remove(employee); transaction.commit(); session.close(); } public Optional<Employee> update(Employee newEmployee, Integer id) { Session session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); Optional<Employee> employee = Optional.ofNullable(session.find(Employee.class, id)); employee.get().setEmplName(newEmployee.getEmplName()).setEmplDob(newEmployee.getEmplDob()) .setEmplSalary(newEmployee.getEmplSalary()); transaction.commit(); session.close(); return employee; } public List <Employee> findAll() { Session session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); List <Employee> employees = session.createQuery(\"FROM Employee\", Employee.class).list(); transaction.commit(); session.close(); return employees; } } DAO-слой у нас представлен классом EmployeeRepository. Этот слой отвечает за взаимодействие с базой данных. В репозитории НЕ должно быть никакой логики обработки получения данных с БД. Класс EmployeeService import java.util.List; import java.util.Set; import com.junit.mock.exception.EmployeeNotFoundException; import com.junit.mock.model.Employee; import com.junit.mock.repository.EmployeeRepository; import jakarta.validation.ConstraintViolation; import jakarta.validation.ConstraintViolationException; import jakarta.validation.Validation; import jakarta.validation.Validator; public class EmployeeService { private final EmployeeRepository repos; public EmployeeService(EmployeeRepository repos) { this.repos = repos; } public Employee saveEmployee(Employee employee) { Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Set<ConstraintViolation<Employee>> violations = validator.validate(employee); if (!violations.isEmpty()) throw new ConstraintViolationException(violations); repos.save(employee); Employee emp = findEmployeeByID(employee.getEmployeeId()); return emp; } public Employee findEmployeeByID(Integer id) { return repos.findById(id).orElseThrow(() -> new EmployeeNotFoundException(id)); } public List <Employee> getAllEmployees() { return repos.findAll(); } public Employee updateEmployee(Employee newEmpl, Integer id) { Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Set<ConstraintViolation<Employee>> violations = validator.validate(newEmpl); if (!violations.isEmpty()) throw new ConstraintViolationException(violations); findEmployeeByID(id); Employee newEmployee = repos.update(newEmpl, id).get(); return newEmployee; } public void removeEmployee(Integer id) { Employee employee = repos.findById(id).orElseThrow(() -> new EmployeeNotFoundException(id)); repos.delete(employee); } } Service-слой у нас представлен классом EmployeeService. В этом классе мы прописываем уже какое-то поведение для ответов, которые пришли от БД. Как видите, напрямую этот класс с БД не общается, а только описывает дальнейшее поведение. Например, прежде чем сохранить данные, он убеждается, что переданный сотрудник содержит валидные поля, а перед тем, как удалить сотрудника, он проверит, что в БД такой вообще существует (иначе, по умолчанию Hibernate, он просто проигнорирует запрос и ничего не скажет пользователю). Теперь замокаем нашу систему. Тест-класс MockTests package com.junit.mock; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.doNothing; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import java.math.BigDecimal; import java.sql.Date; import java.util.Optional; import java.util.stream.Stream; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.MethodOrderer; import org.junit.jupiter.api.Order; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.TestMethodOrder; import org.junit.jupiter.api.extension.ExtendWith; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.MethodSource; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.junit.jupiter.MockitoExtension; import com.junit.mock.exception.EmployeeNotFoundException; import com.junit.mock.model.Employee; import com.junit.mock.repository.EmployeeRepository; import com.junit.mock.service.EmployeeService; import jakarta.validation.ConstraintViolationException; @ExtendWith(MockitoExtension.class) @TestMethodOrder(MethodOrderer.OrderAnnotation.class) public class MockEmployeeRepository { @InjectMocks private EmployeeService service; @Mock private EmployeeRepository repository; private static Employee employee; private static Employee newEmployee; private static Employee invalidEmployee; @BeforeAll static void initialize() { employee = new Employee(5, \"Валобуев Михаил Семенович\", new Date(945153510963l), new BigDecimal(\"1000\")); newEmployee = new Employee(\"Миськевич Константин Александрович\", new Date(945153510963l), new BigDecimal(\"1200\")); invalidEmployee = new Employee(\"Инвалиды! Огузки!\", new Date(1022131568640l), new BigDecimal(\"-500\")); } static Stream<Employee> OKempl() { return Stream.of(new Employee(\"Бут-Гусаим Денис Михалыч\", new Date(945153510963l), new BigDecimal(\"1000\")), new Employee(\"Терентьев Михал Палыч\", new Date(988349168640l), new BigDecimal(\"1500\")), new Employee(\"Фролов Алексей Васильевич\", new Date(1022131568640l), new BigDecimal(\"1000\"))); } static Stream<Employee> BADempl() { return Stream.of(new Employee(\"InvalidName\", new Date(945153510963l), new BigDecimal(\"1000\")), new Employee(\"Терентьев Михал Палыч\", new Date(1734158310963l), new BigDecimal(\"1500\")), new Employee(\"Фролов Алексей Васильевич\", new Date(1022131568640l), new BigDecimal(\"-500\"))); } @ParameterizedTest @MethodSource(\"OKempl\") @Order(10) void saveEmployee_Valid_Test(Employee empl) { doNothing().when(repository).save(empl); when(repository.findById(empl.getEmployeeId())).thenReturn(Optional.of(empl)); Employee result = service.saveEmployee(empl); verify(repository).save(Mockito.any(Employee.class)); verify(repository).findById(empl.getEmployeeId()); assertEquals(empl, result); } @ParameterizedTest @MethodSource(\"BADempl\") @Order (11) void saveEmployee_Invalid_Test(Employee empl) { assertThrows(ConstraintViolationException.class, () -> service.saveEmployee(empl)); } @Test @Order (20) void removeEmployee_Successful_Test() { when(repository.findById(employee.getEmployeeId())).thenReturn(Optional.of(employee)); doNothing().when(repository).delete(employee); service.removeEmployee(employee.getEmployeeId()); verify(repository).delete(employee); verify(repository).findById(anyInt()); } @Test @Order (30) void updateEmployee_Successful_Test() { when(repository.findById(employee.getEmployeeId())).thenReturn(Optional.of(employee)); when(repository.update(newEmployee, employee.getEmployeeId())).thenReturn(Optional.of(newEmployee)); Employee newEmp = service.updateEmployee(newEmployee, employee.getEmployeeId()); assertEquals(newEmp, newEmployee); verify(repository).update(Mockito.any(Employee.class), anyInt()); verify(repository).findById(anyInt()); } @Test @Order (31) void updateEmployee_Invalid_Test() { assertThrows(ConstraintViolationException.class, () -> service.updateEmployee(invalidEmployee, 4)); } @Test @Order (32) void updateEmployee_NotFound_Test() { when(repository.findById(employee.getEmployeeId())).thenReturn(Optional.empty()); assertThrows(EmployeeNotFoundException.class, ()-> service.updateEmployee(newEmployee, employee.getEmployeeId())); verify(repository).findById(anyInt()); } } Теперь мы познакомимся с самым главным - кто же этот загадочный “актер”. Актер помечен в нашем тесте аннотацией @Mock. Мы не создаем никакого настоящего репозитория, этот класс ведет себя как болванка, которая будет делать то, что мы ей скажем. Когда мы будем разбирать это на примере теста, вам станет понятнее, что имеется ввиду. Аннотацией @InjectMock мы помечаем класс, в который мы засунем болванку. Наш сервисный класс даже не заподозрит, что он говорит не с настоящим репозиторием, а с актером, которому мы как суфлер подсказываем из-за кулис, что ему надо делать… Понесло на аналогии. Теперь давайте, например, разберем тест removeEmployee_Successful_Test void removeEmployee_Successful_Test() { when(repository.findById(employee.getEmployeeId())).thenReturn(Optional.of(employee)); doNothing().when(repository).delete(employee); service.removeEmployee(employee.getEmployeeId()); verify(repository).delete(employee); verify(repository).findById(anyInt()); } Итак, в первых двух строчках мы рассказываем мок-классу репозитория, что ему делать, когда к нему обращается сервис. Что это значит? Давайте заглянем в метод removeEmployee в классе EmployeeService: public void removeEmployee(Integer id) { Employee employee = repos.findById(id).orElseThrow(() -> new EmployeeNotFoundException(id)); repos.delete(employee); } В этом классе мы обращаемся к репозиторию два раза - сначала мы вызываем метод findById, который в обычном случае вернул бы из бд либо найденный объект, либо null. Затем обращается к методу delete. Однако теперь мы работаем с актером. Когда мы вызовем, например repos.findById(id), мы выполним этот код: when(repository.findById(employee.getEmployeeId())).thenReturn(Optional.of(employee)); “Когда мы просим у репозитория достать сотрудника, он вернет нам employee” Давайте немного проясним ситуацию. Мы НЕ работаем с базой данных от слова совсем. Этого сотрудника там может и не быть, мы об этом не можем знать, потому что у нас актер. Мы просто говорим актеру, что когда мы просим найти работника с id = employee.getEmployeeId(), он должен отдать нам employee Волобуева Михаила Семеновича. Здесь мы даже могли бы написать anyInt(), то есть хоть по id 5 хоть по 50 мы нашли бы там Волобуева и никого более. Соответственно, второй строчкой в нашем тестовом методе мы говорим, что когда мы вызываем метод delete у репозитория, актер ничего не должен делать. На четвертой и пятой строчке теста, когда мы используем verify, мы проверяем, что актер выполнил указанную функцию. Возможно, вас смутил, например, вот этот тест: void saveEmployee_Invalid_Test(Employee empl) { assertThrows(ConstraintViolationException.class, () -> service.saveEmployee(empl)); } Почему тут мы не определяем поведение актера? Давайте заглянем в метод saveEmployee: public Employee saveEmployee(Employee employee) { Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Set<ConstraintViolation<Employee>> violations = validator.validate(employee); if (!violations.isEmpty()) throw new ConstraintViolationException(violations); repos.save(employee); Employee emp = findEmployeeByID(employee.getEmployeeId()); return emp; } Если проследить за логикой выполнения этого метода, становится понятно, что мы просто не доходим до момента, когда мы обращаемся к репозиторию, поэтому нам не нужно говорить актеру, как себя вести. Что-то промежуточное можно увидеть в тесте updateEmployee_NotFound_Test: void updateEmployee_NotFound_Test() { when(repository.findById(employee.getEmployeeId())).thenReturn(Optional.empty()); assertThrows(EmployeeNotFoundException.class, ()-> service.updateEmployee(newEmployee, employee.getEmployeeId())); verify(repository).findById(anyInt()); } Заглянем в updateEmployee: public Employee updateEmployee(Employee newEmpl, Integer id) { Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Set<ConstraintViolation<Employee>> violations = validator.validate(newEmpl); if (!violations.isEmpty()) throw new ConstraintViolationException(violations); findEmployeeByID(id); Employee newEmployee = repos.update(newEmpl, id).get(); return newEmployee; } Как видите, мы успеваем выполнить findByID, после чего вызывается ошибка. Нам достаточно рассказать актеру, что делать, когда ему надо искать по ID, а дальше выкидывается эксепшн. Запускаем тесты: Ссылки на источники: [1] Фундаментальная теория тестирования: https://habr.com/ru/articles/549054/ Дата доступа: 01.11.2024 Файлы для лабораторной emp1.xml <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <employee> <emplName>Мирон</emplName> <emplDob>2004-01-01</emplDob> <emplSalary>1200</emplSalary> </employee> emp2.xml <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <employee> <emplName>Иван</emplName> <emplDob>2024-12-12</emplDob> <emplSalary>1500</emplSalary> </employee> emp3.xml <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <employee> <emplName>Александр</emplName> <emplDob>2001-12-01</emplDob> <emplSalary>1500</emplSalary> </employee> in.json { \"emplName\": \"Мишаня\", \"emplDob\": \"1988-04-23\", \"emplSalary\": 2000.23 }",
      "wordCount": 4223,
      "uploadDate": "2026-01-28T23:00:04.210Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        210439,
        6592,
        583154,
        63569,
        40675,
        207991,
        175700,
        606372,
        258320,
        269949,
        80317,
        166580,
        358853,
        50633,
        144351,
        8226,
        51172,
        80489,
        17907,
        22874,
        370121,
        331078,
        91694,
        41365,
        139330,
        237019,
        113593,
        141314,
        68217,
        316326,
        299038,
        62899,
        97703,
        150468,
        70088,
        51155,
        196844,
        514002,
        11546,
        46667,
        373154,
        204661,
        202700,
        62048,
        836865,
        488237,
        23171,
        1575,
        99470,
        72494,
        94049,
        158419,
        166140,
        36331,
        1058975,
        35737,
        303098,
        130099,
        183190,
        329147,
        153100,
        128350,
        122991,
        246253,
        48305,
        26362,
        17621,
        53173,
        28025,
        436225,
        443879,
        72750,
        110934,
        74654,
        35237,
        60981,
        598,
        407603,
        179605,
        104581,
        275190,
        341118,
        65550,
        405474,
        20381,
        10874,
        256416,
        263560,
        291290,
        269742,
        82061,
        67794,
        351548,
        126839,
        213131,
        251282,
        798021,
        742417,
        43262,
        443537,
        1264093,
        645258,
        60484,
        416810,
        753519,
        20918,
        398520,
        105866,
        69237,
        25173,
        300649,
        16703,
        93849,
        7940,
        112340,
        72003,
        128833,
        499971,
        70966,
        50765,
        225927,
        117086,
        135259,
        18237,
        11781,
        569520,
        115979,
        37535
      ],
      "shingleCount": 10550
    },
    {
      "id": 46,
      "title": "77777",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "77777.docx",
      "filePath": "data/uploads/1769641785426_77777.docx",
      "content": "Классификация основных фреймворков для автоматизированной сборки и управления проектами. Жизненный цикл приложения при управлении сборкой проекта. Применение Maven при разработке программного обеспечения (ПО). Конфигурация и порядок использования pom.xml файла. Основные команды и возможности Maven при управлении сборкой ПО. Архетипы приложений. Роль плагинов (plugins) в управлении жизненным циклом ПО. Понятие персистенции (persistence) в языках программирования. Отличительные свойства персистенции от маршаллинга (marshalling) и сериализации (serialization). Роль шаблона проектирования Data Access Object (DAO) на этапе разработки ПО. Платформенно независимые стандарты взаимодействия Java-приложения с источниками данных, их классификация и отличительные свойства (JDBC, ODBC). Возможности использования основных интерфейсов Statement, PreparedStatement, CollableStatement. Назначение и возможности применения методов предлагаемых интерфейсов. Цель и возможности управления персистентностью. Назначение и способы управления транзакциями в JDBC. Выборка и хранение данных с применением ResultSet. Способы управления данными в ResultSet. Современные форматы представления данных, переход от XML к JSON. Введение в понятия маршаллинга (marshalling), парсер JAXB. Современные форматы представления данных, переход от XML к JSON. Введение в понятия маршаллинга (marshalling), парсер Gson. Основное назначения, форматы и специфика применения JSON формата данных в приложениях. Применение событийного парсера XML документов. Классификация и основные возможности систем контроля версий (СКВ). Понятия локальных, централизованных и распределённых СКВ. Хостинг репозиториев GitHub и его основные возможности. Применение репозитория Git. Команды системы Git и их применение при совместном проектировании и разработке ПО. Понятие ветвей Git. Слияние ветвей и хранение копий разрабатываемого ПО. Назначение и возможности Java persistence API (JPA). Создание Plain Old Java Object (POJO) классов и их роль в системе. Преобразование POJO классов в классы Сущности (Entity). Персистенция объектов в java. Понятие технологии Object-Relational Mapping (ORM). Сравнение основных возможностей JPA и JDBC. Hibernate как основная реализация ORM технологии в спецификации JPA. Компоненты Hibernate. Выполнение запросов на основе SQL-подобного языка Hibernate Query Language (HQL). Применение классов EntityManager и SessionFactory при взаимодействии ПО с источником данных. Открытие сессий и выполнение CRUD операций с применением Hibernate. Транзакции и управление состоянием объекта персистенции. Назначение и конфигурация CreteriaAPI в Hibernate. Осуществление запросов в базу данных посредством стандартных методов Hibernate. Маппинг классов и создание связей между ними. Применение аннотаций для указания кратности связи 1:1, 1:М и М:1. Маппинг классов и создание связей между ними. Применение аннотаций для указания кратности связи М:М. Отладка и тестирование приложения средствами среды разработки, основные плюсы и минусы подхода. Точки Останова при разработке ПО. Модульное тестирование на основе Reflection API и Junit. Основные возможности феймворка JUnit. Основные аннотации, применяемые при тестировании ПО с помощью JUnit. Параметризированное и групповое тестирование. Мутационные тесты и их назначение. Техника test-driven development (TDD). Основные уровни OSI и изучаемые протоколы. Прикладной уровень OSI и протокол HTTP. Основные методы протокола HTTP. Структура запроса и ответа с использованием HTTP протокола. Java EE сервера и основные возможности, предоставляемые такими системами. Цель и назначение SOAP, RPC, gRPC. Понятие web-приложения и его назначение. Пример реализации классов обработки HTTP запросов. Создание сервлетов (servlet) и обеспечения доступа к ним. Жизненный цикл сервлета. Основные элементы и классы сервлетов. Основные подходы к созданию web-архитектуры приложения. Request и Response обращений. Дискриптор развёртывания приложения и возможность маппинга классов. Назначение cookies и cache. Создание фильтров (Filter) обработки запросов. Перенаправление запросов между классами сервлетов. Паттерн проектирования MVC и его реализация в web-приложении. Взаимодействие сервлетов с представлением. Понятие, назначение и цели Java Server Page (JSP). Применение Bootstrap и Thymeleaf для обеспечения представления. Принципы применения JSP Standard Tag Library (JSTL). Понятие REST и ключевые особенности построение приложения на его основе. Сходства и отличия понятий REST и RESTfull. Плюсы построения приложений на основе REST архитектуры. Степень соответствия приложения и правила построения REST-архитектуры. Назначение о обзор принципов SOLID. Назначение и возможности интеграции фреймворка Spring. Основной контекст (Context) приложения и его роль в системе. Понятие и назначение бина (Bean) приложения. Sping Core и базовые механизмы предоставляемые фреймворком. Назначение и цели Inversion of Control (IoC) в Spring. Реализация Dependency Injection (DI). IoC контейнер и управление жизненным циклом бина. Основные концептуальные решения создания бина приложения. Конфигурация бина приложения на основе XML файла. Надстройка Spring Boot и ее основные возможности. Конфигурация бина через основные аннотации Spring Boot. Реализация приложений на основе Spring Boot и Spring MVC. Пример создания класса Controller и привязка к контексту ПО. Особенности интеграции Spring Data в ПО и сравнение с Hibernate. Ключевые аспекты реализации классов CRUDRepository и JPARepositiry. Возможности применения Spring Security при разграничении прав доступа пользователей системы.",
      "wordCount": 693,
      "uploadDate": "2026-01-28T23:09:45.455Z",
      "category": "practice",
      "status": "final",
      "userId": "31810080",
      "institution": "БГУИР",
      "minhashSignature": [
        713150,
        321551,
        608273,
        545213,
        189858,
        402626,
        510924,
        801763,
        351212,
        61833,
        1060517,
        166580,
        820342,
        560216,
        982022,
        888978,
        130897,
        255731,
        344834,
        165936,
        90091,
        167056,
        602988,
        1273741,
        1997256,
        1127529,
        113593,
        141314,
        474145,
        397480,
        473736,
        82281,
        202130,
        393622,
        105690,
        4111785,
        230803,
        514002,
        1716028,
        44225,
        1080334,
        841895,
        583245,
        127195,
        638239,
        488237,
        1859242,
        1529290,
        579379,
        207880,
        716553,
        1046479,
        315492,
        36331,
        2136917,
        454246,
        131306,
        429139,
        1307316,
        2156791,
        133731,
        560256,
        219207,
        1458984,
        1172502,
        303420,
        1073294,
        1561612,
        222264,
        2640995,
        222090,
        173350,
        112505,
        4509,
        1111825,
        104103,
        308699,
        347937,
        258760,
        151169,
        763359,
        149415,
        1203626,
        2019722,
        2021001,
        496514,
        476060,
        289423,
        492977,
        239279,
        20757,
        157689,
        71562,
        2015446,
        3379174,
        119660,
        426772,
        704026,
        21971,
        598840,
        861635,
        645258,
        769567,
        361847,
        344239,
        7003,
        334585,
        442827,
        659752,
        406984,
        300649,
        599442,
        522062,
        178704,
        338247,
        2555307,
        344161,
        271136,
        58692,
        101195,
        795170,
        117086,
        704676,
        702716,
        622613,
        290401,
        568939,
        1200356
      ],
      "shingleCount": 3002
    },
    {
      "id": 47,
      "title": "123",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "123.docx",
      "filePath": "data/uploads/1769642079621_123.docx",
      "content": "1 Фреймворки автоматизированной сборки предназначены для управления процессом компиляции, тестирования, упаковки и развёртывания программного обеспечения. Они позволяют стандартизировать сборку проекта и исключить ручные действия. По принципу работы фреймворки сборки делятся на: • Скриптовые (Ant) сборка описывается последовательностью шагов • Декларативные (Maven, Gradle) описывается структура проекта и зависимости Apache Maven является декларативным фреймворком и основан на понятии жизненного цикла сборки. Жизненный цикл это строго определённая последовательность фаз, которые выполняются при сборке проекта: • validate • compile • test • package • install • deploy Maven широко применяется в промышленной разработке благодаря: • централизованному управлению зависимостями • повторяемости сборки • поддержке CI/CD • большому количеству плагинов 2 Файл pom.xml (Project Object Model) является центральным конфигурационным файлом Maven. В нём описываются: • координаты проекта • зависимости • плагины • жизненный цикл сборки Основные команды Maven: • mvn clean очистка сборки • mvn compile компиляция • mvn test запуск тестов • mvn package упаковка (JAR/WAR) Архетипы Maven это шаблоны проектов, которые позволяют быстро создать стандартную структуру приложения. Плагины Maven расширяют возможности сборки и выполняют конкретные задачи 3 Персистенция это способность объекта сохранять своё состояние между запусками приложения, как правило, путём хранения в базе данных. Отличия: • Персистенция долговременное хранение (БД) • Сериализация преобразование объекта в поток байт (файл, сеть) • Маршаллинг преобразование объекта в формат обмена (XML, JSON) Персистенция обычно реализуется через ORM-фреймворки (Hibernate, JPA), которые автоматически отображают объектную модель на реляционную БД. 4 Data Access Object (DAO) шаблон проектирования, который инкапсулирует логику доступа к данным и отделяет бизнеслогику от работы с БД. Преимущества DAO: • упрощение поддержки кода • изоляция SQL • возможность замены источника данных JDBC (Java Database Connectivity) стандарт Java для работы с БД. ODBC (Open Database Connectivity) — универсальный интерфейс, независимый от языка программирования. JDBC: • ориентирован на Java • типобезопасен • быстрее и удобнее в Java-приложениях 5 В JDBC существуют три основных интерфейса для выполнения SQL-запросов: • Statement используется для простых SQL-запросов • PreparedStatement поддерживает параметры, защищает от SQL-инъекций • CallableStatement предназначен для вызова хранимых процедур PreparedStatement предпочтительнее, так как: • повышает производительность. • безопасен • поддерживает повторное использование 6 Управление персистентностью направлено на обеспечение корректного, надёжного и согласованного хранения данных между запусками приложения. Основные цели: • сохранение целостности данных; • контроль изменений объектов; • поддержка атомарности операций; • обработка ошибок при работе с БД. Транзакция в JDBC это логическая единица работы, состоящая из нескольких SQL-операций, которые должны выполниться либо полностью, либо не выполниться вовсе. По умолчанию JDBC работает в режиме autoCommit = true, при котором каждая операция фиксируется автоматически. Основные операции управления транзакциями: • setAutoCommit(false) • commit() • rollback() 7 ResultSet это объект JDBC, представляющий результат выполнения SQL-запроса SELECT. Он позволяет построчно получать данные из результата запроса. Основные возможности ResultSet: • последовательный доступ к данным (next()); • получение значений по имени или индексу столбца; • поддержка разных режимов прокрутки (forward-only, scrollable); • обновление данных напрямую из ResultSet (при соответствующей конфигурации). ResultSet тесно связан с Statement и Connection, и существует только пока они открыты. 8 XML долгое время являлся основным форматом обмена данными между системами. Его преимущества строгая структура и расширяемость, недостатки избыточность и большой объём. Маршаллинг (marshalling) процесс преобразования объекта в формат передачи данных (XML или JSON). JAXB (Java Architecture for XML Binding) стандарт Java для преобразования Java-объектов в XML и обратно. JAXB использует аннотации для описания соответствия между классами и XML-структурой. 9 JSON постепенно вытеснил XML благодаря компактности, простоте чтения и лёгкой интеграции с web-приложениями. Gson библиотека Google для сериализации и десериализации Java-объектов в JSON. Она: • не требует аннотаций по умолчанию; • легко интегрируется с REST API; • поддерживает коллекции и вложенные объекты. Gson активно используется в клиент-серверных и микросервисных архитектурах. 10 JSON (JavaScript Object Notation) текстовый формат обмена данными, широко применяемый в web-приложениях, REST API и микросервисах. Основные особенности JSON: • структура «ключ–значение»; • поддержка массивов и вложенных объектов; • независимость от языка программирования; • компактность по сравнению с XML. JSON чаще всего используется: • при обмене данными между frontend и backend; • в REST -сервисах; • при передаче конфигураций и сообщений. 11 Событийный парсер XML используется для обработки XMLдокументов без загрузки всего файла в память. Это особенно важно при работе с большими XML-файлами. В Java наиболее распространённым событийным парсером является SAX (Simple API for XML). Принцип работы SAX-парсера основан на событиях: • начало элемента (startElement) • конец элемента (endElement) • обработка текстовых данных (characters) Основное преимущество SAX высокая производительность и минимальное потребление памяти. Недостатком является сложность логики обработки, так как данные обрабатываются последовательно. 12 Система контроля версий (СКВ) это программный инструмент, предназначенный для управления изменениями в исходном коде и документации. СКВ классифицируются на: 1. Локальные история хранится локально (RCS) 2. Централизованные единый сервер (SVN, CVS) 3. Распределённые у каждого разработчика полный репозиторий (Git, Mercurial) Распределённые СКВ обладают преимуществами: • автономная работа • высокая надёжность • гибкое ветвление 13 GitHub облачная платформа для хостинга Git-репозиториев и совместной разработки ПО. Основные возможности GitHub: • хранение репозиториев; • Pull Request и Code Review;• управление задачами (Issues); • CI/CD через GitHub Actions; • контроль доступа и ролей. GitHub широко используется в командной разработке и opensource проектах. 14 Git распределённая система контроля версий, позволяющая эффективно управлять разработкой ПО. Основные команды Git: • clone клонирование репозитория • add добавление файлов в индекс • commit фиксация изменений • pull получение обновлений • push отправка изменений Git обеспечивает безопасную и параллельную работу нескольких разработчиков. 15 Ветка (branch) в Git это независимая линия разработки, позволяющая разрабатывать функциональность параллельно с основной версией проекта. Основные операции с ветками: • создание ветки; • переключение между ветками; • слияние (merge); • разрешение конфликтов. Ветки обеспечивают безопасную разработку новых функций без риска повредить основной код. 16 Java Persistence API (JPA) это спецификация Java, предназначенная для управления персистентностью объектов и их хранения в реляционных базах данных. JPA определяет набор интерфейсов и аннотаций, но не является конкретной реализацией. Реализациями JPA являются Hibernate, EclipseLink и другие. POJO (Plain Old Java Object) это обычный Java-класс без зависимостей от фреймворков. Такие классы удобны для тестирования и повторного использования. Чтобы объект стал персистентным, POJO необходимо преобразовать в Entity, добавив аннотации JPA. Entity-класс: • соответствует таблице БД; • имеет уникальный идентификатор;• управляется JPA-контейнером. 17 Object-Relational Mapping (ORM) технология, которая автоматически связывает объектную модель приложения с реляционной моделью базы данных. ORM скрывает SQL-код и позволяет работать с БД через объекты. JPA использует ORM- подход и предоставляет: • автоматическое управление SQL; • кэширование; • управление транзакциями; • декларативные связи между сущностями. JDBC, в отличие от JPA: • требует ручного написания SQL; • не управляет объектным состоянием; • даёт более низкоуровневый контроль. JPA упрощает разработку, JDBC используется там, где нужен максимальный контроль. 18 Hibernate наиболее популярная реализация спецификации JPA. Он предоставляет расширенные возможности по сравнению с чистым JPA. Основные компоненты Hibernate: • SessionFactory фабрика сессий; • Session контекст работы с БД; • Transaction управление транзакциями; • Query выполнение запросов. Hibernate поддерживает HQL (Hibernate Query Language) — объектно-ориентированный язык запросов, независимый от конкретной СУБД. 19 EntityManager основной интерфейс JPA для управления жизненным циклом сущностей. SessionFactory — объект Hibernate, создающий сессии для работы с БД. CRUD-операции: • Create persist • Read find, get • Update merge • Delete remove EntityManager автоматически отслеживает изменения сущностей в рамках транзакции. 20 В JPA и Hibernate объект может находиться в одном из состояний: • Transient не связан с БД • Persistent управляется контекстом • Detached отсоединён от контекста • Removed помечен на удаление Criteria API предназначен для создания типобезопасных запросов без использования строкового HQL или SQL. Он удобен для динамического построения запросов. 21 Hibernate предоставляет несколько способов выполнения запросов к базе данных, что позволяет выбирать оптимальный вариант в зависимости от задачи. Основные подходы: • HQL (Hibernate Query Language) — объектноориентированный язык запросов; • Criteria API типобезопасный программный способ построения запросов; • Native SQL выполнение «чистых» SQL-запросов. Преимущество Hibernate-запросов заключается в том, что разработчик оперирует сущностями и их свойствами, а не таблицами и колонками, что повышает переносимость кода между СУБД. 22 Маппинг это процесс сопоставления Java-классов с таблицами базы данных. В JPA/Hibernate связи между сущностями задаются с помощью аннотаций. Основные типы связей: • One-to-One (1:1) один объект соответствует одному; • One-to-Many (1:М) один объект связан с несколькими; • Many-to-One (М:1) несколько объектов связаны с одним. Корректный маппинг связей позволяет Hibernate автоматически управлять внешними ключами и загрузкой данных. 23 Связь Many-to-Many означает, что нескольким объектам одного класса соответствуют несколько объектов другого класса. В реляционных БД такая связь реализуется через промежуточную таблицу. В Hibernate для этого используется аннотация @ManyToMany, а также @JoinTable для указания таблицы связей. Связь М:М часто применяется, например, между пользователями и ролями. 24 Отладка (debugging) процесс поиска и исправления ошибок в программе с использованием инструментов среды разработки (IntelliJ IDEA, Eclipse). Основные возможности отладки: • установка точек останова (breakpoints); • пошаговое выполнение кода; • просмотр значений переменных; • анализ стека вызовов. Преимущество отладки точное понимание поведения программы. Недостаток невозможность выявить все логические ошибки без тестирования. 25 Модульное тестирование направлено на проверку отдельных компонентов (методов, классов) программы в изоляции. JUnit — основной фреймворк для модульного тестирования в Java. Он позволяет: • автоматизировать тестирование; • проверять ожидаемые результаты; • интегрироваться с Maven и CI-системами. Reflection API может использоваться для тестирования приватных методов и анализа структуры классов, однако применять его следует осторожно. 26 Параметризованные тесты позволяют запускать один тест с разными входными данными. TDD (Test Driven Development) разработка через тесты: тест → код → рефакторинг. Мутационные тесты проверяют качество тестов путём внесения ошибок в код. 27 Модель OSI состоит из 7 уровней. HTTP относится к прикладному уровню и используется для передачи данных в web-приложениях. Основные HTTP-методы: • GET • POST • PUT • DELETE 28 HTTP-запрос состоит из: • стартовой строки; • заголовков; • тела (опционально). HTTP-ответ содержит: • статус-код;• заголовки; • тело ответа. Пример 29 Java EE серверы (WildFly, GlassFish) предоставляют: • управление транзакциями; • безопасность; • web-сервисы. SOAP XML-based web-сервисы. RPC / gRPC удалённый вызов процедур, gRPC использует protobuf. 30 Web-приложение серверное ПО, доступное через браузер по HTTP. Основная задача обработка запросов и формирование ответов. В Java это реализуется через сервлеты или Spring MVC. 31 Сервлет это Java-класс, предназначенный для обработки HTTP-запросов и формирования HTTP-ответов в webприложении. Сервлеты работают на стороне сервера и являются основой Java-web-разработки. Доступ к сервлету обеспечивается: • через аннотацию @WebServlet • либо через конфигурацию в web.xml Жизненный цикл сервлета управляется контейнером сервлетов (Tomcat): 1. init() инициализация сервлета (вызывается один раз) 2. service() → doGet(), doPost() обработка запросов 3. destroy() освобождение ресурсов 32 Основные классы и интерфейсы сервлетов: • HttpServlet базовый класс • HttpServletRequest объект запроса • HttpServletResponse объект ответа • ServletConfig конфигурация сервлета • ServletContext контекст приложения Сервлет получает данные из запроса (параметры, заголовки, тело) и формирует ответ клиенту. 33 Современные web-приложения строятся на основе клиентсерверной архитектуры. Клиент отправляет HTTP- запрос, сервер обрабатывает его и возвращает HTTP-ответ. Основные подходы: • монолитные web-приложения • MVC-архитектура • REST -архитектура Request содержит: • URL • HTTP-метод • параметры • заголовки Response содержит: • статус ответа • заголовки • тело ответа 34 Дескриптор развёртывания (web.xml) XML- файл, описывающий конфигурацию web-приложения: сервлеты, фильтры, маппинги, безопасность. Cookies используются для хранения данных на стороне клиента (сессии, настройки). Кэширование повышает производительность. Фильтры (Filter) позволяют перехватывать запросы и ответы (логирование, авторизация). 35 Перенаправление используется для передачи управления между сервлетами или страницами. Существует два основных механизма: • Redirect (sendRedirect) клиент делает новый запрос • Forward (RequestDispatcher.forward) перенаправление внутри сервера Redirect используется при смене URL, Forward для внутренней логики. 36 MVC (Model–View–Controller) архитектурный паттерн, разделяющий приложение на три компонента: • Model бизнес-логика и данные (например, JPAсущности) • View представление пользователю (JSP, Thymeleaf) • Controller обработка запросов, маршрутизация, вызов сервисов Преимущества: • упрощение поддержки кода • повторное использование компонентов • разделение обязанностей 37 JSP (Java Server Pages) технология генерации HTML на сервере с возможностью вставки Java-кода. Thymeleaf современный серверный шаблонизатор, интегрируется с Spring. JSTL — библиотека тегов для JSP, упрощает цикл, условие и работу с коллекциями. Bootstrap CSS-фреймворк для красивого оформления страниц. 38. REST (Representational State Transfer) архитектурный стиль для построения web-сервисов. Основные принципы: • ресурсы идентифицируются URI • операции ограничены HTTP-методами: GET, POST, PUT, DELETE • stateless (без состояния) • использование стандартных форматов данных (JSON, XML) RESTful API сервис, строго соответствующий принципам REST. Плюсы: • простота интеграции с клиентами • совместимость с веб-приложениями • поддержка масштабирования 39 Для того чтобы приложение соответствовало REST: • URI должны идентифицировать ресурсы (/users/1) • HTTP-методы должны отражать действие (GET, POST, PUT, DELETE) • Статусы HTTP должны быть корректными (200 OK, 404 Not Found) • Использовать HATEOAS (по желанию) для навигации между ресурсами Проверка соответствия REST помогает поддерживать совместимость и удобство API для клиентов. 40 SOLID пять принципов объектно- ориентированного проектирования: 1. S (Single Responsibility Principle) один класс, одна ответственность 2. O (Open/Closed Principle) открыто для расширения, закрыто для изменения 3. L (Liskov Substitution Principle) объекты подклассов должны заменять объекты суперкласса 4. I (Interface Segregation Principle) маленькие, специализированные интерфейсы 5. D (Dependency Inversion Principle) зависимость от абстракций, а не от конкретных реализаций Следование SOLID делает код: • более модульным • тестируемым • сопровождаемым 41 Spring Framework это мощный фреймворк для разработки Java-приложений, который обеспечивает: • управление зависимостями и конфигурацией приложений через IoC-контейнер; • интеграцию с базами данных, веб-сервисами и безопасностью; • поддержку различных модулей: Spring Core, Spring MVC, Spring Data, Spring Security, Spring Boot. Контекст (ApplicationContext) центральный контейнер Spring, который управляет жизненным циклом бинов и их зависимостями. 42 Bean объект, управляемый Spring IoC контейнером. Особенности бина: • создаётся контейнером, а не вручную; • может иметь зависимости, которые внедряются автоматически; • жизненный цикл управляется Spring (инициализация, уничтожение). 43 Spring Core предоставляет: • IoC (Inversion of Control) контейнер управляет зависимостями; • DI (Dependency Injection) внедрение зависимостей через конструктор, сеттер или поле; • конфигурацию через XML, аннотации или Java Config. 44 IoC принцип, при котором контейнер управляет созданием и жизненным циклом объектов. DI способ реализации IoC, внедряющий зависимости через: • конструктор • сеттер • поле DI позволяет: • уменьшить связность компонентов; • упростить тестирование; • гибко конфигурировать приложение. 45 Жизненный цикл бина в Spring: 1. Создание экземпляра 2. Внедрение зависимостей 3. Инициализация (методы @PostConstruct) 4. Работа бина 5. Уничтожение (методы @PreDestroy) Контейнер управляет всеми этапами, обеспечивая консистентность и контроль зависимостей. 46 Ранее Spring широко использовал XML для определения бинов: <beans xmlns=\"http://www.springframework.org/schema/beans\"> <bean id=\"userService\" class=\"com.example.UserService\"/> </beans> Преимущества: • централизованная конфигурация • возможность менять реализацию без перекомпиляции 47 Spring Boot надстройка над Spring, упрощающая конфигурацию: • автоконфигурация • встроенный сервер (Tomcat) • упрощённая работа с зависимостями • быстрое создание REST и web-приложений 48 Spring MVC интегрирован в Spring Boot. Контроллеры управляют запросами и возвращают представление. 49 Spring Data упрощает работу с базой данных, предоставляя интерфейсы CrudRepository и JpaRepository: • CRUD операции без написания SQL • Поддержка пагинации и сортировки • Расширение через кастомные методы 50. Spring Security предоставляет комплексные возможности для управления правами доступа: - Аутентификация и авторизация на основе ролей (ROLE ADMIN, ROLE _ _ USER) - Защита URL-путей с помощью аннотаций @PreAuthorize, @PostAuthorize - Метод-левел безопасность для контроля доступа к методам сервисов - Интеграция с JWT для stateless-аутентификации в REST API Кастомизация правил доступа через SecurityConfig с использованием HttpSecurity - Поддержка OAuth2 для внешней аутентификации (Google, GitHub и др.) - Возможность создания сложных правил доступа на основе SpEL выражений Пример конфигурации доступа:",
      "wordCount": 2461,
      "uploadDate": "2026-01-28T23:14:39.711Z",
      "category": "practice",
      "status": "final",
      "userId": "31810080",
      "institution": "БГУИР",
      "minhashSignature": [
        23179,
        48624,
        447012,
        63569,
        30795,
        53090,
        206744,
        134434,
        72007,
        195466,
        135514,
        166580,
        80905,
        50633,
        982022,
        494538,
        742674,
        80489,
        17907,
        99793,
        43274,
        224245,
        185551,
        45863,
        719842,
        18327,
        27226,
        141314,
        474145,
        326667,
        123530,
        82281,
        114802,
        692404,
        43608,
        215639,
        128606,
        152983,
        307433,
        44225,
        67600,
        9763,
        583245,
        127195,
        64093,
        488237,
        298217,
        272110,
        52576,
        207880,
        152863,
        114940,
        355005,
        36331,
        117786,
        454246,
        179185,
        176152,
        144323,
        364584,
        46078,
        53725,
        122991,
        46854,
        261438,
        126907,
        2274,
        103584,
        134646,
        240949,
        222090,
        173350,
        13049,
        4509,
        35237,
        60981,
        39245,
        285708,
        258760,
        104581,
        317186,
        53068,
        46543,
        26384,
        102984,
        10874,
        296337,
        104673,
        56438,
        178440,
        13992,
        157689,
        569104,
        67318,
        98880,
        119660,
        725352,
        780613,
        27602,
        221872,
        265935,
        805,
        404804,
        491495,
        344239,
        7003,
        225975,
        231004,
        69237,
        108284,
        237295,
        599442,
        392937,
        36293,
        50060,
        129544,
        344161,
        725447,
        26134,
        101195,
        321005,
        117086,
        298707,
        568017,
        62627,
        290401,
        53574,
        37535
      ],
      "shingleCount": 9512
    },
    {
      "id": 48,
      "title": "ХА АНДРЕЙ 2.0",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "ХА АНДРЕЙ 2.0 (1).docx",
      "filePath": "data/uploads/1769642261789_ХА_АНДРЕИ__2_0__1_.docx",
      "content": "Министерство образования Республики Беларусь Учреждение образования «Белорусский государственный университет информатики и радиоэлектроники» Факультет компьютерного проектирования Кафедра проектирования информационно–компьютерных систем Дисциплина «Разработка программных приложений для бизнес-анализа» «К ЗАЩИТЕ ДОПУСТИТЬ» Руководитель курсового проекта Ассистент кафедры ПИКС _______________ К.С. Крез ___.____.2025 ПОЯСНИТЕЛЬНАЯ ЗАПИСКА к курсовой работе на тему: «Разработка модульной системы проверки на заимствования текста с использованием Docker–контейнеров» БГУИР КП 1–39 02 01 080 ПЗ Выполнил студент группы 314302 Ханцевич Андрей Александрович _______________________________ (подпись студента) Курсовой проект представлен на проверку ___.____.2025 _______________________________ (подпись студента) Минск 2025 РЕФЕРАТ БГУИР КП 1–39 02 01 080 ПЗ Ханцевич А.А. Разработка модульной системы проверки на заимствования текста с использованием Docker–контейнеров: пояснительная записка к курсовому проекту/ А.А. Ханцевич. – Минск: БГУИР, 2025. – 72 с. Пояснительная записка 72 с., 32 рис., 7 табл., 30 источников, 3 приложения. РАЗРАБОТКА МОДУЛЬНОЙ СИСТЕМЫ ПРОВЕРКИ НА ЗАИМСТВОВАНИЯ ТЕКСТА С ИСПОЛЬЗОВАНИЕМ DOCKER–КОНТЕЙНЕРОВ Цель проектирования: создание модульного программного средства для проверки текстов на заимствования, реализованного на основе микросервисной архитектуры и развёртываемого с использованием Docker–контейнеров. Система должна обеспечивать высокую производительность, удобство масштабирования и изоляцию вычислительных модулей, участвующих в анализе текстов и обработке запросов пользователей. Методология проведения работы: при проектировании применялись принципы модульности, отказоустойчивости и горизонтального масштабирования. Выполнен анализ существующих решений в сфере проверки уникальности текста и определены требования к функциональности, безопасности, хранению данных и взаимодействию сервисов. Результаты работы: разработана архитектура программного средства, включающая отдельные сервисы для обработки запросов пользователей, анализа текстовых данных, управления базой текстов и формирования отчётов. Каждая функциональная часть системы упакована в Docker–контейнер, что обеспечивает гибкое управление конфигурациями, удобство обновления и переносимость решения. Реализован пользовательский веб–интерфейс с возможностью загрузки файлов, просмотром результатов проверки и управлением историей анализов. Предусмотрены механизмы логирования, мониторинга, защиты данных и контроля доступа к функциональным элементам системы. Область применения результатов: разработанное решение может использоваться в образовательных учреждениях, научных организациях и коммерческих компаниях для автоматизации проверки оригинальности контента, повышения качества работ и предотвращения нарушений авторских прав. Благодаря модульной архитектуре система легко адаптируется под различные предметные области и объёмы данных, а технология контейнеризации упрощает её внедрение в существующие ИТ–инфраструктуры. СОДЕРЖАНИЕ Введение 20 1 Анализ исходных данных к курсовому проекту. 20 1.1 Анализ исходных данных к курсовому проекту 20 1.2 Обзор существующих программных средств по теме курсовой работы 20 1.3 Обоснование и описание выбора языка программирования, средств разработки, используемых технологий и сторонних библиотек. 20 1.4 Постановка задач на курсовую работу 20 2 Разработка и реализация процесса контейнеризации программного средства с использованием технологии Docker. 20 2.1. Теоретические основы и анализ технологий контейнеризации. 20 2.2. Проектирование и практическая реализация контейнеризации проекта 21 2.2.1. Анализ архитектуры и технологического стека исследуемого проекта 21 2.2.2 Проектирование контейнерной инфраструктуры. 22 2.2.3 Разработка Dockerfile. 22 2.2.4 Оркестрация контейнеров с помощью Docker Compose. 24 2.3 Тестирование и оценка эффективности внедренного решения 25 2.3.1 Методология тестирования решения 25 2.3.2 Сравнительный анализ показателей до и после внедрения контейнеризации 25 2.3.3 Анализ аспектов безопасности. 26 2.4 Выводы по главе. 28 3 Реализация централизованного управления данными аутентификации посредством LDAP 20 3.1 Настройка Celery 20 3.2 Анализ исходных данных к курсовому проекту 20 3.3 Вывод по главе 20 4 Проектирование, разработка 20 4.1 Проектирование и реализация способа хранения данных программного средства 20 4.2 Проектирование и разработка графического интерфейса 20 4.3 Тестирование программного средства 20 4.4 Вывод по главе 20 5 Эксплуатация программного средства 25 5.1 Ввод в эксплуатацию и обоснование минимальных технических требований к оборудованию 25 5.2 Руководство по эксплуатации программным средством 25 Заключение 20 Приложение А (обязательное) Отчет о проверке на заимствование в системе \"Антиплагиат\" 20 Приложение Б (обязательное) Листинг кода алгоритмов, реализующих основную бизнес-логику 20 Приложение В (обязательное) Графический материал 20 Приложение Г (обязательное) Ведомость курсового проекта 20 ВВЕДЕНИЕ В рамках данного курсового проекта разработана модульная система для проверки текстовых документов на заимствования с использованием технологии Docker–контейнеризации. Программное средство предназначено для автоматизации процесса выявления сходств между документами и упрощения развёртывания системы на различных программно–аппаратных платформах. Основная цель проекта заключается в создании гибкого, масштабируемого и легко поддерживаемого веб–сервиса, обеспечивающего анализ текстов и предоставляющего пользователям отчёты о степени уникальности материалов. Использование Docker позволяет изолировать компоненты системы, обеспечить независимость от окружения и повысить надёжность процесса развёртывания. При выполнении курсовой работы проведён анализ исходных данных и существующих программных средств в области проверки уникальности текстов, обоснован выбор фреймворка Django и технологий, применяемых при контейнеризации. Реализована архитектура, включающая отдельные контейнеры для веб–приложения и сопутствующих сервисов, проведено тестирование работоспособности и оценка преимуществ контейнерного подхода. Пояснительная записка включает описание используемых методов проверки на заимствования, проектирование и реализацию системы контейнеризации, разработку механизмов обработки и хранения данных, а также инструкцию по эксплуатации и развёртыванию программного средства. В работе представлены графические материалы, демонстрирующие структуру приложения, диаграммы развертывания и элементы пользовательского интерфейса. Разработанное программное средство может использоваться в учебном процессе БГУИР для автоматизированного контроля оригинальности студенческих и научных работ, а также служить основой для дальнейшего расширения функциональности и внедрения более совершенных алгоритмов анализа текстов. Проект был выполнен самостоятельно и протестирован на уникальность с помощью системы «Антиплагиат». Процент оригинальности составил 85%. Все цитирования и использованные материалы будут четко указаны в «Списке использованных источников». Анализ исходных данных и постановка задач 1.1 Анализ исходных данных к курсовому проекту Современные системы проверки текстовых документов на заимствования активно используются в образовательных учреждениях, научных организациях и коммерческих компаниях. С ростом объёмов цифрового контента и увеличением количества текстовой информации необходимость автоматизированной обработки документов становится критически важной. Традиционные системы часто сталкиваются с ограничениями, связанными с низкой масштабируемостью, недостаточной скоростью анализа и сложностью развертывания. Отсутствие модульной архитектуры и слабая изоляция вычислительных процессов могут приводить к снижению производительности, конфликтам зависимостей и нестабильной работе системы. Кроме того, многие решения не обеспечивают гибкости при обновлении и замене отдельных компонентов, что усложняет поддержку и развитие программного средства. Для решения этих проблем в рамках курсового проекта предлагается разработать модульную систему проверки текстов на заимствования с использованием Docker–контейнеров. Сервис будет состоять из изолированных компонентов, отвечающих за загрузку документа, очистку и нормализацию текста, формирование векторных представлений, поиск семантических совпадений и генерацию итогового отчёта. Контейнеризация позволит обеспечить воспроизводимость окружения, стабильность работы и возможность горизонтального масштабирования. Основные функции разрабатываемой системы включают обработку текстовых файлов различных форматов, построение пайплайна предварительной обработки данных, применение нескольких моделей для формирования векторных представлений, сравнение документов по семантическим признакам, а также предоставление пользователю отчёта о найденных заимствованиях. Ожидаемыми результатами внедрения системы являются повышение точности и скорости анализа текстов, упрощение переноса и развертывания программного обеспечения, возможность гибкого расширения функциональности и снижение вероятности ошибок, связанных с ручной проверкой документов. Разработка такого веб–приложения способствует автоматизации анализа текстовых данных, повышению качества оценки оригинальности документов и оптимизации процессов обработки информации в образовательной и научной сферах. 1.2 Обзор существующих программных средств по теме курсовой работы В сети Интернет существует множество веб–сервисов для проверки текста на наличие заимствование. Однако большое количество данных программных средств не говорит о бессмысленности разрабатываемого приложения. Несмотря на то, что существующие программы предоставляют различные функции, многие пользователи могут позволить только бесплатный интерфейс, не имея доступа к полному функционалу, что уменьшает количество как потенциальных пользователь, так и качество квалификационных работ, созданных без использования детальной проверки на наличие заимствований. Было принято решение рассмотреть наиболее популярные и схожие с разрабатываемым веб–сервисом программные средства. Так для сравнения были выбраны: «Антиплагиат», «», «.», «» и «1». Антиплагиат – платформа, которая широко используется для выявления плагиата. Основана на сравнении текста работы с обширной базой данных научных публикаций, учебных материалов, интернет–ресурсов и других источников. Пользователи могут загружать свои работы на платформу и получать детальные отчеты о совпадениях с другими источниками. Антиплагиат обладает высокой степенью точности в обнаружении заимствований и широко используется в образовательных учреждениях и научных организациях [2]. – инструмент для анализа оригинальности текста, который позволяет загружать и анализировать документы в различных форматах. предоставляет гибкие настройки поиска заимствований и создает подробные отчеты о совпадениях, помогая пользователям эффективно бороться с копированием и поддерживать академическую честность [3]. . – многофункциональный инструмент для проверки текста, который помимо анализа грамматики и стиля также предлагает возможность проверки оригинальности контента. Пользователи могут использовать Text.ru для обнаружения плагиата и помогает избежать нежелательных совпадений с другими источниками. Инструмент предоставляет детальные отчеты о совпадениях, что помогает поддерживать высокую уникальность и качество текстов [4]. – специализированное программное обеспечение, разработанное для обнаружения плагиата в текстах. проводит сканирование веб–ресурсов с целью выявления совпадений и предоставляет пользователям подробные отчеты о найденных схожих фрагментах. Этот инструмент помогает обеспечить уникальность контента и защитить авторские права [5]. 1 – инновационное решение для борьбы с плагиатом, предназначенное как для образовательных, так и для коммерческих целей. 1 предлагает широкий спектр функций для анализа текста и генерирует подробные отчеты о совпадениях с другими источниками. Инструмент помогает пользователям эффективно бороться с плагиатом и поддерживать высокий уровень академической и профессиональной честности [6]. На рисунке 1.1 представлен экран авторизации веб–сервиса «1.». Рисунок 1.1 – Экран авторизации веб–сервиса «1.» Рассмотрим непосредственно экран, изображенный на рисунке 1.1. Заметно, что интерфейс достаточно информативен и интуитивно понятен для пользователя. Несмотря на то, что на экране содержится много информации, она организована компактно и четко. Но крупные иконки занимают значительное пространство. При рассмотрении системы аутентификации важно обратить внимание на функциональные возможности. Обычно экран авторизации содержит поля для ввода адреса электронной почты и пароля, а также предлагает возможность аутентификации через социальные сети. Кроме того, присутствуют кнопки «Войти», «Регистрация» и «Забыли пароль». Однако, в данном случае, ни один из представленных веб–сервисов не соответствует требуемому функционалу, поскольку в системе предусмотрена регистрация пользователей. Вместо этого необходимо обеспечить только процесс авторизации, который должен быть связан и взаимодействовать с информационной системой БГУИР. Рассмотрим экран для работы с антиплагиатом. На рисунке 1.2 представлен экран веб–сервиса «Антиплагиат». Рисунок 1.2 – Экран работы с веб–сервисом «Антиплагиат» На рисунке 1.2, относящемся к веб–сервису «Антиплагиат», заметно, что интерфейс выглядит минималистично и лишен лишних элементов, что позволяет пользователю сосредоточиться на основных задачах. Однако, отсутствие мобильной версии может быть значительным недостатком для пользователей, которые предпочитают использовать сервис с мобильных устройств или не имеют возможности использовать персональный компьютер по какой–либо причине. На рисунке 1.3 представлен экран для работы с текстом и документами веб–сервиса «Antiplagius». Рисунок 1.3 – Экран для работы с текстом и документами веб–сервиса «Antiplagius» Рисунок 1.3 отображает интерфейс «Antiplagius», который, несмотря на освобождение от избыточных элементов, выглядит достаточно устаревшим из–за маленького размера шрифта и излишней загруженности верхней части экрана. Кроме того, основной функционал антиплагиата кажется зажатым в узком пространстве. Рекламный баннер внизу экрана также привлекает слишком много внимания, что может отвлечь пользователя. Здесь система загрузки документа разработана таким образом, чтобы пользователь мог легко задать название файла, выбрать тип работ и загрузить файл для проверки. Что позволяет пользователю эффективно выполнять основные задачи без лишних помех и создает благоприятное впечатление о сервисе. Возможность перейти в личный кабинет в самом веб–сервисе является значимым преимуществом для пользователей. Среди сравниваемых веб–сервисов личный кабинет представлен в приложениях «Антиплагиат», «Antiplagius» и «1.». Однако, у каждого веб–сервиса есть свое собственное видение того, что должно включать в себя личное пространство пользователя. На экране веб–сервиса «Антиплагиат» представлены такие опции как удаление аккаунта, изменение пароля, адреса электронной почты и других учетных данных. В то время как экран веб–сервиса «.» выводит информацию о последнем входе в систему, дате регистрации, адресе электронной почты и других аспектах, связанных с профилем пользователя. Экран веб–сервиса «1.» обладает функционалом вывода и редактирования персональных данных, адреса электронной почты, а также социальных сетей и фотографий пользователя. Это дает пользователям возможность настройки и персонализации своего профиля в соответствии с их предпочтениями. В разрабатываемом веб–сервисе в личном кабинете представлена информация о ФИО и адресе электронной почты, но без возможности редактирования или удаления этих данных. Это может быть полезным в случае, если важно сохранить правильность исходного заполнения некоторых личных данных для обеспечения безопасности и устойчивости аккаунта. Каждая программа предлагает как платные, так и бесплатные функции. В бесплатном режиме могут быть ограничения на количество отправляемых файлов в день или в определенное время, на размер проверяемого файла, количество слов для проверки, и доступность получения полного отчета о выявленных заимствованиях и так далее. Чтобы избежать таких ограничений, необходимо иметь премиум–аккаунт. Также не все веб–сервисы имеют планшетную и мобильную адаптацию, из–за этого появляются неудобства при работе на маленьких экранах. Можно сделать вывод о том, что присутствует большое количество веб–сервисов для выполнения поиска заимствований текста, которые имеют большую аудиторию, то есть данная сфера очень востребована. Результат сравнения отображен в таблице 1.1. Таблица 1.1 – Результат сравнения веб–сервисов Критерий сравнения 1. . Антиплагиат Антиплагиат БГУИР 1 Адаптивность – + – + + + 2 Регистрация + + + + + – 3 Авторизация через сторонний ресурс – – – – – + 4 Личный кабинет + – + – + + 5 Бесплатный функционал антиплагиата – – + – + + В результате сравнения существующих программных не было наедено примера, который мог бы полностью удовлетворить все поставленные требования. Но в процессе сравнения удалось выделить дополнительные характеристики, которым должен соответствовать разрабатываемый веб–сервис. Таким образом для полного удовлетворения потребностей конечных пользователей необходимо, чтобы веб–сервис был интуитивно понятным и легко доступным для использования. Основной акцент следует сделать на точности анализа и быстроте обработки информации, чтобы конечные пользователи могли эффективно использовать функционал разрабатываемого веб–сервиса в повседневной деятельности. Так же необходимо реализовать удобную систему аутентификации на основе ресурсов, используемых в университете, для их синхронной работы. 1.3 Обоснование и описание выбора языка программирования, средств разработки, используемых технологий и сторонних библиотек В данном курсовом проекте использованы: язык гипертекстовой разметки текста HTML; каскадные таблицы стилей CSS; препроцессор SCSS; язык программирования JavaScript; интегрированная среда разработки VSCode; система контроля версий Git и онлайн–сервис GitHub; сборщик GULP для стилей, скриптов и изображений; для работы с дизайном Figma. HTML – это язык гипертекстовой разметки текста [7–9]. Это набор команд, следуя которым браузеры выводят на монитор различные документы и страницы сайтов. HTML является основным языком разметки для создания структуры веб–страниц. Он является стандартом для создания веб–страниц, поддерживаемым всеми современными браузерами. С помощью HTML можно создавать различные типы веб–страниц, начиная от простых статических страниц и заканчивая сложными интерактивными веб–приложениями. HTML используется для создания структуры веб–страницы, определяя содержимое и его семантику. Он состоит из набора элементов (тегов), каждый из которых определяет определенный тип содержимого. HTML используется для создания основной структуры веб–страниц, которая затем стилизуется с помощью CSS и делается интерактивной с использованием JavaScript. HTML, сокращение от HyperText Markup Language, представляет собой язык разметки текста, который используется для создания веб–страниц и их структуры [7–9]. Этот набор команд определяет, как браузеры должны отображать содержимое документов и страниц сайтов. Будучи основным языком разметки для веб–страниц, HTML является стандартом, поддерживаемым всеми современными браузерами. С его помощью можно создавать разнообразные типы веб–страниц, начиная от простых статических страниц и заканчивая сложными интерактивными веб–приложениями. Одна из ключевых функций HTML заключается в создании структуры веб–страницы и определении семантики её содержимого. HTML состоит из различных элементов, или тегов, каждый из которых определяет определенный тип содержимого на странице. CSS – это формальный язык, предназначенный для описания внешнего вида документа (веб–страницы), написанного с использованием языка разметки [10]. Он играет неотъемлемую роль в веб–разработке, предоставляя средства для стилизации и оформления веб–страниц. С его помощью можно задавать цвета, шрифты, стили, расположение отдельных блоков и другие аспекты представления внешнего вида веб–страниц. Одним из ключевых преимуществ CSS является возможность отделения логической структуры HTML–документа от его визуального оформления. Это способствует созданию более гибких, модульных и легко поддерживаемых веб–сайтов. CSS является стандартом в веб–разработке и поддерживается всеми современными браузерами, что обеспечивает широкую совместимость и надежность. Он предоставляет разработчикам широкий спектр инструментов для создания разнообразных дизайнерских решений, включая возможность задания цветов, шрифтов, размеров, отступов, анимации и многого другого. Основной целью разработки CSS является ограждение и отделение описания логической структуры веб–страницы от описания внешнего вида этой веб–страницы. Такое разделение может увеличить доступность документа, предоставить большую гибкость и возможность управления его представлением, а также уменьшить сложность и повторяемость в структурном содержимом. В данной работе в режиме разработки будет использоваться препроцессор SCSS для более гибкого и быстрого написания стилей, который в итоге соберется в один итоговый CSS файл с помощью сборщика. SCSS обладает расширенным и более читабельным синтаксисом по сравнению с обычным CSS, что позволяет разработчику писать код стилей быстрее и эффективнее, а также облегчает его поддержку в будущем. Большим преимуществом SCSS перед CSS является возможность использования операторов и функций, переменных и миксинов, а также вложенных стилей. Эти возможности значительно упрощают процесс написания и поддержки стилей веб–приложений, делая его более эффективным и удобным для разработчиков [11]. JavaScript (JS) является одним из наиболее распространенных и востребованных инструментов [12][13]. JavaScript обладает универсальностью, позволяя разрабатывать как клиентскую, так и серверную части веб–приложений. Благодаря кроссплатформенной поддержке JavaScript широко применяется на различных устройствах и операционных системах. Активное сообщество разработчиков постоянно развивает новые технологии и библиотеки для улучшения процесса разработки и повышения производительности. JavaScript поддерживает асинхронное программирование и обработку событий, что позволяет создавать отзывчивые и интерактивные веб–приложения. Большой выбор инструментов разработки, включая среды разработки, системы управления версиями и отладчики, делает процесс разработки более эффективным и удобным. В результате JavaScript остается привлекательным выбором для веб–разработки благодаря своей универсальности, широкой поддержке, активному сообществу и большому выбору инструментов. Так же существует множество мощных интегрированных сред разработки (IDE) для веб–сайтов с помощью, JS, HTML, CSS, таких как VSCode, IntelliJ IDEA, WebStorm и другие [14]. Они предоставляют разработчикам удобные инструменты для создания, отладки и тестирования приложений. При разработке программного средства для данной курсовой работы выбор пал на VSCode. VSCode – мощное интегрированное средство разработки (IDE), которое обладает обширным набором инструментов для улучшения процесса написания кода [15]. Одним из его преимуществ является обширный набор операций рефакторинга, таких как переименование переменных и извлечение методов, которые значительно упрощают изменение структуры кода и повышают его читаемость. Кроме того, VSCode предоставляет контекстно–зависимые подсказки и авто дополнение кода, что способствует увеличению производительности и снижению вероятности возникновения ошибок [16]. IDEA, с другой стороны, также предоставляет удобный интерфейс для создания новых проектов и импортирования существующих. Она интегрируется с системами контроля версий, такими как Git, Subversion и Mercurial, обеспечивая удобное отслеживание изменений в коде. Более того, IDEA поддерживает различные языки программирования, включая PHP, Kotlin, JavaScript, Python и многие другие, что делает её универсальным инструментом для разработки в рамках одной среды. Дополнительно, IDEA включает инструменты для работы с базами данных и SQL–запросами [17], что позволяет разработчикам управлять и редактировать таблицы, выполнять запросы и многое другое, не выходя из среды разработки. Кроме того, с помощью плагинов и расширений разработчики могут расширять функциональность IDE и добавлять дополнительные инструменты по мере необходимости. Выбор системы контроля версий Git и онлайн–сервиса GitHub обоснован исходя из ряда ключевых преимуществ и возможностей, которые они предоставляют для эффективного управления кодом и совместной работы над проектами [18]. Git является одной из самых популярных и широко используемых систем контроля версий в мире разработки программного обеспечения. Его распространенность обусловлена простотой в использовании, распределенной структурой, высокой скоростью работы и мощными функциями ветвления и слияния [19]. Git позволяет эффективно отслеживать изменения в коде, возвращаться к предыдущим версиям проекта и управлять конфликтами в изменениях. GitHub, с другой стороны, является онлайн–платформой для хостинга Git–репозиториев, которая предоставляет дополнительные инструменты для совместной работы над проектами [20]. Он обладает широким набором функций, таких как задачи и проблемы (issues), запросы на объединение (pull requests), вики, управление правами доступа и многое другое. GitHub обеспечивает удобный и простой способ совместной разработки, обратной связи и координации команды разработчиков. Использование Git и GitHub позволяет разработчикам эффективно организовывать рабочий процесс, отслеживать изменения в коде, реагировать на обратную связь со стороны других участников проекта, а также обеспечивать надежное хранение и резервное копирование кодовой базы. Благодаря их распространенности и популярности, Git и GitHub являются стандартом в индустрии разработки программного обеспечения и обеспечивают надежную основу для успешного ведения проектов. Выбор сборщика Gulp для обработки стилей, скриптов и изображений обусловлен несколькими факторами, которые способствуют эффективной и удобной разработке веб–приложений [21]. Прежде всего, Gulp является мощным инструментом автоматизации задач, который позволяет разработчикам оптимизировать процесс сборки и развертывания проекта. Он обладает простым и интуитивно понятным синтаксисом, что делает его легко доступным для новичков и удобным для опытных разработчиков. С помощью Gulp можно легко настроить и выполнять различные задачи, такие как компиляция препроцессоров CSS в обычный CSS, минификация и оптимизация стилей и скриптов, сжатие изображений, автоматическое обновление браузера при изменении файлов и многое другое. Это позволяет существенно ускорить процесс разработки, сделать код более оптимизированным и улучшить производительность веб–приложения. Gulp также обладает богатой экосистемой плагинов, которые позволяют расширять его функциональность и адаптировать под конкретные потребности проекта. Благодаря этому разработчики могут выбирать из большого количества плагинов те, которые соответствуют их требованиям и использовать их для решения конкретных задач. Использование сборщика Gulp для обработки стилей, скриптов и изображений обеспечивает более эффективную и удобную разработку веб–приложений, улучшает процесс сборки проекта и помогает создать более оптимизированный и производительный код. Figma – это мощный инструмент для дизайна, который позволяет создавать интерфейсы и макеты веб–приложений с учетом современных требований и тенденций [22]. Figma предоставляет возможность совместной работы над проектом, что позволяет всем участникам команды, включая дизайнеров и разработчиков, работать над одним и тем же макетом одновременно. Это снижает время на коммуникацию и ускоряет процесс разработки. Использование Figma для разработки предоставляет разработчикам мощный инструмент для создания качественного дизайна, улучшает командную работу, ускоряет процесс разработки и помогает создать более удобные и привлекательные веб–приложения. Наличие раннее описанных мощных и многофункциональных библиотек, взаимодействие с HTML, CSS, JS, а также крайне удобной среды разработки с множеством дополнительных функций, ускоряющих процесс разработки засчет своей производительности, предоставляет огромное количество возможностей для реализации массивного функционала программного средства. Также данное программное средство имеет огромный плюс в виде своей адаптивности под разные операционные системы, что позволит не испытывать проблем с его поддержкой в будущем. 1.4 Постановка задач на курсовую работу Целью курсового проекта является проектирование и разработка веб–сервиса для проверки оригинальности различных работ, включая курсовые, дипломные, научные статьи и другие материалы. Основное назначение системы – предоставление пользователям возможности проверки уникальности текстов и предотвращения. Программное обеспечение должно поддерживать русский язык, а графический интерфейс веб–сервиса должен включать такие страницы, как главная страница, авторизация, личный кабинет и пользовательский кабинет с соответствующей ролью. Разработка веб–сервиса предполагает выполнение нескольких этапов. На первом этапе проводится обзор предметной области, анализируются существующие программные средства для проверки оригинальности текстов, сравниваются их возможности с функционалом разрабатываемого приложения и обосновывается выбор используемых технологий, языков программирования и инструментов разработки. Второй этап включает проектирование архитектуры программного средства, создание базы данных, разработку алгоритмов функционирования приложения и проектирование пользовательского графического интерфейса. Основным результатом второго этапа является работоспособное программное средство, способное проверять тексты на оригинальность и предоставлять пользователю детальные отчеты о совпадениях. На третьем этапе составляется инструкция по развертыванию и эксплуатации веб–сервиса, описываются основные функции системы и рекомендации по использованию всех возможностей приложения. Завершающий этап работы посвящен оформлению пояснительной записки и графических материалов. В рамках данного этапа разрабатываются ER–диаграмма базы данных, UML–диаграммы состояний и вариантов использования, а также графический интерфейс программного средства, отражающий все элементы взаимодействия пользователя с системой. Таким образом, курсовой проект включает комплексную разработку веб–сервиса антиплагиата, начиная с анализа предметной области и выбора технологий, и заканчивая созданием полноценного интерфейса и технической документации, что обеспечивает полное соответствие требованиям к современным веб–приложениям для проверки оригинальности текстов. Разработка и реализация процесса контейнеризации программного средства с использованием технологии Docker. 2.1. Теоретические основы и анализ технологий контейнеризации. Контейнеризация представляет собой современный подход к развёртыванию программных систем, при котором приложение вместе со всеми зависимостями упаковывается в изолированный контейнер. Такой контейнер работает поверх общей операционной системы, используя её ядро, но при этом имеет собственное файловое пространство, сетевую конфигурацию и окружение. Это позволяет добиться одинакового поведения приложения на различных машинах, независимо от особенностей их конфигурации. Наиболее популярным инструментом контейнеризации является технология Docker, предоставляющая средства для сборки, распространения и запуска контейнеров. Она значительно упрощает процесс развёртывания приложений и позволяет избежать проблем, связанных с несовместимостью окружений. Контейнеры отличаются от виртуальных машин тем, что не требуют отдельной гостевой операционной системы, благодаря чему они запускаются быстрее и потребляют меньше ресурсов. Кроме того, контейнеризация способствует стандартизации процессов разработки и эксплуатации, упрощает масштабирование и интеграцию с системами непрерывной интеграции и доставки. Использование Docker в современных программных проектах стало практически стандартом. Он предоставляет возможность создавать образы, которые затем можно переносить и запускать на любых серверах или облачных платформах. Благодаря этому процесс развертывания становится предсказуемым, а разработчики и системные администраторы работают в идентичных условиях, что снижает риск ошибок и несовместимостей. 2.2. Проектирование и практическая реализация контейнеризации проекта 2.2.1. Анализ архитектуры и технологического стека исследуемого проекта Исследуемое программное средство представляет собой современное веб-приложение, спроектированное в рамках клиент-серверной архитектуры. Его ядро реализовано на языке программирования Python с активным использованием возможностей асинхронного фреймворка FastAPI. Основным интерфейсом взаимодействия выступает REST API, предоставляющий упорядоченный набор HTTP-эндпоинтов для выполнения операций CRUD (создание, чтение, обновление, удаление) с данными. Это позволяет различным клиентам — веб-интерфейсам, мобильным приложениям или сторонним сервисам — унифицированно интегрироваться с системой. Для долговременного, надежного и структурированного хранения информации используется реляционная система управления базами данных PostgreSQL. Детальный анализ архитектуры позволяет выделить три ключевых, логически обособленных слоя. Серверная часть (backend), построенная на FastAPI, отвечает за всю бизнес-логику приложения: валидацию входящих запросов, применение бизнес-правил, оркестрацию процессов и формирование ответов. Она выступает в роли посредника между внешним миром и данными. Слой работы с данными (data access layer) абстрагирует прямое взаимодействие с СУБД. Для этого применяются объектно-реляционные преобразователи (ORM) — библиотеки SQLAlchemy или SQLModel. Они позволяют оперировать данными как Python-объектами, повышая безопасность (защита от SQL-инъекций) и удобство разработки. Сама база данных PostgreSQL функционирует как независимый сервис хранения, обеспечивающий целостность, транзакционность и надежность данных. Для обеспечения высокой производительности и эффективной обработки множества одновременных подключений в качестве ASGI (Asynchronous Server Gateway Interface) сервера используется Uvicorn. Этот выбор обусловлен его способностью асинхронно обрабатывать запросы, что критически важно для поддержания отзывчивости API под нагрузкой. Весь технологический стек (FastAPI, Uvicorn, SQLAlchemy/SQLModel, PostgreSQL) образует синергетическую связку: FastAPI обеспечивает быстрое прототипирование и строгую типизацию, Uvicorn гарантирует высокую скорость обработки входящих запросов, а ORM в связке с PostgreSQL дают разработчикам мощный и гибкий инструмент для моделирования сложных структур данных. Выбор именно FastAPI в качестве основного фреймворка был продиктован его преимуществами: высокой скоростью выполнения, сравнимой с Node.js и Go, встроенной автоматической генерацией интерактивной документации (Swagger UI и ReDoc) на основе аннотаций типов Python, а также простотой валидации данных с помощью Pydantic. PostgreSQL был выбран в качестве СУБД не случайно: это зрелое, открытое решение, предлагающее продвинутые функции (оконные функции, поддержку JSONB, полнотекстовый поиск), отличную стабильность и превосходную экосистему драйверов для Python. Такая архитектура, где каждый компонент решает четко определенную задачу, является идеально приспособленной для контейнеризации (например, с использованием Docker). Сервер приложения, рабочие процессы и база данных могут быть развернуты в изолированных контейнерах, что упрощает развертывание, масштабирование и обеспечение консистентности среды на всех этапах разработки и эксплуатации. 2.2.2 Проектирование контейнерной инфраструктуры. Проектирование контейнерной инфраструктуры началось с определения основных сервисов, которые должны быть вынесены в отдельные контейнеры. В их число вошли приложение FastAPI и база данных PostgreSQL. Такое разделение позволяет управлять каждым компонентом независимо, что облегчает обновление, масштабирование и сопровождение системы. Между контейнерами организуется внутренняя сеть, обеспечивающая их взаимодействие без необходимости открывать внешние порты, что повышает безопасность решения. Особое внимание уделялось вопросам хранения данных. Для постоянного хранения информации базы данных был создан отдельный том, который сохраняет данные даже при перезапуске контейнера. Это позволило добиться устойчивости и сохранности информации в процессе эксплуатации. Переменные окружения, содержащие параметры подключения и конфигурации, вынесены в отдельный файл .env, исключённый из репозитория, чтобы предотвратить случайное раскрытие конфиденциальных данных. 2.2.3 Разработка Dockerfile. Ключевым элементом процесса контейнеризации является создание файла Dockerfile, в котором описывается процесс сборки контейнерного образа приложения. Для данного проекта был использован официальный базовый образ Python версии 3.11 в минимальной сборке slim. Это позволило значительно сократить размер итогового контейнера, сохранив при этом всю необходимую функциональность. В Dockerfile выполняется установка системных зависимостей и копирование в контейнер файлов проекта. На основе файла requirements.txt устанавливаются все необходимые Python–зависимости. После этого в контейнер добавляется исходный код приложения, а в качестве команды запуска указывается выполнение сервера Uvicorn, обслуживающего FastAPI–приложение. Таким образом, сборка образа полностью автоматизирована, а запуск контейнера инициирует работу приложения в изолированной среде, не зависящей от состояния хост–системы. Пример Dockerfile используемого в проекте: # Multi–stage build для минимизации размера FROM python:3.11–slim AS builder WORKDIR /build RUN apt–get update && apt–get install –y ––no–install–recommends \\ build–essential libpq–dev \\ && rm –rf /var/lib/apt/lists/* COPY requirements.txt /build/ # Установка PyTorch CPU версии сначала RUN pip install ––no–cache–dir ––upgrade pip RUN pip install ––no–cache–dir ––user torch==2.0.1+cpu torchvision==0.15.2+cpu ––index–url https://download.pytorch.org/whl/cpu # Установка остальных зависимостей, пропуская torch и torchvision RUN pip install ––no–cache–dir ––user –r requirements.txt # Чистка RUN find /root/.local –type d –name \"__pycache__\" –exec rm –rf {} + 2>/dev/null || true && \\ find /root/.local –type f –name \"*.pyc\" –delete FROM python:3.11–slim WORKDIR /app RUN apt–get update && apt–get install –y ––no–install–recommends \\ postgresql–client libpq5 netcat–openbsd \\ && rm –rf /var/lib/apt/lists/* # Копируем установленные пакеты COPY ––from=builder /root/.local /root/.local ENV PATH=/root/.local/bin:$PATH \\ PYTHONUNBUFFERED=1 \\ PYTHONDONTWRITEBYTECODE=1 COPY Folder/ /app/Folder/ COPY entrypoint.sh /usr/local/bin/entrypoint.sh RUN chmod +x /usr/local/bin/entrypoint.sh && \\ mkdir –p /app/Folder/media/pdf_files /app/Folder/media/txt_files /app/Folder/staticfiles EXPOSE 8000 ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"] CMD [\"gunicorn\", \"Folder.app.wsgi:application\", \"––bind\", \"0.0.0.0:8000\", \"––workers\", \"3\", \"––chdir\", \"/app/Folder\"] 2.2.4 Оркестрация контейнеров с помощью Docker Compose. Для управления несколькими контейнерами и их связями использовался инструмент Docker Compose. В едином конфигурационном файле docker–compose.yml были описаны два сервиса: приложение и база данных. Compose автоматически создаёт общую сеть для взаимодействия контейнеров и управляет их жизненным циклом. Контейнер приложения собирается на основе локального Dockerfile, а контейнер базы данных создаётся из официального образа PostgreSQL. При запуске система автоматически инициализирует базу данных, подключает том для хранения данных и устанавливает сетевые соединения между сервисами. Благодаря этому приложение может обращаться к базе данных по имени контейнера, что делает конфигурацию простой и устойчивой к изменениям. Для запуска всей инфраструктуры достаточно одной команды, после чего все компоненты системы автоматически собираются и запускаются в рабочем состоянии. Пример docker–compose.yml используемого в проекте services: db: image: ankane/pgvector container_name: postgres_db restart: always environment: POSTGRES_DB: ${POSTGRES_DB} POSTGRES_USER: ${POSTGRES_USER} POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} ports: – \"5432:5432\" volumes: – pgvector_data:/var/lib/postgresql/data healthcheck: test: [\"CMD–SHELL\", \"pg_isready –U ${POSTGRES_USER} –d ${POSTGRES_DB}\"] interval: 10s timeout: 5s retries: 5 redis: image: redis:7 container_name: redis restart: always ports: – \"6379:6379\" healthcheck: test: [\"CMD\", \"redis–cli\", \"ping\"] interval: 10s timeout: 5s retries: 5 web: build: . container_name: django_web command: gunicorn Folder.app.wsgi:application ––bind 0.0.0.0:8000 ––workers 3 ––chdir /app/Folder volumes: – .:/app – media_files:/app/Folder/media – static_files:/app/Folder/staticfiles – hf_cache:/root/.cache/huggingface ports: – \"8080:8000\" depends_on: db: condition: service_healthy redis: condition: service_healthy environment: PYTHONPATH: /app/Folder PYTHONUNBUFFERED: \"1\" SECRET_KEY: ${SECRET_KEY:–django–insecure–default–change–me} DEBUG: ${DEBUG:–False} ALLOW_ALL_HOSTS: ${ALLOW_ALL_HOSTS:–True} ALLOWED_HOSTS: ${ALLOWED_HOSTS:–localhost,127.0.0.1} DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB} CELERY_BROKER_URL: ${CELERY_BROKER_URL:–redis://redis:6379/0} CELERY_RESULT_BACKEND: ${CELERY_RESULT_BACKEND:–redis://redis:6379/0} 2.3 Тестирование и оценка эффективности внедренного решения 2.3.1 Методология тестирования решения После завершения контейнеризации была проведена серия тестов, направленных на проверку корректности функционирования приложения в контейнерной среде. Проверялся процесс сборки образов, запуск контейнеров, доступность API и корректность работы взаимодействия с базой данных. Все основные маршруты приложения отрабатывали без ошибок, а данные успешно сохранялись и извлекались из базы. Отдельное внимание было уделено измерению производительности системы. Результаты показали, что контейнеризация не оказала отрицательного влияния на скорость работы приложения. Напротив, запуск и развертывание среды стали происходить значительно быстрее. Если ранее на установку и настройку зависимостей уходило около тридцати минут, то после внедрения Docker этот процесс сократился до трёх минут. 2.3.2 Сравнительный анализ показателей до и после внедрения контейнеризации Проведенный сравнительный анализ эффективности работы программного средства до и после внедрения контейнеризации наглядно демонстрирует качественное улучшение ключевых операционных и технологических показателей. Основным результатом стало кардинальное изменение принципов управления средой исполнения. Использование Docker позволило добиться полной воспроизводимости окружения как на этапе разработки, так и в эксплуатации. Если ранее настройка каждого нового стенда или сервера требовала ручной установки и конфигурации всех зависимостей (определенных версий Python, системных библиотек, серверов и самой СУБД), что занимало значительное время и часто приводило к трудновоспроизводимым ошибкам из-за расхождений в средах, то после контейнеризации приложение было упаковано в стандартизированный образ со всеми необходимыми зависимостями. Это сделало его абсолютно независимым от специфики базовой операционной системы и глобально установленных версий программного обеспечения. Теперь любой этап — от локального запуска для отладки до развертывания на тестовом или промышленном сервере — гарантированно выполняется в идентичных условиях. Значительно упростились процессы масштабирования и управления нагрузкой. В традиционной модели вертикальное или горизонтальное масштабирование требовало сложного клонирования и настройки серверов. После внедрения контейнеризации запуск дополнительных экземпляров приложения сводится к простой команде запуска нового контейнера из готового образа, без необходимости вносить какие-либо изменения в исходный код или конфигурацию инфраструктуры. Это открывает возможности для быстрой и гибкой балансировки нагрузки в реальном времени. Наиболее существенно повысились показатели стабильности и предсказуемости работы системы. Контейнерная изоляция устранила конфликты между службами и фоновыми процессами, а четкое определение зависимостей исключило ситуации, когда обновление одного системного пакета неожиданно ломало работу приложения. Каждый контейнер работает в собственной изолированной среде, что минимизирует влияние внешних факторов. Как следствие, количество инцидентов, связанных с проблемами совместимости или конфигурации, сократилось до минимума. Наконец, была решена задача высокой портируемости и упрощения процедур развертывания. Перенос приложения с одной физической или виртуальной машины на другую, а также между облачными провайдерами, перестал быть сложной инженерной задачей. Теперь он выполняется простым переносом Docker-образов и файлов конфигурации оркестратора. Это не только сократило время на развертывание с часов до минут, но и позволило реализовать эффективные стратегии непрерывной интеграции и поставки (CI/CD), где каждый билд приложения автоматически упаковывается в контейнер и может быть немедленно протестирован и выкачен на любой сервер. Таким образом, внедрение контейнеризации привело к системным улучшениям по всем ключевым направлениям: управляемости, надежности, масштабируемости и скорости разработки. 2.3.3 Анализ аспектов безопасности. Безопасность контейнеризированной системы является комплексной задачей, затрагивающей все этапы жизненного цикла — от сборки образов до их эксплуатации. В рамках проекта был реализован многоуровневый подход, интегрирующий меры безопасности непосредственно в процесс проектирования и реализации инфраструктуры. Фундаментом безопасности является контроль происхождения и целостности базовых образов. Для сборки всех компонентов системы использовались исключительно официальные и проверенные образы из репозитория Docker Hub, такие как python:3.12-slim для приложения и postgres:16-alpine для базы данных. Выбор минималистичных образов (slim, alpine) позволил сократить поверхность атаки, исключив из контейнеров ненужные системные пакеты и утилиты, которые могли бы содержать уязвимости. Дополнительно, практика фиксации конкретных версий образов по тегам, а не использование плавающих тегов вроде latest, предотвращает непреднамеренное обновление до нестабильных или несовместимых версий. На уровне исполнения была минимизирована привилегированность процессов. Вопреки распространённой практике по умолчанию, приложение не запускается от имени суперпользователя (root) внутри контейнера. Вместо этого, в Dockerfile явно создан и назначен для работы непривилегированный системный пользователь. Это критически важная мера, которая, в случае компрометации приложения, ограничивает возможности злоумышленника и предотвращает эскалацию привилегий на уровень хостовой операционной системы. Управление конфиденциальными данными (секретами) было вынесено за пределы образов и файлов конфигурации. Пароли для доступа к базе данных, API-ключи и другие чувствительные параметры не хардкодятся и не передаются в открытом виде. Они хранятся во внешнем файле .env (исключённом из систем контроля версий) и передаются в контейнеры через механизм переменных окружения, который в промышленной среде легко заменяется на специализированные системы управления секретами, такие как HashiCorp Vault или облачные аналоги. Это предотвращает утечку данных при публикации кода или образов. Сетевая изоляция была тщательно спроектирована. База данных PostgreSQL работает в изолированной внутренней Docker-сети, доступной только для контейнера приложения. Прямой внешний доступ к портам СУБД с хоста или извне полностью запрещён, что сводит на нет риски прямых атак на сервер баз данных. Весь обмен данными между фронтендом и бэкендом происходит через строго определённые API-интерфейсы, проходящие валидацию. Кроме того, сама сеть контейнеров изолирована от внешней среды, что является дополнительным барьером. Процесс обеспечения безопасности носит не разовый, а непрерывный характер. Регулярное обновление базовых образов и зависимостей интегрировано в конвейер CI/CD для получения своевременных патчей безопасности. Для автоматизации этого процесса используются инструменты статического анализа уязвимостей, такие как trivy или docker scan, которые интегрируются в процесс сборки и проверяют образы на наличие известных CVE (Common Vulnerabilities and Exposures) в используемых пакетах. Это позволяет выявлять и устранять уязвимости на этапе разработки, а не в уже работающей системе. 2.4 Выводы по главе. В результате проведённой работы была успешно реализована контейнеризация программного средства на Python с использованием фреймворка FastAPI и базы данных PostgreSQL. Применение технологии Docker позволило стандартизировать процесс развертывания, повысить надёжность и упростить администрирование системы. Полученная контейнерная инфраструктура обеспечивает гибкость, устойчивость и безопасность приложения, а также делает процесс разработки и внедрения более управляемым и предсказуемым. В целом, внедрение контейнеризации стало важным этапом развития проекта, позволившим существенно повысить эффективность и удобство его эксплуатации. Реализация централизованного управления данными аутентификации посредством LDAP. 3.1. Настройка Celery На этапе интеграции было принято решение использовать Celery в связке с брокером сообщений Redis, работающим в контейнере Docker. Redis выступает в роли посредника между приложением и Celery, обеспечивая хранение и маршрутизацию сообщений. Такой выбор обусловлен его высокой скоростью работы, простотой конфигурации и полной поддержкой в Docker–среде. В конфигурационном файле docker–compose.yml для Redis был добавлен отдельный сервис: redis: image: redis:7 container_name: redis restart: always ports: – \"6379:6379\" Благодаря этому Redis автоматически запускается вместе с остальными сервисами проекта и становится доступным по внутреннему адресу redis:6379. Приложение FastAPI и Celery получают доступ к брокеру и хранилищу результатов через переменные окружения CELERY_BROKER_URL и CELERY_RESULT_BACKEND, указывающие на redis://redis:6379/0. Эти параметры задаются в файле .env, что упрощает конфигурацию и позволяет гибко изменять настройки при необходимости. Настройка Celery в проекте выполнена в отдельном модуле Python. В нём создаётся объект Celery и задаются параметры подключения к Redis. Также определяются общие настройки, такие как сериализация данных, формат хранения результатов и таймауты выполнения задач. Все эти параметры обеспечивают надёжность взаимодействия между компонентами системы и предотвращают потерю данных при возможных сбоях сети или перезапуске контейнеров. Для запуска обработчиков задач (worker’ов) в контейнерной среде используется отдельный сервис celery в составе docker–compose.yml. Этот контейнер запускается из того же образа, что и приложение FastAPI, и автоматически подключается к Redis для получения задач из очереди. Благодаря этому при увеличении нагрузки можно легко масштабировать обработку, запуская дополнительные экземпляры пользователей. 2.2. Настройка сервера LDAP На этапе настройки серверной части была выбрана реализация OpenLDAP, являющаяся свободным и надёжным решением для организации каталога. Сервер LDAP был развёрнут в контейнере, что позволило упростить процесс установки и обеспечить его изоляцию от основной системы. Для хранения данных каталога использовалась отдельная директория, монтируемая как постоянный том, что гарантировало сохранность информации при перезапуске контейнера. После развёртывания сервера была произведена базовая настройка структуры каталога. В корневом домене каталога были созданы организационные единицы, отражающие внутреннюю структуру университета: факультеты, кафедры и группы пользователей. Для каждой организационной единицы задавались соответствующие атрибуты и уровни доступа. Таким образом, в каталоге формировалась иерархия, отражающая реальную структуру учебного учреждения. Для аутентификации пользователей использовались учётные записи студентов, синхронизированные с базой данных университета. Каждая запись включала логин, хэш пароля, а также служебные данные, необходимые для идентификации личности. Доступ к серверу LDAP осуществлялся по защищённому протоколу LDAPS, что обеспечивало шифрование передаваемых данных и предотвращало их перехват. В процессе настройки была также реализована система ролей, определяющая права доступа пользователей. Так, студенты имели возможность аутентифицироваться в системе, преподаватели получали расширенные права на доступ к учебным материалам, а администраторы могли управлять записями каталога. Для упрощения администрирования использовался веб–интерфейс phpLDAPadmin, предоставляющий наглядный доступ к структуре каталога и записям пользователей. 2.3. Реализация аутентификации пользователей После настройки LDAP–сервера был реализован механизм интеграции его с системой авторизации приложения. Приложение, разработанное на Python с использованием фреймворка FastAPI, было дополнено модулем, обеспечивающим аутентификацию пользователей через LDAP. В процессе входа пользователь вводит свои учётные данные – логин и пароль, которые затем проверяются посредством обращения к LDAP–каталогу. Механизм аутентификации реализован таким образом, что приложение не хранит пароли пользователей, а лишь выполняет проверку их подлинности через LDAP. Это повышает безопасность системы, исключая возможность утечки данных при компрометации приложения. После успешной аутентификации сервер возвращает информацию о пользователе, включая его имя, принадлежность к факультету и роль в системе. Эти данные используются для определения уровня доступа и предоставления соответствующих функций внутри приложения. Благодаря такой интеграции студент может использовать свои стандартные университетские учётные данные для входа не только в основную информационную систему, но и во все связанные сервисы, включая внутренние порталы, системы дистанционного обучения и файловые хранилища. Это обеспечивает единообразие политики безопасности и снижает нагрузку на службу технической поддержки, так как отпадает необходимость в создании и сопровождении отдельных учётных записей для каждого приложения. Для тестирования корректности работы системы проводились проверки на авторизацию пользователей из различных подразделений университета. Результаты показали стабильную работу механизма аутентификации и отсутствие ошибок при обращении к LDAP–серверу. Также была протестирована работа в случае некорректных данных и при попытке подключения без авторизации. В обоих случаях система корректно реагировала, отклоняя запросы и фиксируя попытки доступа в журнале безопасности. Реализованная интеграция позволила объединить все процессы аутентификации в единую централизованную систему, основанную на LDAP. Это решение стало основой для формирования общей политики безопасности и упрощения управления доступом внутри университета. 3.5. Выводы по главе В результате внедрения Celery и Redis в инфраструктуру проекта была реализована централизованная система управления асинхронными задачами. Данное решение позволило разгрузить основной поток приложения FastAPI, обеспечив эффективное выполнение длительных операций в фоне без снижения производительности интерфейса. Использование Redis в качестве брокера сообщений и хранилища результатов обеспечило высокую скорость обработки и устойчивость системы, а интеграция Flower упростила процесс мониторинга и диагностики задач. Развёртывание всех компонентов в Docker–контейнерах позволило добиться высокой степени изоляции, воспроизводимости и удобства при масштабировании. Таким образом, реализация Celery стала важным этапом развития архитектуры проекта, обеспечив баланс между производительностью, надёжностью и гибкостью системы. Централизованное управление задачами повысило устойчивость сервиса и позволило использовать ресурсы вычислительной среды более рационально, что особенно важно при росте нагрузки и расширении функционала приложения. Проектирование, разработка и тестирование программного средства 4.1 Проектирование и реализация способа хранения данных программного средства База данных – это совокупность структурированных взаимосвязанных данных, относящихся к определённой предметной области и организованных для решения определенных задач разными пользователями. База данных предназначена для хранения, изменения и обработки информации. В ходе разработки используется PostgreSQL – мощная реляционная база данных с открытым исходным кодом, которая широко применяется для веб–сервисов и мобильных приложений [24]. PostgreSQL предоставляет разработчикам надежное хранилище данных с расширенными возможностями работы с данными и поддержкой многих языков программирования для разработки приложений. PostgreSQL является популярным выбором среди разработчиков благодаря ряду ключевых преимуществ. Этот инструмент обеспечивает высокую надёжность и целостность данных за счёт продуманной транзакционной архитектуры. Система отличается гибкостью и хорошей масштабируемостью, позволяя эффективно работать с растущими объёмами информации в веб-приложениях. Расширяемость PostgreSQL даёт возможность настраивать и дополнять его функционал под конкретные задачи с помощью разнообразных расширений, что превращает его в гибкую платформу для реализации сложной бизнес-логики. База данных строго соответствует стандартам ANSI SQL и поддерживает современные форматы, такие как геоданные и JSON, что упрощает интеграцию с различными стеками технологий. Важным аспектом является встроенная безопасность, включая механизмы шифрования, детализированное управление доступом и защиту на уровне строк. Кроме того, PostgreSQL поддерживается активным сообществом разработчиков, что гарантирует его постоянное развитие, своевременное обновление и качественную поддержку, снижая долгосрочные риски использования. Эта комбинация надежности, гибкости и мощной экосистемы делает его надежным фундаментом для проектов любого масштаба. Для сравнения, в Firebase подобные данные, например о пользователе, могли бы храниться в коллекции «User» с полями для уникального идентификатора, имени, даты рождения, электронной почты, пароля и других атрибутов. Такой подход отличается большей свободой в структурировании, но возлагает проверку целостности данных на приложение, в то время как PostgreSQL обеспечивает её на уровне самой базы, что минимизирует возможность ошибок и повышает общую стабильность системы. Таблица 4.1 – Таблица «User» № Название Тип данных Описание 1 id BigAutoField Первичный ключ (автоинкремент) 2 username CharField(150) Уникальное имя пользователя 3 first_name CharField(150) Имя 4 last_name CharField(150) Фамилия 5 sur_name CharField(100) Отчество 6 email EmailField(254) Email адрес 7 password CharField(128) Хэшированный пароль 8 image ImageField Аватар пользователя 9 is_staff BooleanField Доступ к админ–панели 10 is_active BooleanField Активность аккаунта 11 is_superuser BooleanField Права суперпользователя 12 date_joined DateTimeField Дата регистрации 13 last_login DateTimeField Дата последнего входа 14 groups ManyToManyField Связь с группами пользователей 15 user_permissions ManyToManyField Связь с правами пользователей Таблица «User» является центральным элементом системы управления пользователями в разрабатываемом приложении для детекции плагиата. Данная таблица обеспечивает хранение всей необходимой информации о пользователях системы, начиная от базовых персональных данных и заканчивая настройками доступа и безопасности. Структура таблицы построена на основе стандартной модели пользователя Django (AbstractUser), что обеспечивает совместимость с встроенными механизмами аутентификации и авторизации. Это позволяет использовать как стандартные методы входа в систему, так и интеграцию с внешними системами аутентификации, такими как LDAP, что особенно важно для корпоративной среды. Особое внимание уделено безопасности хранения данных: пароли пользователей хранятся в хэшированном виде с использованием встроенных механизмов Django, что исключает возможность их восстановления в случае компрометации базы данных. Система прав доступа реализована через гибкую модель групп и разрешений, позволяющую администраторам тонко настраивать доступ к различным функциям приложения. Для обеспечения удобства использования система поддерживает загрузку аватаров пользователей, что повышает узнаваемость интерфейса и улучшает пользовательский опыт. Поля для хранения полного имени (имя, фамилия, отчество) позволяют корректно отображать информацию о пользователях в различных частях приложения, включая отчеты и административные панели. Временные метки (дата регистрации и последнего входа) обеспечивают возможность мониторинга активности пользователей и проведения аналитики использования системы. Это особенно важно для образовательных учреждений, где необходимо отслеживать активность студентов и преподавателей при работе с системой детекции плагиата.Интеграция данной таблицы с другими компонентами системы, такими как таблица документов, обеспечивает полную трассируемость действий пользователей и возможность ведения детального журнала операций, что критически важно для системы контроля академической честности. PostgreSQL представляет собой надежные инструменты для разработчиков в области веб–разработки, обеспечивая высокую производительность, надежность и защиту данных. Таблица Status определяет возможные состояния документов в системе, например: «В очереди», «Проверяется», «Готово». Для каждого статуса задаётся не только название, но и CSS–класс для визуального отображения в интерфейсе. Это позволяет обеспечить единообразную цветовую маркировку статусов.Таблица 4.2 – Таблица «Status» № Название Тип данных Описание 1 id AutoField Первичный ключ (автоинкремент) 2 name CharField(100) Название статуса 3 html_class CharField(100) HTML класс для отображения статуса Данная таблица служит справочником статусов документов, например: «В очереди», «Проверяется», «Проверено». Поле html_class применимо для интерфейса: оно позволяет выводить статус в определённом цвете или стиле. Таблица используется в цифровом документообороте и при формировании отчётов о проверке. Таблица Type служит для хранения типов загружаемых работ: «Реферат», «Курсовая работа», «Диплом», «Отчёт» и т.д. Использование отдельной таблицы делает систему расширяемой: добавление новых типов работ не требует изменения логики приложения. Таблица 4.3 – Таблица «Type» № Название Тип данных Описание 1 id AutoField Первичный ключ (автоинкремент) 2 name CharField(100) Название типа работы Таблица содержит перечень категорий документов, таких как «Курсовая работа», «Реферат», «Диплом». Она позволяет организовать данные структуры и облегчает категоризацию отчетов и статистики. Это также способствует гибкому расширению функционала: можно добавлять новые типы работ без модификации всей системы. Таблица Document является базовой для хранения всех загруженных документов и результатов их анализа.Таблица 4.4 – Таблица «Document» № Название Тип данных Описание 1 id BigAutoField Первичный ключ (автоинкремент) 2 user ForeignKey(User) Ссылка на пользователя 3 name CharField(100) Название документа 4 result DecimalField(5,2) Процент оригинальности 5 status ForeignKey(Status) Статус проверки 6 type ForeignKey(Type) Тип работы 7 time_created DateTimeField Дата и время загрузки 8 data FileField Загруженный документ 9 txt_file FileField Текстовая версия документа 10 vector TextField Векторное представление текста (JSON) 11 last_status_changed_by ForeignKey(User) Кто изменил статус последним Таблица «Document» включает все основные характеристики документа – от исходного файла до результатов анализа. Особую важность имеет поле vector, содержащее текст в векторном виде, который используется для семантических сравнений. Таблица обеспечивает хранение полного жизненного цикла документа: загрузка → анализ → присвоение статуса → формирование отчёта. Также фиксируется пользователь, изменивший статус документа, что обеспечивает прозрачность и аудит действий. Таблица SimilarDocument отвечает за хранение результатов вычисления схожести между документами. Таблица 4.5 – Таблица «User» № Название Тип данных Описание 1 id BigAutoField Первичный ключ (автоинкремент) 2 document ForeignKey(Document) Исходный документ 3 similar_document ForeignKey(Document) Похожий документ 4 similarity_score FloatField Уровень схожести (0–1) Эта таблица фиксирует пары документов, которые показали значительную семантическую близость. Поле similarity_score отражает степень совпадения, где 1 – полное совпадение, 0 – отсутствие схожести. Таблица используется при формировании отчётов, а также при выявлении подозрительных совпадений для дальнейшего анализа. Представленная структура базы данных обеспечивает надёжное хранение всех данных, необходимых для работы системы. Логичное разбиение сущностей на таблицы и использование внешних ключей создаёт удобную и масштабируемую архитектуру. Отдельные таблицы для статусов, типов и похожих документов позволяют гибко расширять функционал без изменения основной логики. Данная структура соответствует требованиям системы анализа текстов и обеспечивает корректную работу всех модулей – от загрузки документов до анализа семантической схожести. 4.2 Проектирование и разработка графического интерфейса Проектирование и разработка графического интерфейса – это один из самых важных этапов создания веб–сервиса, так как именно интерфейс является основным способом взаимодействия пользователя с приложением. Перед началом проектирования необходимо определить целевую аудиторию и ее потребности. Это поможет создать удобный и понятный интерфейс, который будет максимально соответствовать требованиям пользователей. Для построения грамотного интерфейса нужно соблюдать принципы UI/UX [25]. UI (User Interface) и UX (User Experience) – это процесс создания удобного и привлекательного интерфейса для пользователей. Этот процесс включает в себя разработку дизайна, который будет удобен для использования и будет привлекать пользователей к продукту. UI (User Interface) – это интерфейс, который пользователи видят и используют для взаимодействия с продуктом. Он включает в себя все элементы, такие как кнопки, меню, тексты и изображения, которые помогают пользователям выполнять задачи в приложении. UX (User Experience) – это опыт, который пользователь получает при использовании программного продукта. Он включает в себя такие аспекты, как удобство использования, скорость работы, интуитивность интерфейса и т. д. Есть несколько основных правил, которым должно соответствовать приложение: Интуитивность и простота: приложение должно быть простым в использовании, чтобы пользователь мог быстро разобраться в нем и понять, как выполнять нужные действия. Визуальная согласованность: все элементы приложения должны быть оформлены в едином стиле, чтобы пользователь легко мог ориентироваться в приложении. Удобство навигации: приложение должно иметь понятную и логичную систему навигации, чтобы пользователь мог найти нужную информацию. Скорость работы: приложение должно быстро загружаться и работать без задержек, чтобы пользователь не терял терпение и не переключался на другое приложение. Таким образом, необходимо создавать простой и интуитивно понятный интерфейс, который будет легко осваиваться пользователями. Отсутствие лишних элементов и явных инструкций также может улучшить юзабилити интерфейса. Пользовательский интерфейс веб–сервиса «Антиплагиат» состоит из следующих экранов: страница авторизации; страница кабинета; страница с результатами; страница личного кабинета; страница с ролями пользователей; модальное окно «Загрузка документа»; модальное окно «Отправить документ ан защиту»; модальное окно «Оценить документ». Рассмотрим графический дизайн для мобильных устройств. В первую очередь, при проектировании пользовательского интерфейса нужно создать грамотный экран «Авторизации». Дизайн экрана «Авторизации» представлен на рисунке 4.1. Рисунок 4.1 – Дизайн страницы «Авторизации» Страница «Авторизации» является лицом приложения, это тот экран, с которым пользователь будет взаимодействовать в первую очередь. Поэтому он должен быть интуитивно понятен. Данный экран имеет минимальное количество элементов дизайна. Имеет поля логина и пароля, а также для пароля кнопка показать/скрыть пароль, кнопку «Войти», а также информационный блок со ссылками на сторонние ресурсы для помощи пользователю в случаи если он находиться первый раз на нашем сайте или если его логин/пароль не работает. После успешной авторизации автоматически запускается экран «Кабинета». На странице «Кабинета» размещены некоторые документы пользователя, если они имеются. Также страница «Кабинета» содержит поиск по названию документа, пагинацию и кнопку «Проверить документ». Для каждого документа есть кнопка в виде иконки «Подробнее», нажимая на нее появляется панель по работе с документом с двумя кнопками. Дизайн страницы «Кабинет» со сразу открытым выпадающим списком для одного из документов представлен на рисунке 4.2. Рисунок 4.2 – Дизайн страницы «Кабинет» со сразу открытым выпадающим списком для документа Нажав на кнопку «Отправить на проверку», в выпадающем меню документа, открывается модальное окно «Отправить документ на защиту» с подробной информацией о документе и кнопкой «Отправить». Дизайн модального окна «Отправить документ на защиту» показан на рисунке 4.3. Рисунок 4.3 – Дизайн модального окна «Отправить документ на защиту» Кнопка «Проверить документ», на странице «Кабинета», нужна для того, чтобы загрузить новый документ. Нажимая на кнопку появляется модальное окно с полем ввода «Название работы», выпадающим списком «Тип работы» и полем для загрузки документа в формате *pdf, а также кнопка «Проверить» для отправки данных. После того как документ загрузили в поле кликнув на кнопку «Загрузить документ» или перетащив в данное поле, отображается документ с возможностью его удаления. Для того чтобы закрыть модальное окно, имеется кнопка крестика или клик вне области модального окна. Пример дизайна модального окна «Загрузка документа» представлен на рисунке 4.4. Рисунок 4.4 – Дизайн модального окна «Загрузка документа» Когда пользователь авторизован на каждой странице у него есть в хедере иконка нажимая на которую появляется выпадающее меню с возможностью перехода по страницам и кнопкой «Выхода» для выхода из системы. Дизайн выпадающего меню показан на рисунке 4.5. Рисунок 4.5 – Дизайн выпадающего списка меню Нажимая на кнопку «Личный кабинет» в выпадающем меню, происходит переход на экран «Личный кабинет». Дизайн страницы «Личный кабинет» представлен на рисунке 4.6. Рисунок 4.6 – Дизайн страницы «Личный кабинет» Страницы «Роль пользователя» и «Результаты» не доступны для администраторов. И данные пункты меню для обычных пользователей не будут отображаться в выпадающем меню. Нажимая на кнопку «Роль пользователя» в выпадающем меню, происходит переход на экран «Роль пользователя». Также экран «Роль пользователя» имеет поиск по ФИО, и пагинацию внизу страницы. Дизайн страницы «Роль пользователя» представлен на рисунке 4.7. Рисунок 4.7 – Дизайн страницы «Роль пользователя» Нажимая на кнопку «Результаты» в выпадающем меню осуществляется переход на страницу «Результаты». На данном экране отображается поиск по ФИО, пагинация и блоки с результатами. Дизайн страницы «Результаты» со сразу с открытым выпадающим списком для данного результата представлен на рисунке 4.8. Рисунок 4.8 – Дизайн страницы «Результаты» со сразу выпадающим списком для результата Нажимая на кнопку «Оценить», открывается модальное окно «Оценить документ», с подробной информацией о результате и двумя кнопками «Отправить на доработку» и «Зачтен». Дизайн модального окна «Оценить документ» представлен на рисунке 4.9. Рисунок 4.9 – Дизайн модального окна «Оценить документ» Таким образом, проектирование и разработка графического интерфейса приложения – это сложный и ответственный процесс, который требует профессионального подхода и внимания к деталям. Однако, правильно спроектированный интерфейс поможет сделать веб–сервис более удобным и привлекательным для пользователей, что положительно скажется на его популярности на рынке и может стать ключевым фактором успеха веб–сервиса. В рамках данного раздела была произведена разработка веб–сервиса «Антиплагиат». Для демонстрации возможностей веб–сервиса разработан графический интерфейс 4.3 Тестирование программного средства Тестирование программного обеспечения имеет ключевое значение в процессе разработки, внедрения и сопровождения программного продукта. Его основная цель – обнаружение ошибок, дефектов и недостатков в программе, а также проверка соответствия программного продукта требованиям и ожиданиям пользователей [26]. По степени автоматизации тестирование разделяется на автоматизированное и ручное. Автоматизированное тестирование программного обеспечения основано на написании кода. Методика данного тестирования позволяет описать ожидаемый сценарий, сравнить его с реальным поведением и указать расхождения. Такое тестирование позволяет получить быстрые и точные результаты. Однако важно понимать, что инструменты автоматизированного тестирования могут оказаться затратными. Поэтому автоматизация наиболее применима в сложных приложениях с большой функциональной частью. Значительным минусом является то, что с помощью автоматизированного тестирования нельзя оценить цветовые решения программного средства. Это не является первостепенным, но может повлиять на качество программного средства. Ручное тестирование – более долгий и трудоемкий процесс. Но он позволяет получить первый пользовательский опыт и отзыв реального человека. Такое тестирование также позволяет протестировать дизайн приложения. Внедрение ручного тестирование всегда менее затратно, чем автоматизированного. Для небольших проектов более рационально использовать именно ручное тестирование. В данном дипломном проекте используется ручное тестирование. Результаты тестирования представлены в таблице 3. Таблица 4.6 – Тестирование программного продукта Сценарий Выполняемое действие Ожидаемый результат 1 Авторизация пользователя Перейти на сайт Отображается страница с формой входа Заполнить поля Логин и Пароль Данные отображаются в полях ввода Нажать кнопку «Войти» Происходит переход в личный кабинет Продолжение таблицы 4.6 Сценарий Выполняемое действие Ожидаемый результат 2 Просмотр «Кабинета» Нажать на значок раскрывающегося меню в верхней части страницы Меню открывается Выбрать пункт «Кабинет» Происходит переход на страницу «Кабинет» 3 Загрузка нового документа Нажать кнопку «Проверить документ» Появляется окно для загрузки файла «Загрузка документа». Ввести необходимые данные, выбрать файл и подтвердить действие кнопкой «Проверить» Документ загружается и появляется в списке в «Кабинете» 4 Отправить документ на проверку Нажать на значок меню (троеточие) рядом с нужным документом Появляется контекстное меню для этого файла Выбрать «Отправить на проверку» Открывается диалоговое окно «Отправить документ на защиту» Нажать кнопку «Отправить» Документ направляется на проверку 5 Скачать результаты Нажать на значок меню (троеточие) рядом с документом Появляется контекстное меню для этого файлаВыбрать «Результаты» Запускается загрузка отчета по документу в формате PD 6 Просмотр «Личного кабинета» Нажать на значок раскрывающегося меню в верхней части страницы Меню открывается Выбрать пункт «Личный кабинет» Происходит переход на страницу «Личный кабинет» Продолжение таблицы 4.6 Сценарий Выполняемое действие Ожидаемый результат 7 Доступ к разделу «Роли пользователей» (администратор) Кликнуть по значку выпадающего меню в шапке Открывается меню Выбрать пункт «Роль пользователя» Переход на страницу управления ролями пользователей 8 Доступ к разделу «Результаты» (администратор) Кликнуть по значку выпадающего меню в шапке Открывается меню Выбрать пункт «Результаты». Переход на страницу с обзором результатов 9 Выгрузка отчета (функционал администратора) Нажать на значок дополнительных действий (троеточие) рядом с записью документа Открывается контекстное меню для этого документа Выбрать опцию «Результаты» Запускается загрузка файла с результатами анализа в формате PDF 10 Рецензирование документа Нажать на значок дополнительных действий (троеточие) рядом с записью документа Открывается контекстное меню для этого документа Выбрать пункт «Оценить» Открывается диалоговое окно для оценки документа Нажать кнопку «Отправить на доработку» Документ помечается как требующий доработки и отправляется обратно пользователю Нажать кнопку «Зачтен» Документ получает статус «Зачтен» Продолжение таблицы 4.6 Сценарий Выполняемое действие Ожидаемый результат 11 Поиск по документу или автору Ввести название документа или ФИО пользователя в поле поиска На экране появляется информация, соответствующая поисковому запросу 12 Завершение сеанса работы в сервисе Нажать на значок выпадающего меню в верхней части страницы Открывается меню пользователя Выбрать кнопку «Выйти» Происходит выход из системы с последующим переходом на страницу авторизации 13 Быстрая прокрутка к началу страницы Нажать на кнопку прокрутки в правом нижнем углу экрана Страница автоматически прокручивается к самому верху 14 Навигация по страницам Нажать на кнопку перехода вперед (вправо) Отображаются следующие 10 записей из списка Нажать на кнопку перехода назад (влево) Отображаются предыдущие 10 записе В ходе тестирования ошибок обнаружено не было, тесты пройдены успешно. Разработанное программное средство демонстрирует корректное функционирование и соответствует требованиям, которые предъявлялись при проектировании и разработке, что говорит о высоком качестве программного продукта. 4.4 Вывод по главе Спроектирована и реализована база данных на PostgreSQL, обладающая необходимыми характеристиками надёжности и масштабируемости. Разработанная схема данных, включающая таблицы пользователей, документов, статусов и результатов сравнения, обеспечивает целостное функционирование всех модулей системы.Проведённое ручное тестирование подтвердило корректность работы всех основных функций системы. Протестированные сценарии использования показали, что программный продукт соответствует поставленным требованиям и готов к практическому применению. Эксплуатация программного средства 5.1 Ввод в эксплуатацию и обоснование минимальных технических требований к оборудованию Для деплоя веб–сервиса нужно использовать какой–либо хостинг [27]. Хостинг – это услуга по предоставлению ресурсов для размещения информации на сервере, постоянно имеющем доступ к сети. Есть большое количество хостингов как платных, так и бесплатных, некоторые из них имеют ограничения по количеству данных, некоторые по времени и занимаемой памяти т. д. Для данной курсовой работы используется платный хостинг Beget с функцией бесплатного использования для одного сайта, одной базы данных и ограниченного по памяти [28][29]. Проходим регистрацию, указывая номер телефона, на который будет зарегистрирован аккаунт, после успешной регистрации на указанный номер телефона придет смс с данными для авторизации логин и пароль. Авторизовавшись попадаем в панель управления, представленную на рисунке 5.1. Рисунок 5.1 – Панель управления Beget На локальном устройстве архивируем все файлы данной курсовой работы и при помощи Файлового менеджера погружаем их на сервер, предварительно удалив присутствующие файлы по умолчанию в нужной папке. Пример заливки файлов через файловый менеджер представлен на рисунке 5.2. Рисунок 5.2 – Заливка файлов через файловый менеджер на хостинг Далее нужно указать версии используемых языков программирования на хосте, такие же которые использовались в работе, для совмещения версий. В случае успешной погрузки всех данных на хостинг веб–сайт откроется по выданной ссылке в левом меню блока. Для работы и внесения правок на сервере нужно зайти в раздел FTP и создать FTP–аккаунт, к которому можно подключиться через FileZilla или другое подобное программное средство для внесения изменений сразу на сервере. Пример создания FTP–аккаунта представлен на рисунке 5.3. Рисунок 5.3 – Создание FTP–аккаунта После создания FTP–аккаунта получаем данные для подключения: хост, пароль, имя пользователя. В FileZilla создаем подключение и получаем все файлы для изменений. Пример подключения через FileZilla представлен на рисунке 5.4. Рисунок 5.4 – Подключение к веб–сайту для изменений через FileZilla Обоснование минимальных технических требований к оборудованию для открытия верстки сайта основывается на нескольких ключевых аспектах: Производительность. Для открытия требуется оборудование, способное обрабатывать HTML, CSS и другие веб–ресурсы без задержек. Даже на начальном этапе проекта, пользователи ожидают быстрого и плавного отображения страниц сайта. Ресурсы браузера. Браузеры должны иметь достаточное количество ресурсов для загрузки и отображения верстки. Это включает в себя оперативную память, процессорное время и место для кэширования данных. Совместимость и доступность. Оборудование должно соответствовать требованиям современных браузеров и учитывать различные устройства и разрешения экранов, чтобы обеспечить правильное отображение верстки на всех платформах. Быстродействие сети. Для эффективной загрузки сайта необходима стабильная и быстрая сетевая связь, особенно в случае использования медиаконтента или внешних ресурсов. Безопасность. Оборудование должно быть защищено от возможных угроз, таких как вредоносные программы или атаки злоумышленников, чтобы обеспечить безопасность. Исходя из этих аспектов, минимальные технические требования к оборудованию для открытия данного веб–сервиса могут включать в себя: Персональный компьютер или ноутбук современного поколения с процессором не ниже Intel Core i3 или аналогичным, оперативной памятью не менее 4 ГБ и достаточным объемом свободного места на диске для временного хранения данных. Поддержка 3G, 4G, Wi–Fi. Использование современного веб–браузера (например, Google Chrome, Mozilla Firefox, Safari, Microsoft Edge), обеспечивающего оптимальное отображение и исполнение веб–страниц. Стабильное интернет–соединение с минимальной скоростью загрузки и выгрузки данных, обеспечивающее быструю загрузку верстки сайта. Эти минимальные требования обеспечат возможность открытия веб–сервиса на устройствах пользователя с минимальными задержками и с учетом основных аспектов производительности и безопасности. 5.2 Руководство по эксплуатации программным средством Для открытия необходимо иметь устройство, которое имеет возможность выхода в сеть Интернет. Веб–сервис загружен на хостинг и открывается по общедоступной ссылке в сети интернет [30]. Рассмотрим руководство по эксплуатации программным средством в десктопной версии. В первую очередь, при проектировании пользовательского интерфейса, нужно создать грамотный экран «Авторизации». Экран «Авторизации» является лицом приложения, это тот экран, с которым пользователь будет взаимодействовать в первую очередь. Поэтому он должен сочетать в себя приятный интерфейс, который сможет понравиться пользователю. Он должен быть интуитивно понятен. Пример страницы «Авторизации» представлен на рисунке 5.5. Рисунок 5.5 – Страница «Авторизации» Если пользователь не зарегистрирован и находиться первый раз на нашем сайте, а также если его логин или пароль не работает для него есть информационный блок с подсказками, что делать в данной ситуации, и ссылками на сторонние ресурсы как это можно исправить. В случаи, если пользователю нужно посмотреть какой пароль он вводит, можно нажать на иконку глаза и сделать ввод пароля видимым, а не в виде точек. После заполнения всех полей нажимая на кнопку «Войти» происходит вход в систему и перенаправление на страницу «Кабинета». Если возникла какая–либо ошибка в поле заполнения ему показывается сообщение о том какое поле неверно заполнено, а также иконка, при наведении на которую, можно получить более подробную информацию ошибки. Пример исключительной ситуации с подробным описанием ошибки и функционалом показа пароля представлен на рисунке 5.6. Рисунок 5.6 – Исключительная ситуация c подробным описанием ошибки и функционалом показа пароля при авторизации Каждый пользователь, зайдя в систему получает доступ к навигационному меню в хедере при наведении на иконку, для перехода между страницами или выхода из аккаунта нажав кнопку «Выйти». Также есть кликабельный логотип, который ведет на страницу «Кабинет». Пример навигационного меню показан на рисунке 5.7. Рисунок 5.7 – Навигационное меню Перейдя в «Личный кабинет пользователя», пользователь видит свое ФИО и адрес электронной почты. Изменение личной информации невозможно. Пример страницы «Личного кабинета» показан на рисунке 5.8. Рисунок 5.8 – Страница «Личного кабинета» Перейдя на страницу «Роль пользователя», она доступна только в режиме администратора, можно увидеть, для удобства взаимодействия, поле поиска по ФИО, а также внизу страницы пагинацию для перехода между записями с информацией, в случаи если больше 10 пользователей выводится на экран за один раз. Основной контент занимает вывод информации о пользователях, их номер ФИО и роль. Пример страницы «Роль пользователя» показан на рисунке 5.9. Рисунок 5.9 – Страница «Роль пользователя» Перейдя на страницу «Кабинет» можно увидеть, для удобства взаимодействия, поле поиска по названию документа, а также внизу страницы пагинацию для перехода между записями с информацией, в случаи если больше 10 документов выводится на экран за один раз и информационный блок с подсказкой. Основной контент занимает вывод информации о документах, их название, статус, дату, оригинальность и кнопку. Дата равна дате загрузки документа на проверку. Состояние статуса меняется и может быть «в очереди», «проверен», «не зачтен», «в защите», «зачтен». Пример страницы «Кабинета» показан на рисунке 5.10. Рисунок 5.10 – Страница «Кабинета» Если же название документа слишком большое и не помещается в одну строку, оно обрезается и оканчивается троеточием, но для того чтобы увидеть полное название документа, нужно навести на название и на экране покажется блок с полным названием. Пример полного названия документа представлен на рисунке 5.11. Рисунок 5.11 – Пример вывода полного названия документа Нажимая на иконку троеточия у каждого документа, появляется выпадающее меню с выбором «Результаты» нажимая на нее происходит скачивание результатов документа и кнопка «Отправить на проверку» для отправки документа на проверку. Пример клика на иконку троеточия показан на рисунке 5.12. Рисунок 5.12 – Пример клика на иконку троеточия Нажимая на кнопку «Отправить на проверку» открывается модальное окно для подтверждения отправки документа на защиту. В данном модальном окне выводиться вопрос подтверждения действия и информация о документе, а также кнопка подтверждения отправки на проверку, нажимая на которую данный документ отправиться на проверку. Для того чтобы закрыть данное модальное окно, необходимо нажать на иконку крестика или же на область вне модального окна. Пример модального окна для отправки на проверку представлен на рисунке 5.13. Рисунок 5.13 – Модальное окно при клике на «Отправить на проверку» Для того чтобы отправить новый документ на проверку, достаточно нажать на кнопку «Проверить документ» рядом с поиском и откроется модальное окно. Пример модального окна для загрузки нового документа представлен на рисунке 5.14. Рисунок 5.14 – Модальное окно для загрузки нового документа Далее выбираем из выпадающего списка тип работы, пишем название работы и в поле для загрузки документа либо нажав на кнопку «Загрузить документ» либо перетащив документ в область загрузки документа, если же документ выбран не тот, что нужно, его можно удалить из данной формы нажав на кнопку крестика данного документа. Если все поля заполнены корректно, нажимая на кнопку «Проверить» документ отправится на проверку и закроется модальное окно. Также для того, чтобы закрыть модальное окно, достаточно нажать на иконку крестика или же на область вне модального окна. Пример заполненной формы представлен на рисунке 5.15. Рисунок 5.15 – Заполненная форма загрузки документа Перейдя на страницу «Результаты» можно увидеть, для удобства взаимодействия, поле поиска по ФИО, а также внизу страницы пагинацию для перехода между страницами с информацией, в случаи если больше 10 пользователей выводится на экран за один раз и информационный блок с подсказкой. Основной контент занимает вывод информации о результатах документов, их название, статус, дату, оригинальность и кнопку. Дата равна дате загрузки документа на проверку. Состояние статуса меняется и, может быть, либо зачтен, либо отправлен на доработку. Пример страницы «Результаты» показан на рисунке 5.16. Рисунок 5.16 – Пример страницы «Результаты» Нажимая на иконку троеточия у каждого документа, появляется выпадающее меню с выбором «Результаты» нажимая на нее происходит скачивание результатов документа в формате *pdf и кнопка «Оценить» для открытия модального окна и оценки данной работы. Пример клика на иконку троеточия показан на рисунке 5.17. Рисунок 5.17 – Пример клика на иконку троеточия Нажимая на кнопку «Оценить», открывается модальное окно для оценки документа, в котором выводится подтверждение для внесения окончательного решения о данном документе, и информация о данном документе в виде ФИО, названии документа и оригинальность. Пример вывода модального окна показан на рисунке 5.18. Рисунок 5.18 – Модальное окно «Оценки документа» Также есть две кнопки «Отправить на доработку» и «Зачтен», при клике на кнопку «Отправить на доработку» документ отправляется на доработку и статус документа меняется на отрицательный. Статус документа после клика на кнопку «Отправить на доработку» показан на рисунке 5.19. Рисунок 5.19 – Статус при клике на кнопку «Отправить на доработку» При клике на кнопку «Зачтен» статус документа меняется на положительный. Статус документа после клика на кнопку «Зачтен» показан на рисунке 5.20. Рисунок 5.20 – Статус при клике на кнопку «Зачтен» После клика на кнопку «Зачтен» или же на кнопку «Отправить на доработку» модальное окно закрывается, также для того, чтобы закрыть модальное окно достаточно нажать на кнопку крестика или же на область вне модального окна. Также для мобильной версии предусмотрена кнопка скроллинга наверх страницы, для быстрого перехода в вверх страницы и любого положения. Пример кнопки скроллинга наверх показан на рисунке 5.21. Рисунок 5.21 – Пример кнопки скроллинга Таким образом, в данном разделе было представлено руководство по вводу в эксплуатацию и эксплуатации разработанного программного продукта. ЗАКЛЮЧЕНИЕ В ходе выполнения курсового проекта была поставлена и успешно достигнута цель – разработка модульной системы проверки текстов на заимствования с использованием Docker–контейнеров. Разработанная система реализована на основе микросервисной архитектуры, что обеспечивает высокий уровень модульности, отказоустойчивости и удобство горизонтального масштабирования. Каждая функциональная часть программного средства, включая обработку запросов пользователей, анализ текстов, управление базой данных и формирование отчётов, выделена в отдельный сервис и упакована в Docker–контейнер. Это решение позволяет легко управлять конфигурациями, обеспечивать переносимость системы между различными средами и упрощает её обновление и поддержку. В процессе работы был проведён детальный анализ существующих решений в области проверки оригинальности текста, что позволило определить ключевые требования к функциональности, безопасности, хранению данных и взаимодействию сервисов. На основе этих требований была спроектирована архитектура системы и реализован пользовательский веб–интерфейс, предоставляющий возможность загрузки файлов, просмотра результатов проверки и управления историей анализов. Дополнительно внедрены механизмы логирования, мониторинга, защиты данных и контроля доступа, что повышает надёжность и безопасность работы системы. Разработанное решение демонстрирует высокую практическую ценность. Система может быть эффективно использована в образовательных учреждениях, научных организациях и коммерческих компаниях для автоматизации проверки текстов, повышения качества работ и предотвращения нарушений авторских прав. Модульная архитектура обеспечивает гибкость и адаптивность системы под различные предметные области и объёмы данных, а технология контейнеризации значительно облегчает её внедрение в существующие ИТ–инфраструктуры. Таким образом, выполненный проект подтвердил возможность создания эффективной и масштабируемой системы проверки на заимствования, сочетающей современные методы анализа текстов с преимуществами контейнеризации и микросервисного подхода. Реализованное решение может стать основой для дальнейшего расширения функционала и интеграции в образовательные и корпоративные платформы. СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ [1] БГУИР ГОСТ СТП 01–2017 [Электронный ресурс]. – Режим доступа: https://www.bsuir.by/m/12_100229_1_122976.pdf − Дата доступа: 10.05.2024. [2] Антиплагиат [Электронный ресурс]. – Режим доступа: https://antiplagiat.ru/ − Дата доступа: 12.04.2024. [3] PlagScan [Электронный ресурс]. – Режим доступа: https://www.turnitin.com/ − Дата доступа: 12.04.2024. [4] Text.ru [Электронный ресурс]. – Режим доступа: https://text.ru/doc–check − Дата доступа: 12.04.2024. [5] Antiplagius [Электронный ресурс]. – Режим доступа: https://antiplagius.ru/− Дата доступа: 12.04.2024. [6] BE1.ru [Электронный ресурс]. – Режим доступа: https://be1.ru/antiplagiat–online/ − Дата доступа: 12.04.2024. [7] MDN Web Docs [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/HTML − Дата доступа: 10.03.2024. [8] W3Schools [Электронный ресурс]. – Режим доступа: https://www.w3schools.com/html/ − Дата доступа: 05.03.2024. [9] Основы HTML – Изучение веб–разработки [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/HTML – Дата доступа: 08.03.2024. [10] Руководство по CSS: каскадные таблицы [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/CSS/Reference – Дата доступа: 10.03.2024. [11] Основы SCSS [Электронный ресурс]. – Режим доступа: https://sass–scss.ru/guide/ – Дата доступа: 12.03.2024. [12] Современный учебник JavaScript [Электронный ресурс]. – Режим доступа: https://learn.javascript.ru/ – Дата доступа: 14.03.2024. [13] UI Дока JavaScript [Электронный ресурс]. – Режим доступа: https://doka.guide/js/ – Дата доступа: 14.03.2024. [14] Интегрированная среда разработки [Электронный ресурс]. – Режим доступа: https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки – Дата доступа: 06.03.2024. [15] VSCode [Электронный ресурс]. – Режим доступа: https://code.visualstudio.com/ – Дата доступа: 06.03.2024. [16] VS Code настройка установка плагины [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=nxCLXMBl4e4 – Дата доступа: 06.03.2024. [17] MySQL [Электронный ресурс]. – Режим доступа: https://www.mysql.com/ – Дата доступа: 05.04.2024. [18] Git и GitHub курс для новичков [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=zZBiln_2FhM – Дата доступа: 17.03.2024. [19] GIT [Электронный ресурс]. – Режим доступа: https://git–scm.com/ – Дата доступа: 20.04.2024. [20] GitHub [Электронный ресурс]. – Режим доступа: https://blog.hubspot.com/website/what–is–github–used–for – Дата доступа: 12.04.2024. [21] Gulp установка настройка плагины [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=jU88mLuLWlk&t=2055s – Дата доступа: 12.03.2024. [22] Гид по Figma для разработчиков [Электронный ресурс]. – Режим доступа: https://www.figma.com/community/file/886207890389884742 – Дата доступа: 12.03.2024. [23] Алексеев, В. Ф. Структуры и базы данных. Пособие для курсового проектирования: пособие / В. Ф. Алексеев, И. Н. Богатко, Г. А. Пискун. – Минск: БГУИР, 2017. – 84 с.: ил. [24] PostgreSQL: Документация – Режим доступа: https://postgrespro.ru/docs/postgresql – Дата доступа: 04.04.2024. [25] Принципы UI/UX. – Режим доступа: https://habr.com/ru/companies/SECL_GROUP/articles/182208/ – Дата доступа: 10.04.2024. [26] Зачем нужно тестирование? Когда оно начинается и когда заканчивается, какие задачи стоят перед тестированием программного обеспечения? [Электронный ресурс]. – Режим доступа: https://dzen.ru/a/ZGEgrWptlGbZJKJi– Дата доступа: 05.01.2024. [27] Что такое хостинг [Электронный ресурс]. – Режим доступа: https://hostiq.ua/info/what–is–hosting/ – Дата доступа: 04.05.2024. [28] Руководство по панели управления Beget [Электронный ресурс]. – Режим доступа: https://beget.com/ru/kb/manual – Дата доступа: 04.05.2024. [29] Выгрузка проекта на хостинг [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=UPnVcTZUwXE&t=854s – Дата доступа: 04.05.2024. [30] Разработанный веб–сервис [Электронный ресурс]. Режим доступа: http://dimaracb.beget.tech/ – Дата доступа: 07.05.2024. ПРИЛОЖЕНИЕ А (обязательное)Отчёт о проверке на заимствования в системе «Антиплагиат» Рисунок А.1 – Отчет о проверке на заимствования в системе «Антиплагиат» ПРИЛОЖЕНИЕ Б (обязательное) Листинги программного кода Файл main.html @Service public class TicketServiceImpl implements TicketService { private TicketRepository ticketRepository; private MovieRepository movieRepository; private CinemaHallService cinemaHallService; private CartRepository cartRepository; private BookingRepository bookingRepository; private MovingPictureShowRepository movingPictureShowRepository; @Autowired public TicketServiceImpl(TicketRepository ticketRepository, MovieRepository movieRepository, CartRepository cartRepository, BookingRepository bookingRepository, CinemaHallService cinemaHallService, MovingPictureShowRepository movingPictureShowRepository) { this.ticketRepository = ticketRepository; this.movieRepository = movieRepository; this.cartRepository = cartRepository; this.bookingRepository = bookingRepository; this.cinemaHallService = cinemaHallService; this.movingPictureShowRepository = movingPictureShowRepository; } @Override public List<DateRequestDto> findAllTicketDates() { List<LocalDate> localDates = movingPictureShowRepository.searchDates(); List<DateRequestDto> dateRequestDtos = new ArrayList<>(); System.out.println(localDates); for (LocalDate localDate : localDates) { dateRequestDtos.add(new DateRequestDto()); dateRequestDtos.getLast().setFullDate(localDate.atStartOfDay().format(DateTimeFormatter.ISO_DATE_TIME)); } return dateRequestDtos; } @Override public List<TicketDto> findAllTicketDatesTime(LocalDateTime localDateTime, Long cinemaHallId) { localDateTime = localDateTime.plusHours(3); LocalDate ld = localDateTime.toLocalDate(); LocalTime lt = localDateTime.toLocalTime(); System.out.println(localDateTime); List<Ticket> tickets = ticketRepository.findAll().stream().filter(e->{ return (ld.equals(e.getMovingPictureShow().getDate()) && lt.equals(e.getMovingPictureShow().getTime()) && e.getMovingPictureShow().getCinemaHall().getId().equals(cinemaHallId)); }).toList(); return tickets.stream().map(TicketMapper::mapToTicketDto).collect(Collectors.toList()); } @Override public List<MovieStatDto> findAllMovieStat() { List<Movie> movies = movieRepository.findAll(); List<MovieStatDto> movieStatDtos = new ArrayList<>(); for(Movie movie : movies) { Integer purchased = ticketRepository.findPurchased(movie.getId()); MovieStatDto movieStatDto = MovieStatDto.builder() .id(movie.getId()) .title(movie.getTitle()) .soldTickets(purchased) .revenue(purchased * movie.getCost()) .build(); movieStatDtos.add(movieStatDto); } return movieStatDtos; } @Override public List<CinemaHallStatDto> findAllCinemaHallStat() { List<CinemaHallStatDto> cinemaHallStatDtos = new ArrayList<>(); List<Movie> movies = movieRepository.findAll(); for(Movie movie : movies) { List<MovingPictureShow> movingPictureShow = movingPictureShowRepository.searchCinoSession(movie.getId()); // System.out.println(movingPictureShow.getFirst().getTickets().size()); // List<Ticket> tickets = movingPictureShow.stream().map(session -> session.getTickets().getFirst()).toList(); for(MovingPictureShow session : movingPictureShow){ Integer purchased = ticketRepository.findPurchasedCinemaHall(session.getDate(), session.getTime()); CinemaHallStatDto cinemaHallStatDto = CinemaHallStatDto.builder() .id(session.getId()) .cinemaHallId(session.getCinemaHall().getId()) .hallName(session.getCinemaHall().getName()) .movieName(session.getMovie().getTitle()) .date(session.getDate()) .time(session.getTime()) .amountOfSeats(session.getCinemaHall().getCol() * session.getCinemaHall().getRow()) .amountOfOccupiedSeats(purchased) .build(); cinemaHallStatDtos.add(cinemaHallStatDto); }} return cinemaHallStatDtos; } @Override public void createTicket(TicketDto ticketDto, MovingPictureShow movingPictureShow) { Ticket ticket = TicketMapper.mapToTicket(ticketDto); ticket.setMovingPictureShow(movingPictureShow); ticketRepository.save(ticket); } @Override public List<TicketDto> findTicketsByMovieIdAndDate(Long movieId,LocalDate date) { Movie movie = movieRepository.findById(movieId).get(); return movie.getMovingPictureShows() .stream() .filter(e -> e.getDate().equals(date)) .map(e -> TicketMapper.mapToTicketDto(e.getTickets().getFirst())) .collect(Collectors.toList()); } @Override public List<TicketDto> findTicketsByCartId(Long cartId) { Cart cart = cartRepository.findById(cartId).get(); return cart.getTickets().stream().map(TicketMapper::mapToTicketDto).collect(Collectors.toList()); } @Override public List<TicketDto> findTicketsByBookingId(Long bookingId) { Booking booking = bookingRepository.findById(bookingId).get(); return booking.getTickets().stream().map(TicketMapper::mapToTicketDto).collect(Collectors.toList()); } @Override public void addTicketToBooking(Long bookingId, Long ticketId, PaymentType payType) { Booking booking = bookingRepository.findById(bookingId).get(); Ticket ticket = ticketRepository.findById(ticketId).get(); ticket.setBooking(booking); ticket.setPayType(payType); ticket.setStatus(true); ticket.setCart(null); ticketRepository.save(ticket); } @Override public void addTicketToAllBooking(Long bookingId, Long cartId, PaymentType paytype) { Booking booking = bookingRepository.findById(bookingId).get(); List<Ticket> tickets = cartRepository.findById(cartId).get().getTickets(); for (Ticket ticket : tickets) { ticket.setBooking(booking); ticket.setPayType(paytype); ticket.setStatus(true); ticket.setCart(null); ticketRepository.save(ticket); }} @Override public void delete(Long ticketId) { ticketRepository.deleteById(ticketId); } public void deleteSchedule(){ LocalDate localDate = LocalDateTime.now().minusHours(3).toLocalDate().minusDays(10); List<Ticket> tickets = ticketRepository.findAll().stream().filter(t -> { return t.getMovingPictureShow().getDate().isBefore(localDate); }).toList(); ticketRepository.deleteAll(tickets); } @Override public void createShedule(LocalDate localDate){ deleteSchedule(); final LocalTime startOfWork= LocalTime.of(10,0); final LocalTime endOfWork= LocalTime.of(0,0); LocalTime time; List<CinemaHallDto> cinemaHallDtos = cinemaHallService.getAllCinemaHalls(); List<Movie> movies = movieRepository.findAll().stream().sorted(Comparator.comparing((e) -> { if(e.getMovingPictureShows()==null || e.getMovingPictureShows().isEmpty()) { System.out.println(e); return 1000000; } else { int soldTickets = e.getMovingPictureShows().stream().flatMap(session -> session.getTickets().stream()).reduce(0, (x, y) -> x + y.getStatus().compareTo(true), Integer::sum); int allTickets = (int)e.getMovingPictureShows().stream().flatMap(session -> session.getTickets().stream()).count(); if( soldTickets == 0){ return allTickets; } else{ return allTickets + soldTickets; }} } )).collect(Collectors.toList()).reversed(); for(CinemaHallDto cinemaHallDto : cinemaHallDtos){ Movie movie = movies.getFirst(); time = startOfWork; while(true) { movie =movies.getFirst(); if(time.plusMinutes(movie.getDuration()).getHour() < startOfWork.getHour()) { for(Movie mv : movies){ if(time.plusMinutes(mv.getDuration()).getHour() > startOfWork.getHour()) { movie = mv; break; }} if(time.plusMinutes(movie.getDuration()).getHour() < startOfWork.getHour()) { break; }} movies.remove(movie); createSession(cinemaHallDto, localDate, movie, time); time = time.plusMinutes(movie.getDuration() + 15); int remainder = time.getMinute() % 5; if (!(remainder == 0)) { time = time.plusMinutes(5 - remainder); } movies.add(movie); }}} public void createSession(CinemaHallDto cinemaHallDto, LocalDate localDate, Movie movie,LocalTime time ) { MovingPictureShow sesion = movingPictureShowRepository.save(MovingPictureShow.builder() .cinemaHall(CinemaHallMapper.mapToCinemaHall(cinemaHallDto)) .date(localDate) .movie(movie) .time(time) .build()); TicketDto ticketDto = TicketDto.builder() .movie(MovieMapper.mapToMovieDto(movie)) .cinemaHall(cinemaHallDto) .status(false) .build(); for (int i = 0; i < cinemaHallDto.getRow(); i++) { for (int j = 0; j < cinemaHallDto.getCol(); j++) { ticketDto.setCol(j+1); ticketDto.setRow(i+1); createTicket(ticketDto, sesion); }}} @Override public List<MovieStatDto> filterMovieStats(Long movieId, Long hallId, LocalDate start, LocalDate end) { List<MovieStatDto> base = findAllMovieStat(); return base.stream() .filter(m -> movieId == null || m.getId().equals(movieId)) .collect(Collectors.toList()); } @Override public List<CinemaHallStatDto> filterHallStats(Long movieId, Long hallId, LocalDate start, LocalDate end) { return findAllCinemaHallStat().stream() .filter(h -> movieId == null || h.getMovieName().equals( movieRepository.findById(movieId).get().getTitle())) .filter(h -> hallId == null || h.getCinemaHallId().equals(hallId)) .filter(h -> { if (start == null || end == null) return true; return (!h.getDate().isBefore(start) && !h.getDate().isAfter(end)); }) .collect(Collectors.toList());} @Override public byte[] generateReport() { StringBuilder sb = new StringBuilder(); sb.append(\"Hall,Date,Time,Movie,Seats,Occupied,Percent\\n\"); for (CinemaHallStatDto dto : findAllCinemaHallStat()) { int percent = dto.getAmountOfOccupiedSeats() * 100 / dto.getAmountOfSeats(); sb.append(dto.getHallName()).append(\",\") .append(dto.getDate()).append(\",\") .append(dto.getTime()).append(\",\") .append(dto.getMovieName()).append(\",\") .append(dto.getAmountOfSeats()).append(\",\") .append(dto.getAmountOfOccupiedSeats()).append(\",\") .append(percent).append(\"%\\n\"); } return sb.toString().getBytes(); }} <User className=\"h-5 w-5\" /> <span className=\"sr-only\">Account</span> </Button> </Link> <Link href=\"/admin\" className=\"md:hidden\"> <Button variant=\"ghost\" size=\"icon\" className=\"text-gray-400 hover:text-white\"> <Settings className=\"h-5 w-5\" /> <span className=\"sr-only\">Admin</span> </Button> </Link> <Link href=\"/login\"> <Button variant=\"outline\" className=\"hidden md:inline-flex border-gray-700 bg-gray-800 text-white hover:bg-gray-700\" > Sign In </Button> </Link> </div> </div> </header> {/* Hero Section */} <section className=\"relative overflow-hidden py-20 md:py-32\"> <div className=\"container flex flex-col items-center text-center\"> <div className=\"absolute inset-0 -z-10 bg-[radial gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-gray-900 via black to-black\"> <div className=\"absolute inset-0 bg-grid-pattern opacity 5\"></div> <div className=\"absolute inset-0 animate-pulse-slow bg-[radial gradient(circle_at_center,_var(--tw-gradient-stops))] from-blue-900/10 via transparent to-transparent\"></div> </div> <div className=\"absolute inset-0 -z-10 bg [url('/placeholder.svg?height=800&width=1600')] bg-cover bg-center opacity-10 mix-blend-overlay\"></div> <h1 className=\"max-w-4xl text-4xl font-bold tracking-tight sm:text 5xl md:text-6xl lg:text-7xl\"> Premium Vaping{\" \"} <span className=\"bg-gradient-to-r from-teal-400 to-blue-500 bg clip-text text-transparent\">Experience</span> </h1> <p className=\"mt-6 max-w-2xl text-lg text-gray-200\"> Discover our premium collection of electronic cigarettes and accessories. Designed for the modern vaper with quality and style in mind. </p> <div className=\"mt-10 flex flex-wrap justify-center gap-4\"> <Button className=\"bg-gradient-to-r from-teal-500 to-blue-600 hover:from-teal-600 hover:to-blue-700\"> Shop Now <ArrowRight className=\"ml-2 h-4 w-4\" /> </Button> <Button variant=\"outline\" </div> </div> </section> {/* Featured Products */} <section id=\"products\" className=\"py-16 bg-gray-950\"> <div className=\"container\"> <h2 className=\"text-3xl font-bold tracking-tight mb-8\">Featured Products</h2> <ProductCatalog /> </div> </section> {/* Features Section */} <section className=\"py-16\"> <div className=\"container\"> <div className=\"grid grid-cols-1 gap-8 md:grid-cols-3\"> <div className=\"group rounded-lg border border-gray-800 bg-gray 950 p-6 transition-all duration-300 hover:border-blue-500 hover:shadow-md hover:shadow-blue-500/10 hover:translate-y-[-5px]\"> <div className=\"mb-4 rounded-full bg-blue-500/10 p-3 w-12 h-12 flex items-center justify-center\"> <svg className=\"h-6 w-6 text-blue-500\" fill=\"none\" height=\"24\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\" > <path d=\"M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z\" /> </svg> </div> <h3 className=\"mb-2 text-xl font-bold\">Premium Quality</h3> <p className=\"text-gray-400\"> Our products are crafted with the highest quality materials for a superior vaping experience. </p> </div> <div className=\"group rounded-lg border border-gray-800 bg-gray 950 p-6 transition-all duration-300 hover:border-teal-500 hover:shadow-md hover:shadow-teal-500/10 hover:translate-y-[-5px]\"> <div className=\"mb-4 rounded-full bg-teal-500/10 p-3 w-12 h-12 flex items-center justify-center\"> </svg> </div> <h3 className=\"mb-2 text-xl font-bold\">Secure Shopping</h3> <p className=\"text-gray-400\"> Shop with confidence with our secure payment system and fast, reliable shipping. </p> </div> <div className=\"group rounded-lg border border-gray-800 bg-gray 950 p-6 transition-all duration-300 hover:border-blue-500 hover:shadow-md hover:shadow-blue-500/10 hover:translate-y-[-5px]\"> <div className=\"mb-4 rounded-full bg-blue-500/10 p-3 w-12 h-12 flex items-center justify-center\"> <svg className=\"h-6 w-6 text-blue-500\" fill=\"none\" height=\"24\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\" > <path d=\"M18 6H5a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h13l4-3.5L18 6Z\" /> <path d=\"M12 13v8\" /> <path d=\"M5 13v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6\" /> </svg> </div> <h3 className=\"mb-2 text-xl font-bold\">Customer Support</h3> <p className=\"text-gray-400\"> Our dedicated support team is always ready to assist you with any questions or concerns. </p> </div> </div> </div> </section> {/* Newsletter Section */} <section className=\"py-16 bg-gray-950\"> <div className=\"container\"> <div className=\"rounded-xl border border-gray-800 bg-gradient-to-br from-gray-900 to-black p-8 relative overflow-hidden\"> <div className=\"absolute inset-0 bg-grid-pattern opacity 5\"></div> <div className=\"absolute -inset-1 bg-gradient-to-r from-teal 500/10 via-blue-500/10 to-teal-500/10 blur-xl filter opacity-30 animate pulse-slow\"></div> <div className=\"relative\"> <div className=\"flex flex-col items-center justify-between gap 4 md:flex-row\"> <div> <h3 className=\"text-2xl font-bold\">Stay Updated</h3> <p className=\"text-gray-400\"> Subscribe to our newsletter for the latest products and exclusive offers. </p> type=\"email\" placeholder=\"Enter your email\" className=\"w-full rounded-md border border-gray-800 bg black px-4 py-2 text-white focus:border-blue-500 focus:outline-none\" /> <Button className=\"bg-gradient-to-r from-teal-500 to-blue 600 hover:from-teal-600 hover:to-blue-700\"> Subscribe </Button> </div> </div> </div> </div> </div> </section> {/* Footer */} <footer className=\"border-t border-gray-800 bg-black py-12\"> <div className=\"container\"> <div className=\"grid grid-cols-1 gap-8 md:grid-cols-4\"> <div> <Link href=\"/\" className=\"flex items-center gap-2 text-xl font bold\"> <span className=\"bg-gradient-to-r from-teal-400 to-blue-500 bg-clip-text text-transparent\">VAPOR</span> <span>TECH</span> </Link> <p className=\"mt-4 text-gray-400\">Premium vaping products for the modern enthusiast.</p> </div> <div> <h3 className=\"mb-4 text-lg font-semibold\">Quick Links</h3> <ul className=\"space-y-2 text-gray-400\"> <li> <Link href=\"/\" className=\"hover:text-blue-400\"> Home </Link> </li> <li> <Link href=\"#products\" className=\"hover:text-blue-400\"> Products </Link> </li> <li> <Link href=\"#about\" className=\"hover:text-blue-400\"> About Us </Link> </li> <li> <Link href=\"#contact\" className=\"hover:text-blue-400\"> Contact </Link> </li> </ul> </div> <div> <h3 className=\"mb-4 text-lg font-semibold\">Customer Service</h3> <ul className=\"space-y-2 text-gray-400\"> <li> </li> <li> <Link href=\"/shipping\" className=\"hover:text-blue-400\"> Shipping & Returns </Link> </li> <li> <Link href=\"/warranty\" className=\"hover:text-blue-400\"> Warranty </Link> </li> <li> <Link href=\"/privacy\" className=\"hover:text-blue-400\"> Privacy Policy </Link> </li> </ul> </div> <div> <h3 className=\"mb-4 text-lg font-semibold\">Contact Us</h3> <address className=\"not-italic text-gray-400\"> <p>1234 Street</p> <p>San Francisco, CA 94103</p> <p className=\"mt-2\">Email: info@vaportech.com</p> <p>Phone: (123) 456-7890</p> </address> </div> </div> <div className=\"mt-12 border-t border-gray-800 pt-8 text-center text-gray-400\"> <p>© 2024 VaporTech. All rights reserved.</p> </div> </div> </footer> </div> ) } export default function Home() { return ( <div className=\"flex min-h-screen flex-col bg-black text-white\"> {/* Navigation */} <header className=\"sticky top-0 z-40 w-full border-b border-gray-800 bg-black/80 backdrop-blur-sm\"> <div className=\"container flex h-16 items-center justify-between\"> <Link href=\"/\" className=\"flex items-center gap-2 text-xl font bold\"> <span className=\"bg-gradient-to-r from-teal-400 to-blue-500 bg clip-text text-transparent\">VAPOR</span> <span>TECH</span> </Link> <nav className=\"hidden md:flex items-center gap-6 text-sm\"> <Link href=\"/\" className=\"font-medium text-white transition colors hover:text-blue-400\"> Home </Link> <Link href=\"#products\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> Products </Link> 49 <Link href=\"#about\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> About </Link> <Link href=\"#contact\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> Contact </Link> <Link href=\"/admin\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> Admin </Link> </nav> <div className=\"flex items-center gap-4\"> <Link href=\"/cart\"> <Button variant=\"ghost\" size=\"icon\" className=\"relative text gray-400 hover:text-white\"> <ShoppingCart className=\"h-5 w-5\" /> <span className=\"absolute -top-1 -right-1 flex h-4 w-4 items center justify-center rounded-full bg-blue-500 text-[10px] font-bold text white\"> 3 </span> <span className=\"sr-only\">Shopping Cart</span> </Button> </Link> <Link href=\"/account\"> ПРИЛОЖЕНИЕ В (обязательное) Графический материал ПРИЛОЖЕНИЕ Г (обязательное) Ведомость курсового проекта",
      "wordCount": 13235,
      "uploadDate": "2026-01-28T23:17:42.051Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        118115,
        228704,
        35456,
        47974,
        40675,
        53090,
        101639,
        166996,
        142348,
        53874,
        79417,
        118127,
        18209,
        28683,
        344873,
        376892,
        130897,
        80489,
        56184,
        22874,
        44872,
        64880,
        28480,
        41365,
        173641,
        544551,
        10284,
        29535,
        51127,
        131290,
        46838,
        82281,
        114802,
        18489,
        19382,
        27216,
        58359,
        29425,
        5072,
        44225,
        355946,
        248464,
        76468,
        95321,
        26861,
        343390,
        10165,
        229934,
        52576,
        396221,
        123214,
        31268,
        115144,
        36331,
        153600,
        35737,
        44206,
        115505,
        46953,
        95050,
        172363,
        96494,
        122991,
        46854,
        10511,
        59676,
        17621,
        47931,
        126076,
        49161,
        63058,
        103730,
        13049,
        4509,
        35237,
        19474,
        34560,
        155298,
        109757,
        95749,
        7481,
        53068,
        36150,
        26384,
        20381,
        10874,
        168631,
        52509,
        76982,
        59454,
        6810,
        10376,
        186383,
        31802,
        128544,
        111792,
        41640,
        82358,
        27602,
        171660,
        163919,
        805,
        24411,
        141064,
        40686,
        7003,
        25243,
        47919,
        56862,
        25173,
        16065,
        138033,
        53371,
        16031,
        73953,
        87067,
        1231,
        116178,
        12127,
        50765,
        109736,
        117086,
        98237,
        18237,
        11781,
        16049,
        53574,
        37535
      ],
      "shingleCount": 29384
    },
    {
      "id": 49,
      "title": "ХА АНДРЕЙ 3.0",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "ХА АНДРЕЙ 3.0 (3).docx",
      "filePath": "data/uploads/1769642284510_ХА_АНДРЕИ__3_0__3_.docx",
      "content": "Министерство образования Республики Беларусь Учреждение образования «Белорусский государственный университет информатики и радиоэлектроники» Факультет компьютерного проектирования Кафедра проектирования информационно-компьютерных систем Дисциплина «Разработка программных приложений для бизнес-анализа» «К ЗАЩИТЕ ДОПУСТИТЬ» Руководитель курсового проекта Магистр, ассистент кафедры ПИКС _______________ К.С. Крез ___.____.2025 ПОЯСНИТЕЛЬНАЯ ЗАПИСКА к курсовой работе на тему: «Разработка модульной системы проверки на заимствования текста с использованием Docker-контейнеров» БГУИР КР 6-05-0611-01 026 ПЗ Выполнил студент группы 314302 Ханцевич Андрей Александрович _______________________________ (подпись студента) Курсовой проект представлен на проверку ___.____.2025 _______________________________ (подпись студента) Минск 2025 РЕФЕРАТ БГУИР КР 6-05-0611-01 026 ПЗ Ханцевич А.А. Разработка модульной системы проверки на заимствования текста с использованием Docker-контейнеров: пояснительная записка к курсовому проекту/ А.А. Ханцевич. – Минск: БГУИР, 2025. – 71 с. Пояснительная записка 71 с., 24 рис., 8 табл., 30 источников, 4 приложения. РАЗРАБОТКА МОДУЛЬНОЙ СИСТЕМЫ ПРОВЕРКИ НА ЗАИМСТВОВАНИЯ ТЕКСТА С ИСПОЛЬЗОВАНИЕМ DOCKER-КОНТЕЙНЕРОВ Цель проектирования: создание модульного программного средства для проверки текстов на заимствования, реализованного на основе микросервисной архитектуры и развёртываемого с использованием Docker-контейнеров. Система должна обеспечивать высокую производительность, удобство масштабирования и изоляцию вычислительных модулей, участвующих в анализе текстов и обработке запросов пользователей. Методология проведения работы: при проектировании применялись принципы модульности, отказоустойчивости и горизонтального масштабирования. Выполнен анализ существующих решений в сфере проверки уникальности текста и определены требования к функциональности, безопасности, хранению данных и взаимодействию сервисов. Результаты работы: разработана архитектура программного средства, включающая отдельные сервисы для обработки запросов пользователей, анализа текстовых данных, управления базой текстов и формирования отчётов. Каждая функциональная часть системы упакована в Docker-контейнер, что обеспечивает гибкое управление конфигурациями, удобство обновления и переносимость решения. Реализован пользовательский веб-интерфейс с возможностью загрузки файлов, просмотром результатов проверки и управлением историей анализов. Предусмотрены механизмы логирования, мониторинга, защиты данных и контроля доступа к функциональным элементам системы. Область применения результатов: разработанное решение может использоваться в образовательных учреждениях, научных организациях и коммерческих компаниях для автоматизации проверки оригинальности контента, повышения качества работ и предотвращения нарушений авторских прав. Благодаря модульной архитектуре система легко адаптируется под различные предметные области и объёмы данных, а технология контейнеризации упрощает её внедрение в существующие ИТ-инфраструктуры. СОДЕРЖАНИЕ Введение 20 1 Анализ исходных данных и постановка задач для курсовой работы 20 1.1 Анализ исходных данных к курсовой работе 20 1.2 Обзор существующих программных средств по теме курсовой работы 20 1.3 Обоснование и описание выбора языка программирования, средств разработки, используемых технологий и сторонних библиотек. 20 1.4 Постановка задач на курсовую работу 20 2 Разработка и реализация процесса контейнеризации программного средства с использованием технологии Docker. 20 2.1. Теоретические основы и анализ технологий контейнеризации. 20 2.2. Проектирование и практическая реализация контейнеризации проекта 21 2.2.1. Анализ архитектуры и технологического стека исследуемого проекта 21 2.2.2 Проектирование контейнерной инфраструктуры. 22 2.2.3 Разработка Dockerfile. 22 2.2.4 Оркестрация контейнеров с помощью Docker Compose. 24 2.3 Тестирование и оценка эффективности внедренного решения 25 2.3.1 Методология тестирования решения 25 2.3.2 Сравнительный анализ показателей до и после внедрения контейнеризации 25 2.3.3 Анализ аспектов безопасности. 26 2.4 Выводы по главе. 28 3 Реализация централизованного управления данными аутентификации посредством LDAP 20 3.1 Настройка Celery 20 3.2 Анализ исходных данных к курсовому проекту 20 3.3 Вывод по главе 20 4 Проектирование, разработка 20 4.1 Проектирование и реализация способа хранения данных программного средства 20 4.2 Проектирование и разработка графического интерфейса 20 4.3 Тестирование программного средства 20 4.4 Вывод по главе 20 5 Эксплуатация программного средства 25 5.1 Ввод в эксплуатацию и обоснование минимальных технических требований к оборудованию 25 5.2 Руководство по эксплуатации программным средством 25 Заключение 20 Приложение А (обязательное) Отчет о проверке на заимствование в системе «Антиплагиат» 20 Приложение Б (обязательное) Листинги программного кода 20 Приложение В (обязательное) Графический материал 20 Приложение Г (обязательное) Ведомость курсового проекта 20 ВВЕДЕНИЕ В рамках данного курсового проекта разработана модульная система для проверки текстовых документов на заимствования с использованием технологии Docker-контейнеризации. Программное средство предназначено для автоматизации процесса выявления сходств между документами и упрощения развёртывания системы на различных программно-аппаратных платформах. Основная цель проекта заключается в создании гибкого, масштабируемого и легко поддерживаемого веб-сервиса, обеспечивающего анализ текстов и предоставляющего пользователям отчёты о степени уникальности материалов. Использование Docker позволяет изолировать компоненты системы, обеспечить независимость от окружения и повысить надёжность процесса развёртывания. При выполнении курсовой работы проведён анализ исходных данных и существующих программных средств в области проверки уникальности текстов, обоснован выбор фреймворка Django и технологий, применяемых при контейнеризации. Реализована архитектура, включающая отдельные контейнеры для веб-приложения и сопутствующих сервисов, проведено тестирование работоспособности и оценка преимуществ контейнерного подхода. Пояснительная записка включает описание используемых методов проверки на заимствования, проектирование и реализацию системы контейнеризации, разработку механизмов обработки и хранения данных, а также инструкцию по эксплуатации и развёртыванию программного средства. В работе представлены графические материалы, демонстрирующие структуру приложения, диаграммы развертывания и элементы пользовательского интерфейса. Разработанное программное средство может использоваться в учебном процессе БГУИР для автоматизированного контроля оригинальности студенческих и научных работ, а также служить основой для дальнейшего расширения функциональности и внедрения более совершенных алгоритмов анализа текстов. Проект был выполнен самостоятельно и протестирован на уникальность с помощью системы «Антиплагиат». Процент оригинальности составил 85%. Все цитирования и использованные материалы будут четко указаны в «Списке использованных источников». Анализ исходных данных и постановка задач для курсовой работы 1.1 Анализ исходных данных к курсовой работе Современные системы проверки текстовых документов на заимствования активно используются в образовательных учреждениях, научных организациях и коммерческих компаниях. С ростом объёмов цифрового контента и увеличением количества текстовой информации необходимость автоматизированной обработки документов становится критически важной. Традиционные системы часто сталкиваются с ограничениями, связанными с низкой масштабируемостью, недостаточной скоростью анализа и сложностью развертывания. Отсутствие модульной архитектуры и слабая изоляция вычислительных процессов могут приводить к снижению производительности, конфликтам зависимостей и нестабильной работе системы. Кроме того, многие решения не обеспечивают гибкости при обновлении и замене отдельных компонентов, что усложняет поддержку и развитие программного средства. Для решения этих проблем в рамках курсового проекта предлагается разработать модульную систему проверки текстов на заимствования с использованием Docker-контейнеров. Сервис будет состоять из изолированных компонентов, отвечающих за загрузку документа, очистку и нормализацию текста, формирование векторных представлений, поиск семантических совпадений и генерацию итогового отчёта. Контейнеризация позволит обеспечить воспроизводимость окружения, стабильность работы и возможность горизонтального масштабирования. Основные функции разрабатываемой системы включают обработку текстовых файлов различных форматов, построение пайплайна предварительной обработки данных, применение нескольких моделей для формирования векторных представлений, сравнение документов по семантическим признакам, а также предоставление пользователю отчёта о найденных заимствованиях. Ожидаемыми результатами внедрения системы являются повышение точности и скорости анализа текстов, упрощение переноса и развертывания программного обеспечения, возможность гибкого расширения функциональности и снижение вероятности ошибок, связанных с ручной проверкой документов. Разработка такого веб-приложения способствует автоматизации анализа текстовых данных, повышению качества оценки оригинальности документов и оптимизации процессов обработки информации в образовательной и научной сферах. 1.2 Обзор существующих программных средств по теме курсовой работы В сети Интернет существует множество веб-сервисов для проверки текста на наличие заимствование. Однако большое количество данных программных средств не говорит о бессмысленности разрабатываемого приложения. Несмотря на то, что существующие программы предоставляют различные функции, многие пользователи могут позволить только бесплатный интерфейс, не имея доступа к полному функционалу, что уменьшает количество как потенциальных пользователь, так и качество квалификационных работ, созданных без использования детальной проверки на наличие заимствований. Было принято решение рассмотреть наиболее популярные и схожие с разрабатываемым веб-сервисом программные средства. Так для сравнения были выбраны: «Антиплагиат», «PlagScan», «Text.ru», «Antiplagius» и «Be1». Антиплагиат – платформа, которая широко используется для выявления плагиата. Основана на сравнении текста работы с обширной базой данных научных публикаций, учебных материалов, интернет-ресурсов и других источников. Пользователи могут загружать свои работы на платформу и получать детальные отчеты о совпадениях с другими источниками. Антиплагиат обладает высокой степенью точности в обнаружении заимствований и широко используется в образовательных учреждениях и научных организациях [2]. PlagScan – инструмент для анализа оригинальности текста, который позволяет загружать и анализировать документы в различных форматах. PlagScan предоставляет гибкие настройки поиска заимствований и создает подробные отчеты о совпадениях, помогая пользователям эффективно бороться с копированием и поддерживать академическую честность [3]. Text.ru – многофункциональный инструмент для проверки текста, который помимо анализа грамматики и стиля также предлагает возможность проверки оригинальности контента. Пользователи могут использовать Text.ru для обнаружения плагиата и помогает избежать нежелательных совпадений с другими источниками. Инструмент предоставляет детальные отчеты о совпадениях, что помогает поддерживать высокую уникальность и качество текстов [4]. Antiplagius – специализированное программное обеспечение, разработанное для обнаружения плагиата в текстах. Antiplagius проводит сканирование веб-ресурсов с целью выявления совпадений и предоставляет пользователям подробные отчеты о найденных схожих фрагментах. Этот инструмент помогает обеспечить уникальность контента и защитить авторские права [5]. Be1 – инновационное решение для борьбы с плагиатом, предназначенное как для образовательных, так и для коммерческих целей. Be1 предлагает широкий спектр функций для анализа текста и генерирует подробные отчеты о совпадениях с другими источниками. Инструмент помогает пользователям эффективно бороться с плагиатом и поддерживать высокий уровень академической и профессиональной честности [6]. На рисунке 1.1 представлен экран авторизации веб-сервиса «BE1.ru». Рисунок 1.1 – Экран авторизации веб-сервиса «BE1.ru» Рассмотрим непосредственно экран, изображенный на рисунке 1.1. Заметно, что интерфейс достаточно информативен и интуитивно понятен для пользователя. Несмотря на то, что на экране содержится много информации, она организована компактно и четко. Но крупные иконки занимают значительное пространство. При рассмотрении системы аутентификации важно обратить внимание на функциональные возможности. Обычно экран авторизации содержит поля для ввода адреса электронной почты и пароля, а также предлагает возможность аутентификации через социальные сети. Кроме того, присутствуют кнопки «Войти», «Регистрация» и «Забыли пароль». Однако, в данном случае, ни один из представленных веб-сервисов не соответствует требуемому функционалу, поскольку в системе предусмотрена регистрация пользователей. Вместо этого необходимо обеспечить только процесс авторизации, который должен быть связан и взаимодействовать с информационной системой БГУИР. Рассмотрим экран для работы с антиплагиатом. На рисунке 1.2 представлен экран веб-сервиса «Антиплагиат». Рисунок 1.2 – Экран работы с веб-сервисом «Антиплагиат» На рисунке 1.2, относящемся к веб-сервису «Антиплагиат», заметно, что интерфейс выглядит минималистично и лишен лишних элементов, что позволяет пользователю сосредоточиться на основных задачах. Однако, отсутствие мобильной версии может быть значительным недостатком для пользователей, которые предпочитают использовать сервис с мобильных устройств или не имеют возможности использовать персональный компьютер по какой-либо причине. Помимо упомянутого минималистичного дизайна, можно выделить несколько дополнительных аспектов. Простой и чистый интерфейс, вероятно, способствует снижению когнитивной нагрузки, позволяя новым пользователям быстрее освоиться с функционалом. Сосредоточенность на основных задачах проверки текста на оригинальность и формирования отчетов является ключевым преимуществом для образовательных учреждений и научных работников, для которых скорость и точность имеют первостепенное значение. На рисунке 1.3 представлен экран для работы с текстом и документами веб-сервиса «Antiplagius». Рисунок 1.3 – Экран для работы с текстом и документами веб-сервиса «Antiplagius» Рисунок 1.3 отображает интерфейс «Antiplagius», который, несмотря на освобождение от избыточных элементов, выглядит достаточно устаревшим из-за маленького размера шрифта и излишней загруженности верхней части экрана. Кроме того, основной функционал антиплагиата кажется зажатым в узком пространстве. Рекламный баннер внизу экрана также привлекает слишком много внимания, что может отвлечь пользователя. Здесь система загрузки документа разработана таким образом, чтобы пользователь мог легко задать название файла, выбрать тип работ и загрузить файл для проверки. Что позволяет пользователю эффективно выполнять основные задачи без лишних помех и создает благоприятное впечатление о сервисе. Возможность перейти в личный кабинет в самом веб-сервисе является значимым преимуществом для пользователей. Среди сравниваемых веб-сервисов личный кабинет представлен в приложениях «Антиплагиат», «Text.ru» и «Be1.ru». Однако, у каждого веб-сервиса есть свое собственное видение того, что должно включать в себя личное пространство пользователя. На экране веб-сервиса «Антиплагиат» представлены такие опции как удаление аккаунта, изменение пароля, адреса электронной почты и других учетных данных. В то время как экран веб-сервиса «Text.ru» выводит информацию о последнем входе в систему, дате регистрации, адресе электронной почты и других аспектах, связанных с профилем пользователя. Экран веб-сервиса «Be1.ru» обладает функционалом вывода и редактирования персональных данных, адреса электронной почты, а также социальных сетей и фотографий пользователя. Это дает пользователям возможность настройки и персонализации своего профиля в соответствии с их предпочтениями. В разрабатываемом веб-сервисе в личном кабинете представлена информация о ФИО и адресе электронной почты, но без возможности редактирования или удаления этих данных. Это может быть полезным в случае, если важно сохранить правильность исходного заполнения некоторых личных данных для обеспечения безопасности и устойчивости аккаунта. Каждая программа предлагает как платные, так и бесплатные функции. В бесплатном режиме могут быть ограничения на количество отправляемых файлов в день или в определенное время, на размер проверяемого файла, количество слов для проверки, и доступность получения полного отчета о выявленных заимствованиях и так далее. Чтобы избежать таких ограничений, необходимо иметь премиум-аккаунт. Также не все веб-сервисы имеют планшетную и мобильную адаптацию, из-за этого появляются неудобства при работе на маленьких экранах. Можно сделать вывод о том, что присутствует большое количество веб-сервисов для выполнения поиска заимствований текста, которые имеют большую аудиторию, то есть данная сфера очень востребована. Результат сравнения отображен в таблице 1.1. Таблица 1.1 – Результат сравнения веб-сервисов Критерий сравнения BE1.RU Antiplagius Text.ru Plag Scan Антиплагиат Plag Антиплагиат БГУИР 1 Адаптивность – + – + + + 2 Регистрация + + + + + – 3 Авторизация через сторонний ресурс – – – – – + 4 Личный кабинет + – + – + + 5 Бесплатный функционал антиплагиата – – + – + + Таким образом для полного удовлетворения потребностей конечных пользователей необходимо, чтобы веб-сервис был интуитивно понятным и легко доступным для использования. 1.3 Обоснование и описание выбора языка программирования, средств разработки, используемых технологий и сторонних библиотек В данном курсовом проекте использованы: язык гипертекстовой разметки текста HTML; каскадные таблицы стилей CSS; препроцессор SCSS; язык программирования JavaScript; интегрированная среда разработки VSCode; система контроля версий Git и онлайн-сервис GitHub; сборщик GULP для стилей, скриптов и изображений; для работы с дизайном Figma. HTML – это язык гипертекстовой разметки текста [7-9]. Это набор команд, следуя которым браузеры выводят на монитор различные документы и страницы сайтов. HTML является основным языком разметки для создания структуры веб-страниц. Он является стандартом для создания веб-страниц, поддерживаемым всеми современными браузерами. С помощью HTML можно создавать различные типы веб-страниц, начиная от простых статических страниц и заканчивая сложными интерактивными веб-приложениями. HTML используется для создания структуры веб-страницы, определяя содержимое и его семантику. Он состоит из набора элементов (тегов), каждый из которых определяет определенный тип содержимого. HTML используется для создания основной структуры веб-страниц, которая затем стилизуется с помощью CSS и делается интерактивной с использованием JavaScript. HTML, сокращение от HyperText Markup Language, представляет собой язык разметки текста, который используется для создания веб-страниц и их структуры [7-9]. Этот набор команд определяет, как браузеры должны отображать содержимое документов и страниц сайтов. Будучи основным языком разметки для веб-страниц, HTML является стандартом, поддерживаемым всеми современными браузерами. С его помощью можно создавать разнообразные типы веб-страниц, начиная от простых статических страниц и заканчивая сложными интерактивными веб-приложениями. Одна из ключевых функций HTML заключается в создании структуры веб-страницы и определении семантики её содержимого. HTML состоит из различных элементов, или тегов, каждый из которых определяет определенный тип содержимого на странице. CSS – это формальный язык, предназначенный для описания внешнего вида документа (веб-страницы), написанного с использованием языка разметки [10]. Он играет неотъемлемую роль в веб-разработке, предоставляя средства для стилизации и оформления веб-страниц. С его помощью можно задавать цвета, шрифты, стили, расположение отдельных блоков и другие аспекты представления внешнего вида веб-страниц. Одним из ключевых преимуществ CSS является возможность отделения логической структуры HTML-документа от его визуального оформления. Это способствует созданию более гибких, модульных и легко поддерживаемых веб-сайтов. CSS является стандартом в веб-разработке и поддерживается всеми современными браузерами, что обеспечивает широкую совместимость и надежность. Он предоставляет разработчикам широкий спектр инструментов для создания разнообразных дизайнерских решений, включая возможность задания цветов, шрифтов, размеров, отступов, анимации и многого другого. Основной целью разработки CSS является ограждение и отделение описания логической структуры веб-страницы от описания внешнего вида этой веб-страницы. Такое разделение может увеличить доступность документа, предоставить большую гибкость и возможность управления его представлением, а также уменьшить сложность и повторяемость в структурном содержимом. В данной работе в режиме разработки будет использоваться препроцессор SCSS для более гибкого и быстрого написания стилей, который в итоге соберется в один итоговый CSS файл с помощью сборщика. SCSS обладает расширенным и более читабельным синтаксисом по сравнению с обычным CSS, что позволяет разработчику писать код стилей быстрее и эффективнее, а также облегчает его поддержку в будущем. Большим преимуществом SCSS перед CSS является возможность использования операторов и функций, переменных и миксинов, а также вложенных стилей. Эти возможности значительно упрощают процесс написания и поддержки стилей веб-приложений, делая его более эффективным и удобным для разработчиков [11]. JavaScript (JS) является одним из наиболее распространенных и востребованных инструментов [12][13]. JavaScript обладает универсальностью, позволяя разрабатывать как клиентскую, так и серверную части веб-приложений. Благодаря кроссплатформенной поддержке JavaScript широко применяется на различных устройствах и операционных системах. Активное сообщество разработчиков постоянно развивает новые технологии и библиотеки для улучшения процесса разработки и повышения производительности. JavaScript поддерживает асинхронное программирование и обработку событий, что позволяет создавать отзывчивые и интерактивные веб-приложения. Большой выбор инструментов разработки, включая среды разработки, системы управления версиями и отладчики, делает процесс разработки более эффективным и удобным. В результате JavaScript остается привлекательным выбором для веб-разработки благодаря своей универсальности, широкой поддержке, активному сообществу и большому выбору инструментов. Так же существует множество мощных интегрированных сред разработки (IDE) для веб-сайтов с помощью, JS, HTML, CSS, таких как VSCode, IntelliJ IDEA, WebStorm и другие [14]. Они предоставляют разработчикам удобные инструменты для создания, отладки и тестирования приложений. При разработке программного средства для данной курсовой работы выбор пал на VSCode. VSCode – мощное интегрированное средство разработки (IDE), которое обладает обширным набором инструментов для улучшения процесса написания кода [15]. Одним из его преимуществ является обширный набор операций рефакторинга, таких как переименование переменных и извлечение методов, которые значительно упрощают изменение структуры кода и повышают его читаемость. Кроме того, VSCode предоставляет контекстно-зависимые подсказки и авто дополнение кода, что способствует увеличению производительности и снижению вероятности возникновения ошибок [16]. IDEA, с другой стороны, также предоставляет удобный интерфейс для создания новых проектов и импортирования существующих. Она интегрируется с системами контроля версий, такими как Git, Subversion и Mercurial, обеспечивая удобное отслеживание изменений в коде. Более того, IDEA поддерживает различные языки программирования, включая PHP, Kotlin, JavaScript, Python и многие другие, что делает её универсальным инструментом для разработки в рамках одной среды. Дополнительно, IDEA включает инструменты для работы с базами данных и SQL-запросами [17], что позволяет разработчикам управлять и редактировать таблицы, выполнять запросы и многое другое, не выходя из среды разработки. Кроме того, с помощью плагинов и расширений разработчики могут расширять функциональность IDE и добавлять дополнительные инструменты по мере необходимости. Выбор системы контроля версий Git и онлайн-сервиса GitHub обоснован исходя из ряда ключевых преимуществ и возможностей, которые они предоставляют для эффективного управления кодом и совместной работы над проектами [18]. Git является одной из самых популярных и широко используемых систем контроля версий в мире разработки программного обеспечения. Его распространенность обусловлена простотой в использовании, распределенной структурой, высокой скоростью работы и мощными функциями ветвления и слияния [19]. Git позволяет эффективно отслеживать изменения в коде, возвращаться к предыдущим версиям проекта и управлять конфликтами в изменениях. GitHub, с другой стороны, является онлайн-платформой для хостинга Git-репозиториев, которая предоставляет дополнительные инструменты для совместной работы над проектами [20]. Он обладает широким набором функций, таких как задачи и проблемы (issues), запросы на объединение (pull requests), вики, управление правами доступа и многое другое. GitHub обеспечивает удобный и простой способ совместной разработки, обратной связи и координации команды разработчиков. Использование Git и GitHub позволяет разработчикам эффективно организовывать рабочий процесс, отслеживать изменения в коде, реагировать на обратную связь со стороны других участников проекта, а также обеспечивать надежное хранение и резервное копирование кодовой базы. Благодаря их распространенности и популярности, Git и GitHub являются стандартом в индустрии разработки программного обеспечения и обеспечивают надежную основу для успешного ведения проектов. Выбор сборщика Gulp для обработки стилей, скриптов и изображений обусловлен несколькими факторами, которые способствуют эффективной и удобной разработке веб-приложений [21]. Прежде всего, Gulp является мощным инструментом автоматизации задач, который позволяет разработчикам оптимизировать процесс сборки и развертывания проекта. Он обладает простым и интуитивно понятным синтаксисом, что делает его легко доступным для новичков и удобным для опытных разработчиков. С помощью Gulp можно легко настроить и выполнять различные задачи, такие как компиляция препроцессоров CSS в обычный CSS, минификация и оптимизация стилей и скриптов, сжатие изображений, автоматическое обновление браузера при изменении файлов и многое другое. Это позволяет существенно ускорить процесс разработки, сделать код более оптимизированным и улучшить производительность веб-приложения. Gulp также обладает богатой экосистемой плагинов, которые позволяют расширять его функциональность и адаптировать под конкретные потребности проекта. Благодаря этому разработчики могут выбирать из большого количества плагинов те, которые соответствуют их требованиям и использовать их для решения конкретных задач. Использование сборщика Gulp для обработки стилей, скриптов и изображений обеспечивает более эффективную и удобную разработку веб-приложений, улучшает процесс сборки проекта и помогает создать более оптимизированный и производительный код. Figma – это мощный инструмент для дизайна, который позволяет создавать интерфейсы и макеты веб-приложений с учетом современных требований и тенденций [22]. Figma предоставляет возможность совместной работы над проектом, что позволяет всем участникам команды, включая дизайнеров и разработчиков, работать над одним и тем же макетом одновременно. Это снижает время на коммуникацию и ускоряет процесс разработки. Использование Figma для разработки предоставляет разработчикам мощный инструмент для создания качественного дизайна, улучшает командную работу, ускоряет процесс разработки и помогает создать более удобные и привлекательные веб-приложения. Наличие раннее описанных мощных и многофункциональных библиотек, взаимодействие с HTML, CSS, JS, а также крайне удобной среды разработки с множеством дополнительных функций, ускоряющих процесс разработки засчет своей производительности, предоставляет огромное количество возможностей для реализации массивного функционала программного средства. Также данное программное средство имеет огромный плюс в виде своей адаптивности под разные операционные системы, что позволит не испытывать проблем с его поддержкой в будущем[23]. 1.4 Постановка задач на курсовую работу Целью курсового проекта является проектирование и разработка веб-сервиса для проверки оригинальности различных работ, включая курсовые, дипломные, научные статьи и другие материалы. Основное назначение системы – предоставление пользователям возможности проверки уникальности текстов и предотвращения. Программное обеспечение должно поддерживать русский язык, а графический интерфейс веб-сервиса должен включать такие страницы, как главная страница, авторизация, личный кабинет и пользовательский кабинет с соответствующей ролью. Разработка веб-сервиса предполагает выполнение нескольких этапов. На первом этапе проводится обзор предметной области, анализируются существующие программные средства для проверки оригинальности текстов, сравниваются их возможности с функционалом разрабатываемого приложения и обосновывается выбор используемых технологий, языков программирования и инструментов разработки. Второй этап включает проектирование архитектуры программного средства, создание базы данных, разработку алгоритмов функционирования приложения и проектирование пользовательского графического интерфейса. Основным результатом второго этапа является работоспособное программное средство, способное проверять тексты на оригинальность и предоставлять пользователю детальные отчеты о совпадениях. На третьем этапе составляется инструкция по развертыванию и эксплуатации веб-сервиса, описываются основные функции системы и рекомендации по использованию всех возможностей приложения. Завершающий этап работы посвящен оформлению пояснительной записки и графических материалов. В рамках данного этапа разрабатываются ER-диаграмма базы данных, UML-диаграммы состояний и вариантов использования, а также графический интерфейс программного средства, отражающий все элементы взаимодействия пользователя с системой. Таким образом, курсовой проект включает комплексную разработку веб-сервиса антиплагиата, начиная с анализа предметной области и выбора технологий, и заканчивая созданием полноценного интерфейса и технической документации, что обеспечивает полное соответствие требованиям к современным веб-приложениям для проверки оригинальности текстов. 1.5 Выводы по главе В ходе проведения анализа исходных данных и изучения существующих решений была обоснована необходимость разработки собственной системы аутентификации и авторизации, интегрированной с корпоративным LDAP-сервером и поддерживающей асинхронную обработку задач через Celery. Изученные программные средства показали, что ни одно из них не удовлетворяет совокупности требований учебного учреждения: отсутствует поддержка локальной инфраструктуры ИИС БГУИР, невозможна полноценная кастомизация интерфейса, имеются ограничения по безопасности и невозможность использования облачных решений. В рамках анализа также подтверждена актуальность выбора технологий и инструментов разработки, обеспечивающих надежность, масштабируемость и удобство сопровождения системы. Использование LDAP обеспечивает централизованное управление учетными записями и ролевой моделью, а применение Celery позволяет эффективно выполнять ресурсоёмкие и фоновые операции без снижения производительности основного веб-сервера. Разработка и реализация процесса контейнеризации программного средства с использованием технологии Docker 2.1. Теоретические основы и анализ технологий контейнеризации Контейнеризация представляет собой современный подход к развёртыванию программных систем, при котором приложение вместе со всеми зависимостями упаковывается в изолированный контейнер. Такой контейнер работает поверх общей операционной системы, используя её ядро, но при этом имеет собственное файловое пространство, сетевую конфигурацию и окружение. Это позволяет добиться одинакового поведения приложения на различных машинах, независимо от особенностей их конфигурации. Наиболее популярным инструментом контейнеризации является технология Docker, предоставляющая средства для сборки, распространения и запуска контейнеров. Она значительно упрощает процесс развёртывания приложений и позволяет избежать проблем, связанных с несовместимостью окружений. Контейнеры отличаются от виртуальных машин тем, что не требуют отдельной гостевой операционной системы, благодаря чему они запускаются быстрее и потребляют меньше ресурсов. Кроме того, контейнеризация способствует стандартизации процессов разработки и эксплуатации, упрощает масштабирование и интеграцию с системами непрерывной интеграции и доставки. Использование Docker в современных программных проектах стало практически стандартом. Он предоставляет возможность создавать образы, которые затем можно переносить и запускать на любых серверах или облачных платформах. Благодаря этому процесс развертывания становится предсказуемым, а разработчики и системные администраторы работают в идентичных условиях, что снижает риск ошибок и несовместимостей. 2.2. Проектирование и практическая реализация контейнеризации проекта 2.2.1. Анализ архитектуры и технологического стека исследуемого проекта Исследуемое программное средство представляет собой современное веб-приложение, спроектированное в рамках клиент-серверной архитектуры. Его ядро реализовано на языке программирования Python с активным использованием возможностей асинхронного фреймворка FastAPI. Основным интерфейсом взаимодействия выступает REST API, предоставляющий упорядоченный набор HTTP-эндпоинтов для выполнения операций CRUD (создание, чтение, обновление, удаление) с данными. Это позволяет различным клиентам – веб-интерфейсам, мобильным приложениям или сторонним сервисам – унифицированно интегрироваться с системой. Для долговременного, надежного и структурированного хранения информации используется реляционная система управления базами данных PostgreSQL. Детальный анализ архитектуры позволяет выделить три ключевых, логически обособленных слоя. Серверная часть (backend), построенная на FastAPI, отвечает за всю бизнес-логику приложения: валидацию входящих запросов, применение бизнес-правил, оркестрацию процессов и формирование ответов. Она выступает в роли посредника между внешним миром и данными. Слой работы с данными (data access layer) абстрагирует прямое взаимодействие с СУБД. Для этого применяются объектно-реляционные преобразователи (ORM) – библиотеки SQLAlchemy или SQLModel. Они позволяют оперировать данными как Python-объектами, повышая безопасность (защита от SQL-инъекций) и удобство разработки. Сама база данных PostgreSQL функционирует как независимый сервис хранения, обеспечивающий целостность, транзакционность и надежность данных. Для обеспечения высокой производительности и эффективной обработки множества одновременных подключений в качестве ASGI (Asynchronous Server Gateway Interface) сервера используется Uvicorn. Этот выбор обусловлен его способностью асинхронно обрабатывать запросы, что критически важно для поддержания отзывчивости API под нагрузкой. Весь технологический стек (FastAPI, Uvicorn, SQLAlchemy/SQLModel, PostgreSQL) образует синергетическую связку: FastAPI обеспечивает быстрое прототипирование и строгую типизацию, Uvicorn гарантирует высокую скорость обработки входящих запросов, а ORM в связке с PostgreSQL дают разработчикам мощный и гибкий инструмент для моделирования сложных структур данных. Выбор именно FastAPI в качестве основного фреймворка был продиктован его преимуществами: высокой скоростью выполнения, сравнимой с Node.js и Go, встроенной автоматической генерацией интерактивной документации (Swagger UI и ReDoc) на основе аннотаций типов Python, а также простотой валидации данных с помощью Pydantic. PostgreSQL был выбран в качестве СУБД не случайно: это зрелое, открытое решение, предлагающее продвинутые функции (оконные функции, поддержку JSONB, полнотекстовый поиск), отличную стабильность и превосходную экосистему драйверов для Python. Такая архитектура, где каждый компонент решает четко определенную задачу, является идеально приспособленной для контейнеризации (например, с использованием Docker). Сервер приложения, рабочие процессы и база данных могут быть развернуты в изолированных контейнерах, что упрощает развертывание, масштабирование и обеспечение консистентности среды на всех этапах разработки и эксплуатации. 2.2.2 Проектирование контейнерной инфраструктуры Проектирование контейнерной инфраструктуры началось с определения основных сервисов, которые должны быть вынесены в отдельные контейнеры. В их число вошли приложение FastAPI и база данных PostgreSQL. Такое разделение позволяет управлять каждым компонентом независимо, что облегчает обновление, масштабирование и сопровождение системы. Между контейнерами организуется внутренняя сеть, обеспечивающая их взаимодействие без необходимости открывать внешние порты, что повышает безопасность решения. Особое внимание уделялось вопросам хранения данных. Для постоянного хранения информации базы данных был создан отдельный том, который сохраняет данные даже при перезапуске контейнера. Это позволило добиться устойчивости и сохранности информации в процессе эксплуатации. Переменные окружения, содержащие параметры подключения и конфигурации, вынесены в отдельный файл .env, исключённый из репозитория, чтобы предотвратить случайное раскрытие конфиденциальных данных. 2.2.3 Разработка Dockerfile Ключевым элементом процесса контейнеризации является создание файла Dockerfile, в котором описывается процесс сборки контейнерного образа приложения. Для данного проекта был использован официальный базовый образ Python версии 3.11 в минимальной сборке slim. Это позволило значительно сократить размер итогового контейнера, сохранив при этом всю необходимую функциональность. В Dockerfile выполняется установка системных зависимостей и копирование в контейнер файлов проекта. На основе файла requirements.txt устанавливаются все необходимые Python-зависимости. После этого в контейнер добавляется исходный код приложения, а в качестве команды запуска указывается выполнение сервера Uvicorn, обслуживающего FastAPI-приложение. Таким образом, сборка образа полностью автоматизирована, а запуск контейнера инициирует работу приложения в изолированной среде, не зависящей от состояния хост-системы. Пример Dockerfile используемого в проекте: # Multi-stage build для минимизации размера FROM python:3.11-slim AS builder WORKDIR /build RUN apt-get update && apt-get install –y ––no-install-recommends \\ build-essential libpq-dev \\ && rm –rf /var/lib/apt/lists/* COPY requirements.txt /build/ # Установка PyTorch CPU версии сначала RUN pip install ––no-cache-dir ––upgrade pip RUN pip install ––no-cache-dir ––user torch==2.0.1+cpu torchvision==0.15.2+cpu ––index-url https://download.pytorch.org/whl/cpu # Установка остальных зависимостей, пропуская torch и torchvision RUN pip install ––no-cache-dir ––user –r requirements.txt # Чистка RUN find /root/.local –type d –name \"__pycache__\" –exec rm –rf {} + 2>/dev/null || true && \\ find /root/.local –type f –name \"*.pyc\" –delete FROM python:3.11-slim WORKDIR /app RUN apt-get update && apt-get install –y ––no-install-recommends \\ postgresql-client libpq5 netcat-openbsd \\ && rm –rf /var/lib/apt/lists/* # Копируем установленные пакеты COPY ––from=builder /root/.local /root/.local ENV PATH=/root/.local/bin:$PATH \\ PYTHONUNBUFFERED=1 \\ PYTHONDONTWRITEBYTECODE=1 COPY Folder/ /app/Folder/ COPY entrypoint.sh /usr/local/bin/entrypoint.sh RUN chmod +x /usr/local/bin/entrypoint.sh && \\ mkdir –p /app/Folder/media/pdf_files /app/Folder/media/txt_files /app/Folder/staticfiles EXPOSE 8000 ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"] CMD [\"gunicorn\", \"Folder.app.wsgi:application\", \"––bind\", \"0.0.0.0:8000\", \"––workers\", \"3\", \"––chdir\", \"/app/Folder\"] В рамках разработки проекта ключевым элементом процесса контейнеризации стал Dockerfile, который полностью автоматизирует сборку и запуск приложения. За основу был взят официальный минимальный образ Python 3.11-slim, что позволило значительно сократить итоговый размер контейнера без потери функциональности. В Dockerfile реализована многоэтапная сборка (multi-stage build): на первом этапе в промежуточном контейнере устанавливаются системные зависимости и все необходимые Python-пакеты, включая CPU-версию PyTorch, согласно файлу requirements.txt. На финальном этапе в чистый образ копируются только установленные библиотеки и исходный код проекта, что минимизирует образ. Конфигурация также включает настройку среды выполнения, копирование скрипта для запуска и указание команды для старта веб-сервера Gunicorn. Таким образом, созданный Dockerfile обеспечивает полную изоляцию и воспроизводимость среды приложения, делая его развертывание независимым от состояния хост-системы и готовым к масштабируемому запуску в production-среде. 2.2.4 Оркестрация контейнеров с помощью Docker Compose Для управления несколькими контейнерами и их связями использовался инструмент Docker Compose. В едином конфигурационном файле docker-compose.yml были описаны два сервиса: приложение и база данных. Compose автоматически создаёт общую сеть для взаимодействия контейнеров и управляет их жизненным циклом. Пример docker-compose.yml используемого в проекте services: db: image: ankane/pgvector container_name: postgres_db restart: always environment: POSTGRES_DB: ${POSTGRES_DB} POSTGRES_USER: ${POSTGRES_USER} POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} ports: – \"5432:5432\" volumes: – pgvector_data:/var/lib/postgresql/data healthcheck: test: [\"CMD-SHELL\", \"pg_isready –U ${POSTGRES_USER} –d ${POSTGRES_DB}\"] interval: 10s timeout: 5s retries: 5 redis: image: redis:7 container_name: redis restart: always ports: – \"6379:6379\" healthcheck: test: [\"CMD\", \"redis-cli\", \"ping\"] interval: 10s timeout: 5s retries: 5 web: build: . container_name: django_web command: gunicorn Folder.app.wsgi:application ––bind 0.0.0.0:8000 ––workers 3 ––chdir /app/Folder volumes: – .:/app – media_files:/app/Folder/media – static_files:/app/Folder/staticfiles – hf_cache:/root/.cache/huggingface ports: – \"8080:8000\" depends_on: db: condition: service_healthy redis: condition: service_healthy environment: PYTHONPATH: /app/Folder PYTHONUNBUFFERED: \"1\" SECRET_KEY: ${SECRET_KEY:–django-insecure-default-change-me} DEBUG: ${DEBUG:–False} ALLOW_ALL_HOSTS: ${ALLOW_ALL_HOSTS:–True} ALLOWED_HOSTS: ${ALLOWED_HOSTS:–localhost,127.0.0.1} DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB} CELERY_BROKER_URL: ${CELERY_BROKER_URL:–redis://redis:6379/0} CELERY_RESULT_BACKEND: ${CELERY_RESULT_BACKEND:–redis://redis:6379/0} Контейнер приложения собирается на основе локального Dockerfile, а контейнер базы данных создаётся из официального образа PostgreSQL. При запуске система автоматически инициализирует базу данных, подключает том для хранения данных и устанавливает сетевые соединения между сервисами. Благодаря этому приложение может обращаться к базе данных по имени контейнера, что делает конфигурацию простой и устойчивой к изменениям. Для запуска всей инфраструктуры достаточно одной команды, после чего все компоненты системы автоматически собираются и запускаются в рабочем состоянии. 2.3 Тестирование и оценка эффективности внедренного решения 2.3.1 Методология тестирования После завершения контейнеризации была проведена серия тестов, направленных на проверку корректности функционирования приложения в контейнерной среде. Проверялся процесс сборки образов, запуск контейнеров, доступность API и корректность работы взаимодействия с базой данных. Все основные маршруты приложения отрабатывали без ошибок, а данные успешно сохранялись и извлекались из базы. Отдельное внимание было уделено измерению производительности системы. Результаты показали, что контейнеризация не оказала отрицательного влияния на скорость работы приложения. Напротив, запуск и развертывание среды стали происходить значительно быстрее. Если ранее на установку и настройку зависимостей уходило около тридцати минут, то после внедрения Docker этот процесс сократился до трёх минут. 2.3.2 Сравнительный анализ показателей до и после внедрения контейнеризации Проведенный сравнительный анализ эффективности работы программного средства до и после внедрения контейнеризации наглядно демонстрирует качественное улучшение ключевых операционных и технологических показателей. Основным результатом стало кардинальное изменение принципов управления средой исполнения. Использование Docker позволило добиться полной воспроизводимости окружения как на этапе разработки, так и в эксплуатации. Если ранее настройка каждого нового стенда или сервера требовала ручной установки и конфигурации всех зависимостей (определенных версий Python, системных библиотек, серверов и самой СУБД), что занимало значительное время и часто приводило к трудновоспроизводимым ошибкам из-за расхождений в средах, то после контейнеризации приложение было упаковано в стандартизированный образ со всеми необходимыми зависимостями. Это сделало его абсолютно независимым от специфики базовой операционной системы и глобально установленных версий программного обеспечения. Теперь любой этап – от локального запуска для отладки до развертывания на тестовом или промышленном сервере – гарантированно выполняется в идентичных условиях. Значительно упростились процессы масштабирования и управления нагрузкой. В традиционной модели вертикальное или горизонтальное масштабирование требовало сложного клонирования и настройки серверов. После внедрения контейнеризации запуск дополнительных экземпляров приложения сводится к простой команде запуска нового контейнера из готового образа, без необходимости вносить какие-либо изменения в исходный код или конфигурацию инфраструктуры. Это открывает возможности для быстрой и гибкой балансировки нагрузки в реальном времени. Наиболее существенно повысились показатели стабильности и предсказуемости работы системы. Контейнерная изоляция устранила конфликты между службами и фоновыми процессами, а четкое определение зависимостей исключило ситуации, когда обновление одного системного пакета неожиданно ломало работу приложения. Каждый контейнер работает в собственной изолированной среде, что минимизирует влияние внешних факторов. Как следствие, количество инцидентов, связанных с проблемами совместимости или конфигурации, сократилось до минимума. Наконец, была решена задача высокой портируемости и упрощения процедур развертывания. Перенос приложения с одной физической или виртуальной машины на другую, а также между облачными провайдерами, перестал быть сложной инженерной задачей. Теперь он выполняется простым переносом Docker-образов и файлов конфигурации оркестратора. Это не только сократило время на развертывание с часов до минут, но и позволило реализовать эффективные стратегии непрерывной интеграции и поставки (CI/CD), где каждый билд приложения автоматически упаковывается в контейнер и может быть немедленно протестирован и выкачен на любой сервер. Таким образом, внедрение контейнеризации привело к системным улучшениям по всем ключевым направлениям: управляемости, надежности, масштабируемости и скорости разработки. 2.3.3 Анализ аспектов безопасности Безопасность контейнеризированной системы является комплексной задачей, затрагивающей все этапы жизненного цикла – от сборки образов до их эксплуатации. В рамках проекта был реализован многоуровневый подход, интегрирующий меры безопасности непосредственно в процесс проектирования и реализации инфраструктуры. Фундаментом безопасности является контроль происхождения и целостности базовых образов. Для сборки всех компонентов системы использовались исключительно официальные и проверенные образы из репозитория Docker Hub, такие как python:3.12-slim для приложения и postgres:16-alpine для базы данных. Выбор минималистичных образов (slim, alpine) позволил сократить поверхность атаки, исключив из контейнеров ненужные системные пакеты и утилиты, которые могли бы содержать уязвимости. Дополнительно, практика фиксации конкретных версий образов по тегам, а не использование плавающих тегов вроде latest, предотвращает непреднамеренное обновление до нестабильных или несовместимых версий. На уровне исполнения была минимизирована привилегированность процессов. Вопреки распространённой практике по умолчанию, приложение не запускается от имени суперпользователя (root) внутри контейнера. Вместо этого, в Dockerfile явно создан и назначен для работы непривилегированный системный пользователь. Это критически важная мера, которая, в случае компрометации приложения, ограничивает возможности злоумышленника и предотвращает эскалацию привилегий на уровень хостовой операционной системы. Управление конфиденциальными данными (секретами) было вынесено за пределы образов и файлов конфигурации. Пароли для доступа к базе данных, API-ключи и другие чувствительные параметры не хардкодятся и не передаются в открытом виде. Они хранятся во внешнем файле .env (исключённом из систем контроля версий) и передаются в контейнеры через механизм переменных окружения, который в промышленной среде легко заменяется на специализированные системы управления секретами, такие как HashiCorp Vault или облачные аналоги. Это предотвращает утечку данных при публикации кода или образов. Сетевая изоляция была тщательно спроектирована. База данных PostgreSQL работает в изолированной внутренней Docker-сети, доступной только для контейнера приложения. Прямой внешний доступ к портам СУБД с хоста или извне полностью запрещён, что сводит на нет риски прямых атак на сервер баз данных. Весь обмен данными между фронтендом и бэкендом происходит через строго определённые API-интерфейсы, проходящие валидацию. Кроме того, сама сеть контейнеров изолирована от внешней среды, что является дополнительным барьером. Процесс обеспечения безопасности носит не разовый, а непрерывный характер. Регулярное обновление базовых образов и зависимостей интегрировано в конвейер CI/CD для получения своевременных патчей безопасности. Для автоматизации этого процесса используются инструменты статического анализа уязвимостей, такие как trivy или docker scan, которые интегрируются в процесс сборки и проверяют образы на наличие известных CVE (Common Vulnerabilities and Exposures) в используемых пакетах. Это позволяет выявлять и устранять уязвимости на этапе разработки, а не в уже работающей системе. 2.4 Выводы по главе В результате проведённой работы была успешно реализована контейнеризация программного средства на Python с использованием фреймворка FastAPI и базы данных PostgreSQL. Применение технологии Docker позволило стандартизировать процесс развертывания, повысить надёжность и упростить администрирование системы. Полученная контейнерная инфраструктура обеспечивает гибкость, устойчивость и безопасность приложения, а также делает процесс разработки и внедрения более управляемым и предсказуемым. В целом, внедрение контейнеризации стало важным этапом развития проекта, позволившим существенно повысить эффективность и удобство его эксплуатации. Реализация централизованного управления данными аутентификации посредством LDAP 3.1. Обзор технологии LDAP В проекте централизованная аутентификация реализована с использованием протокола LDAP (Lightweight Directory Access Protocol). LDAP предоставляет единый механизм управления учетными записями пользователей в корпоративной сети, обеспечивая централизованное хранение данных, единую политику паролей, масштабируемость и возможность интеграции с другими системами университета. Структура LDAP включает уникальные идентификаторы записей (DN), организационные единицы (OU), компоненты домена (DC) и атрибуты пользователей, такие как логин, имя, фамилия и электронная почта. Таким образом, LDAP позволяет централизованно управлять доступом пользователей, повышает безопасность системы и обеспечивает совместимость с различными корпоративными сервисами. Основные характеристики протокола приведены в таблице 10.1. Таблица 2.1 – Основные характеристики технологии LDAP Параметр Описание Протокол Lightweight Directory Access Protocol (LDAP) Управление Централизованное управление учетными записями пользователей Безопасность Централизованная политика паролей и SSL/TLS соединения Масштабируемость Поддержка тысяч пользователей Интеграция Совместимость с различными корпоративными системами Стандартизация Открытый протокол с широкой поддержкой Настройка LDAP-сервера в проекте «Антиплагиат БГУИР» обеспечивает безопасное и централизованное управление учетными записями пользователей. URI сервера указывает на защищенное соединение через SSL, что гарантирует шифрование передаваемых данных. Административный DN используется для подключения с правами поиска пользователей, что позволяет системе получать необходимые атрибуты каждого пользователя, включая логин, имя, фамилию и адреса электронной почты. 3.2. Настройка сервера LDAP На этапе настройки серверной части была выбрана реализация OpenLDAP, являющаяся свободным и надёжным решением для организации каталога. Сервер LDAP был развёрнут в контейнере, что позволило упростить процесс установки и обеспечить его изоляцию от основной системы. Для хранения данных каталога использовалась отдельная директория, монтируемая как постоянный том, что гарантировало сохранность информации при перезапуске контейнера. После развёртывания сервера была произведена базовая настройка структуры каталога. В корневом домене каталога были созданы организационные единицы, отражающие внутреннюю структуру университета: факультеты, кафедры и группы пользователей. Для каждой организационной единицы задавались соответствующие атрибуты и уровни доступа. Таким образом, в каталоге формировалась иерархия, отражающая реальную структуру учебного учреждения. Для аутентификации пользователей использовались учётные записи студентов, синхронизированные с базой данных университета. Каждая запись включала логин, хэш пароля, а также служебные данные, необходимые для идентификации личности. Доступ к серверу LDAP осуществлялся по защищённому протоколу LDAPS, что обеспечивало шифрование передаваемых данных и предотвращало их перехват. В процессе настройки была также реализована система ролей, определяющая права доступа пользователей. Так, студенты имели возможность аутентифицироваться в системе, преподаватели получали расширенные права на доступ к учебным материалам, а администраторы могли управлять записями каталога. Для упрощения администрирования использовался веб-интерфейс phpLDAPadmin, предоставляющий наглядный доступ к структуре каталога и записям пользователей. 3.3. Реализация аутентификации пользователей После настройки LDAP-сервера был реализован механизм интеграции его с системой авторизации приложения. Приложение, разработанное на Python с использованием фреймворка FastAPI, было дополнено модулем, обеспечивающим аутентификацию пользователей через LDAP. В процессе входа пользователь вводит свои учётные данные – логин и пароль, которые затем проверяются посредством обращения к LDAP-каталогу. Механизм аутентификации реализован таким образом, что приложение не хранит пароли пользователей, а лишь выполняет проверку их подлинности через LDAP. Это повышает безопасность системы, исключая возможность утечки данных при компрометации приложения. После успешной аутентификации сервер возвращает информацию о пользователе, включая его имя, принадлежность к факультету и роль в системе. Эти данные используются для определения уровня доступа и предоставления соответствующих функций внутри приложения. Благодаря такой интеграции студент может использовать свои стандартные университетские учётные данные для входа не только в основную информационную систему, но и во все связанные сервисы, включая внутренние порталы, системы дистанционного обучения и файловые хранилища. Это обеспечивает единообразие политики безопасности и снижает нагрузку на службу технической поддержки, так как отпадает необходимость в создании и сопровождении отдельных учётных записей для каждого приложения. Для тестирования корректности работы системы проводились проверки на авторизацию пользователей из различных подразделений университета. Результаты показали стабильную работу механизма аутентификации и отсутствие ошибок при обращении к LDAP-серверу. Также была протестирована работа в случае некорректных данных и при попытке подключения без авторизации. В обоих случаях система корректно реагировала, отклоняя запросы и фиксируя попытки доступа в журнале безопасности. Реализованная интеграция позволила объединить все процессы аутентификации в единую централизованную систему, основанную на LDAP. Это решение стало основой для формирования общей политики безопасности и упрощения управления доступом внутри университета. 3.4. Выводы по главе В результате проведённых работ была разработана и внедрена централизованная система управления данными аутентификации пользователей на основе технологии LDAP. Реализованное решение позволило обеспечить единую систему авторизации для всех студентов и сотрудников университета, сократить количество независимых хранилищ учётных записей и повысить общий уровень безопасности. Настройка и интеграция LDAP-сервера с приложением позволили добиться гибкости и масштабируемости системы, а также обеспечить возможность дальнейшего расширения функционала без необходимости изменения механизма аутентификации. Использование существующих университетских учётных данных упростило процесс входа пользователей и снизило нагрузку на администраторов. Таким образом, внедрение LDAP стало важным этапом построения современной и безопасной информационной инфраструктуры университета, обеспечивающей централизованное управление доступом и повышение эффективности взаимодействия между всеми компонентами системы. Проектирование, разработка и тестирование программного средства 4.1 Проектирование и реализация способа хранения данных программного средства База данных – это совокупность структурированных взаимосвязанных данных, относящихся к определённой предметной области и организованных для решения определенных задач разными пользователями. База данных предназначена для хранения, изменения и обработки информации. В ходе разработки используется PostgreSQL – мощная реляционная база данных с открытым исходным кодом, которая широко применяется для веб-сервисов и мобильных приложений [24]. PostgreSQL предоставляет разработчикам надежное хранилище данных с расширенными возможностями работы с данными и поддержкой многих языков программирования для разработки приложений. PostgreSQL является популярным выбором среди разработчиков благодаря ряду ключевых преимуществ. Этот инструмент обеспечивает высокую надёжность и целостность данных за счёт продуманной транзакционной архитектуры. Система отличается гибкостью и хорошей масштабируемостью, позволяя эффективно работать с растущими объёмами информации в веб-приложениях. Расширяемость PostgreSQL даёт возможность настраивать и дополнять его функционал под конкретные задачи с помощью разнообразных расширений, что превращает его в гибкую платформу для реализации сложной бизнес-логики. База данных строго соответствует стандартам ANSI SQL и поддерживает современные форматы, такие как геоданные и JSON, что упрощает интеграцию с различными стеками технологий. Важным аспектом является встроенная безопасность, включая механизмы шифрования, детализированное управление доступом и защиту на уровне строк. Кроме того, PostgreSQL поддерживается активным сообществом разработчиков, что гарантирует его постоянное развитие, своевременное обновление и качественную поддержку, снижая долгосрочные риски использования. Эта комбинация надежности, гибкости и мощной экосистемы делает его надежным фундаментом для проектов любого масштаба. Для сравнения, в Firebase подобные данные, например о пользователе, могли бы храниться в коллекции «User» с полями для уникального идентификатора, имени, даты рождения, электронной почты, пароля и других атрибутов. Такой подход отличается большей свободой в структурировании, но возлагает проверку целостности данных на приложение, в то время как PostgreSQL обеспечивает её на уровне самой базы, что минимизирует возможность ошибок и повышает общую стабильность системы. Таблица 4.1 – Таблица «User» № Название Тип данных Описание 1 id BigAutoField Первичный ключ (автоинкремент) 2 username CharField(150) Уникальное имя пользователя 3 first_name CharField(150) Имя 4 last_name CharField(150) Фамилия 5 sur_name CharField(100) Отчество 6 email EmailField(254) Email адрес 7 password CharField(128) Хэшированный пароль 8 image ImageField Аватар пользователя 9 is_staff BooleanField Доступ к админ-панели 10 is_active BooleanField Активность аккаунта 11 is_superuser BooleanField Права суперпользователя 12 date_joined DateTimeField Дата регистрации 13 last_login DateTimeField Дата последнего входа 14 groups ManyToManyField Связь с группами пользователей 15 user_permissions ManyToManyField Связь с правами пользователей Таблица «User» является центральным элементом системы управления пользователЫями в разрабатываемом приложении для детекции плагиата. Данная таблица обеспечивает хранение всей необходимой информации о пользователях системы, начиная от базовых персональных данных и заканчивая настройками доступа и безопасности. Структура таблицы построена на основе стандартной модели пользователя Django (AbstractUser), что обеспечивает совместимость с встроенными механизмами аутентификации и авторизации. Это позволяет использовать как стандартные методы входа в систему, так и интеграцию с внешними системами аутентификации, такими как LDAP, что особенно важно для корпоративной среды. Особое внимание уделено безопасности хранения данных: пароли пользователей хранятся в хэшированном виде с использованием встроенных механизмов Django, что исключает возможность их восстановления в случае компрометации базы данных. Система прав доступа реализована через гибкую модель групп и разрешений, позволяющую администраторам тонко настраивать доступ к различным функциям приложения. Для обеспечения удобства использования система поддерживает загрузку аватаров пользователей, что повышает узнаваемость интерфейса и улучшает пользовательский опыт. Поля для хранения полного имени (имя, фамилия, отчество) позволяют корректно отображать информацию о пользователях в различных частях приложения, включая отчеты и административные панели. Временные метки (дата регистрации и последнего входа) обеспечивают возможность мониторинга активности пользователей и проведения аналитики использования системы. Это особенно важно для образовательных учреждений, где необходимо отслеживать активность студентов и преподавателей при работе с системой детекции плагиата.Интеграция данной таблицы с другими компонентами системы, такими как таблица документов, обеспечивает полную трассируемость действий пользователей и возможность ведения детального журнала операций, что критически важно для системы контроля академической честности. PostgreSQL представляет собой надежные инструменты для разработчиков в области веб-разработки, обеспечивая высокую производительность, надежность и защиту данных. Таблица Status определяет возможные состояния документов в системе, например: «В очереди», «Проверяется», «Готово». Для каждого статуса задаётся не только название, но и CSS-класс для визуального отображения в интерфейсе. Это позволяет обеспечить единообразную цветовую маркировку статусов.Таблица 4.2 – Таблица «Status» № Название Тип данных Описание 1 id AutoField Первичный ключ (автоинкремент) 2 name CharField(100) Название статуса 3 html_class CharField(100) HTML класс для отображения статуса Данная таблица служит справочником статусов документов, например: «В очереди», «Проверяется», «Проверено». Поле html_class применимо для интерфейса: оно позволяет выводить статус в определённом цвете или стиле. Таблица используется в цифровом документообороте и при формировании отчётов о проверке. Таблица Type служит для хранения типов загружаемых работ: «Реферат», «Курсовая работа», «Диплом», «Отчёт» и т.д. Использование отдельной таблицы делает систему расширяемой: добавление новых типов работ не требует изменения логики приложения. Таблица 4.3 – Таблица «Type» № Название Тип данных Описание 1 id AutoField Первичный ключ (автоинкремент) 2 name CharField(100) Название типа работы Таблица содержит перечень категорий документов, таких как «Курсовая работа», «Реферат», «Диплом». Она позволяет организовать данные структуры и облегчает категоризацию отчетов и статистики. Это также способствует гибкому расширению функционала: можно добавлять новые типы работ без модификации всей системы. Таблица Document является базовой для хранения всех загруженных документов и результатов их анализа.Таблица 4.4 – Таблица «Document» № Название Тип данных Описание 1 id BigAutoField Первичный ключ (автоинкремент) 2 user ForeignKey(User) Ссылка на пользователя 3 name CharField(100) Название документа 4 result DecimalField(5,2) Процент оригинальности 5 status ForeignKey(Status) Статус проверки 6 type ForeignKey(Type) Тип работы 7 time_created DateTimeField Дата и время загрузки 8 data FileField Загруженный документ 9 txt_file FileField Текстовая версия документа 10 vector TextField Векторное представление текста (JSON) 11 last_status_changed_by ForeignKey(User) Кто изменил статус последним Таблица «Document» включает все основные характеристики документа – от исходного файла до результатов анализа. Особую важность имеет поле vector, содержащее текст в векторном виде, который используется для семантических сравнений. Таблица обеспечивает хранение полного жизненного цикла документа: загрузка → анализ → присвоение статуса → формирование отчёта. Также фиксируется пользователь, изменивший статус документа, что обеспечивает прозрачность и аудит действий. Таблица SimilarDocument отвечает за хранение результатов вычисления схожести между документами. Таблица 4.5 – Таблица «User» № Название Тип данных Описание 1 id BigAutoField Первичный ключ (автоинкремент) 2 document ForeignKey(Document) Исходный документ 3 similar_document ForeignKey(Document) Похожий документ 4 similarity_score FloatField Уровень схожести (0-1) Эта таблица фиксирует пары документов, которые показали значительную семантическую близость. Поле similarity_score отражает степень совпадения, где 1 – полное совпадение, 0 – отсутствие схожести. Таблица используется при формировании отчётов, а также при выявлении подозрительных совпадений для дальнейшего анализа. Представленная структура базы данных обеспечивает надёжное хранение всех данных, необходимых для работы системы. Логичное разбиение сущностей на таблицы и использование внешних ключей создаёт удобную и масштабируемую архитектуру. Отдельные таблицы для статусов, типов и похожих документов позволяют гибко расширять функционал без изменения основной логики. Данная структура соответствует требованиям системы анализа текстов и обеспечивает корректную работу всех модулей – от загрузки документов до анализа семантической схожести. 4.2 Тестирование программного средства Тестирование программного обеспечения имеет ключевое значение в процессе разработки, внедрения и сопровождения программного продукта. Его основная цель – обнаружение ошибок, дефектов и недостатков в программе, а также проверка соответствия программного продукта требованиям и ожиданиям пользователей [26]. По степени автоматизации тестирование разделяется на автоматизированное и ручное. Автоматизированное тестирование программного обеспечения основано на написании кода. Методика данного тестирования позволяет описать ожидаемый сценарий, сравнить его с реальным поведением и указать расхождения. Такое тестирование позволяет получить быстрые и точные результаты. Однако важно понимать, что инструменты автоматизированного тестирования могут оказаться затратными. Поэтому автоматизация наиболее применима в сложных приложениях с большой функциональной частью. Значительным минусом является то, что с помощью автоматизированного тестирования нельзя оценить цветовые решения программного средства. Это не является первостепенным, но может повлиять на качество программного средства. Ручное тестирование – более долгий и трудоемкий процесс. Но он позволяет получить первый пользовательский опыт и отзыв реального человека. Такое тестирование также позволяет протестировать дизайн приложения. Внедрение ручного тестирование всегда менее затратно, чем автоматизированного. Для небольших проектов более рационально использовать именно ручное тестирование. В данном дипломном проекте используется ручное тестирование. Результаты тестирования представлены в таблице 3. Таблица 4.6 – Тестирование программного продукта Сценарий Выполняемое действие Ожидаемый результат 1 Авторизация пользователя Перейти на сайт Отображается страница с формой входа Заполнить поля Логин и Пароль Данные отображаются в полях ввода Нажать кнопку «Войти» Происходит переход в личный кабинет 2 Просмотр «Кабинета» Нажать на значок раскрывающегося меню в верхней части страницы Меню открывается Выбрать пункт «Кабинет» Происходит переход на страницу «Кабинет» 3 Загрузка нового документа Нажать кнопку «Проверить документ» Появляется окно для загрузки файла «Загрузка документа». Выбрать пункт «Кабинет» Документ загружается и появляется в списке в «Кабинете» Продолжение таблицы 4.6 Сценарий Выполняемое действие Ожидаемый результат 4 Отправить документ на проверку Нажать на значок меню (троеточие) рядом с нужным документом Появляется контекстное меню для этого файла Выбрать «Отправить на проверку» Открывается диалоговое окно «Отправить документ на защиту» Нажать кнопку «Отправить» Документ направляется на проверку 5 Скачать результаты Нажать на значок меню (троеточие) рядом с документом Появляется контекстное меню для этого файлаВыбрать «Результаты» Запускается загрузка отчета по документу в формате PD 6 Просмотр «Личного кабинета» Нажать на значок раскрывающегося меню в верхней части страницы Меню открывается Выбрать пункт «Личный кабинет» Происходит переход на страницу «Личный кабинет» 7 Доступ к разделу «Роли пользователей» (администратор) Кликнуть по значку выпадающего меню в шапке Открывается меню Выбрать пункт «Роль пользователя» Переход на страницу управления ролями пользователей 8 Доступ к разделу «Результаты» (администратор) Кликнуть по значку выпадающего меню в шапке Открывается меню Выбрать пункт «Результаты». Переход на страницу с обзором результатов Продолжение таблицы 4.6 Сценарий Выполняемое действие Ожидаемый результат 9 Выгрузка отчета (функционал администратора) Нажать на значок дополнительных действий (троеточие) рядом с записью документа Открывается контекстное меню для этого документа Выбрать опцию «Результаты» Запускается загрузка файла с результатами анализа в формате PDF 10 Рецензирование документа Нажать на значок дополнительных действий (троеточие) рядом с записью документа Открывается контекстное меню для этого документа Выбрать пункт «Оценить» Открывается диалоговое окно для оценки документа Нажать кнопку «Отправить на доработку» Документ помечается как требующий доработки и отправляется обратно пользователю Нажать кнопку «Зачтен» Документ получает статус «Зачтен» 11 Поиск по документу или автору Ввести название документа или ФИО пользователя в поле поиска На экране появляется информация, соответствующая поисковому запросу 12 Завершение сеанса работы в сервисе Нажать на значок выпадающего меню в верхней части страницы Открывается меню пользователя Выбрать кнопку «Выйти» Происходит выход из системы с последующим переходом на страницу авторизации 13 Быстрая прокрутка к началу страницы Нажать на кнопку прокрутки в правом нижнем углу экрана Страница автоматически прокручивается к самому верху Продолжение таблицы 4.6 Сценарий Выполняемое действие Ожидаемый результат 14 Навигация по страницам Нажать на кнопку перехода вперед (вправо) Отображаются следующие 10 записей из списка Нажать на кнопку перехода назад (влево) Отображаются предыдущие 10 записей В ходе тестирования ошибок обнаружено не было, тесты пройдены успешно. Разработанное программное средство демонстрирует корректное функционирование и соответствует требованиям, которые предъявлялись при проектировании и разработке, что говорит о высоком качестве программного продукта. Спроектирована и реализована база данных на PostgreSQL, обладающая необходимыми характеристиками надёжности и масштабируемости. Разработанная схема данных, включающая таблицы пользователей, документов, статусов и результатов сравнения, обеспечивает целостное функционирование всех модулей системы. Протестированные сценарии использования показали, что программный продукт соответствует поставленным требованиям и готов к практическому применению. Разработанная логическая и физическая схема данных включает в себя полный набор взаимосвязанных сущностей, покрывающих все бизнес-процессы приложения. Были спроектированы и реализованы таблицы для управления учётными записями пользователей и их сессиями, что обеспечивает безопасный доступ и полноценный аудит действий. Модель хранения документов и их версий позволяет эффективно управлять историей изменений и метаданными файлов. Отдельные сущности для контроля жизненного цикла задач (статусов) и детализированного хранения результатов сравнения создают гибкую основу для аналитики и формирования отчётов. - Эксплуатация программного средства 5.1 Ввод в эксплуатацию и обоснование минимальных технических требований к оборудованию Для деплоя веб-сервиса нужно использовать какой-либо хостинг [27]. Хостинг – это услуга по предоставлению ресурсов для размещения информации на сервере, постоянно имеющем доступ к сети. Есть большое количество хостингов как платных, так и бесплатных, некоторые из них имеют ограничения по количеству данных, некоторые по времени и занимаемой памяти т. д. Для данной курсовой работы используется платный хостинг Beget с функцией бесплатного использования для одного сайта, одной базы данных и ограниченного по памяти [28][29]. Проходим регистрацию, указывая номер телефона, на который будет зарегистрирован аккаунт, после успешной регистрации на указанный номер телефона придет смс с данными для авторизации логин и пароль. Авторизовавшись попадаем в панель управления, представленную на рисунке 5.1. Рисунок 5.1 – Панель управления Beget На локальном устройстве архивируем все файлы данной курсовой работы и при помощи Файлового менеджера погружаем их на сервер, предварительно удалив присутствующие файлы по умолчанию в нужной папке. Пример заливки файлов через файловый менеджер представлен на рисунке 5.2. Рисунок 5.2 – Заливка файлов через файловый менеджер на хостинг Далее нужно указать версии используемых языков программирования на хосте, такие же которые использовались в работе, для совмещения версий. В случае успешной погрузки всех данных на хостинг веб-сайт откроется по выданной ссылке в левом меню блока. Для работы и внесения правок на сервере нужно зайти в раздел FTP и создать FTP-аккаунт, к которому можно подключиться через FileZilla или другое подобное программное средство для внесения изменений сразу на сервере. Пример создания FTP-аккаунта представлен на рисунке 5.3. Рисунок 5.3 – Создание FTP-аккаунта После создания FTP-аккаунта получаем данные для подключения: хост, пароль, имя пользователя. В FileZilla создаем подключение и получаем все файлы для изменений. Пример подключения через FileZilla представлен на рисунке 5.4. Рисунок 5.4 – Подключение к веб-сайту для изменений через FileZilla Обоснование минимальных технических требований к оборудованию для открытия верстки сайта основывается на нескольких ключевых аспектах: Производительность системы выступает фундаментальным условием. Оборудование должно уверенно обрабатывать HTML, CSS, JavaScript и сопутствующие ресурсы, обеспечивая мгновенную отрисовку страниц без видимых задержек. Опыт показывает, что даже на начальной стадии знакомства с сервисом медленная реакция интерфейса воспринимается крайне негативно и может привести к потере пользователя. Ресурсы, потребляемые веб-браузером, также имеют критическое значение. Современный браузер для загрузки, обработки и плавного отображения сложной вёрстки требует значительного объема оперативной памяти, свободного процессорного времени и пространства для кэширования данных. Недостаток любого из этих ресурсов ведёт к снижению скорости работы и возможным сбоям. Не менее важен аспект совместимости и доступности. Оборудование и программное обеспечение должны соответствовать стандартам, поддерживаемым современными браузерами, и корректно работать на разнообразных устройствах, от настольных компьютеров до планшетов и смартфонов с различными разрешениями экранов. Это гарантирует, что дизайн и функционал сайта будут представлены правильно на любой выбранной платформе. Быстродействие сетевого подключения остаётся одним из основных факторов пользовательского опыта. Для эффективной загрузки всех элементов страницы, особенно при наличии медиафайлов или активном использовании внешних библиотек, необходима стабильная и достаточно быстрая сеть. Исходя из этих аспектов, минимальные технические требования к оборудованию для открытия данного веб-сервиса могут включать в себя: Персональный компьютер или ноутбук современного поколения с процессором не ниже Intel Core i3 или аналогичным, оперативной памятью не менее 4 ГБ и достаточным объемом свободного места на диске для временного хранения данных. Поддержка 3G, 4G, Wi-Fi. Использование современного веб-браузера (например, Google Chrome, Mozilla Firefox, Safari, Microsoft Edge), обеспечивающего оптимальное отображение и исполнение веб-страниц. Стабильное интернет-соединение с минимальной скоростью загрузки и выгрузки данных, обеспечивающее быструю загрузку верстки сайта. Эти минимальные требования обеспечат возможность открытия веб-сервиса на устройствах пользователя с минимальными задержками и с учетом основных аспектов производительности и безопасности. 5.2 Руководство по эксплуатации программным средством Для открытия необходимо иметь устройство, которое имеет возможность выхода в сеть Интернет. Веб-сервис загружен на хостинг и открывается по общедоступной ссылке в сети интернет [30]. Рассмотрим руководство по эксплуатации программным средством в десктопной версии. В первую очередь, при проектировании пользовательского интерфейса, нужно создать грамотный экран «Авторизации». Экран «Авторизации» является лицом приложения, это тот экран, с которым пользователь будет взаимодействовать в первую очередь. Поэтому он должен сочетать в себя приятный интерфейс, который сможет понравиться пользователю. Он должен быть интуитивно понятен. Пример страницы «Авторизации» представлен на рисунке 5.5. Рисунок 5.5 – Страница «Авторизации» Если пользователь не зарегистрирован и находиться первый раз на нашем сайте, а также если его логин или пароль не работает для него есть информационный блок с подсказками, что делать в данной ситуации, и ссылками на сторонние ресурсы как это можно исправить. В случаи, если пользователю нужно посмотреть какой пароль он вводит, можно нажать на иконку глаза и сделать ввод пароля видимым, а не в виде точек. После заполнения всех полей нажимая на кнопку «Войти» происходит вход в систему и перенаправление на страницу «Кабинета». Если возникла какая-либо ошибка в поле заполнения ему показывается сообщение о том какое поле неверно заполнено, а также иконка, при наведении на которую, можно получить более подробную информацию ошибки. Пример исключительной ситуации с подробным описанием ошибки и функционалом показа пароля представлен на рисунке 5.6. Рисунок 5.6 – Исключительная ситуация c подробным описанием ошибки и функционалом показа пароля при авторизации Каждый пользователь, зайдя в систему получает доступ к навигационному меню в хедере при наведении на иконку, для перехода между страницами или выхода из аккаунта нажав кнопку «Выйти». Также есть кликабельный логотип, который ведет на страницу «Кабинет». Пример навигационного меню показан на рисунке 5.7. Рисунок 5.7 – Навигационное меню Перейдя в «Личный кабинет пользователя», пользователь видит свое ФИО и адрес электронной почты. Изменение личной информации невозможно. Пример страницы «Личного кабинета» показан на рисунке 5.8. Рисунок 5.8 – Страница «Личного кабинета» Перейдя на страницу «Роль пользователя», она доступна только в режиме администратора, можно увидеть, для удобства взаимодействия, поле поиска по ФИО, а также внизу страницы пагинацию для перехода между записями с информацией, в случаи если больше 10 пользователей выводится на экран за один раз. Основной контент занимает вывод информации о пользователях, их номер ФИО и роль. Пример страницы «Роль пользователя» показан на рисунке 5.9. Рисунок 5.9 – Страница «Роль пользователя» Перейдя на страницу «Кабинет» можно увидеть, для удобства взаимодействия, поле поиска по названию документа, а также внизу страницы пагинацию для перехода между записями с информацией, в случаи если больше 10 документов выводится на экран за один раз и информационный блок с подсказкой. Основной контент занимает вывод информации о документах, их название, статус, дату, оригинальность и кнопку. Дата равна дате загрузки документа на проверку. Состояние статуса меняется и может быть «в очереди», «проверен», «не зачтен», «в защите», «зачтен». Пример страницы «Кабинета» показан на рисунке 5.10. Рисунок 5.10 – Страница «Кабинета» Если же название документа слишком большое и не помещается в одну строку, оно обрезается и оканчивается троеточием, но для того чтобы увидеть полное название документа, нужно навести на название и на экране покажется блок с полным названием. Пример полного названия документа представлен на рисунке 5.11. Рисунок 5.11 – Пример вывода полного названия документа Нажимая на иконку троеточия у каждого документа, появляется выпадающее меню с выбором «Результаты» нажимая на нее происходит скачивание результатов документа и кнопка «Отправить на проверку» для отправки документа на проверку. Пример клика на иконку троеточия показан на рисунке 5.12. Рисунок 5.12 – Пример клика на иконку троеточия Нажимая на кнопку «Отправить на проверку» открывается модальное окно для подтверждения отправки документа на защиту. В данном модальном окне выводиться вопрос подтверждения действия и информация о документе, а также кнопка подтверждения отправки на проверку, нажимая на которую данный документ отправиться на проверку. Для того чтобы закрыть данное модальное окно, необходимо нажать на иконку крестика или же на область вне модального окна. Пример модального окна для отправки на проверку представлен на рисунке 5.13. Рисунок 5.13 – Модальное окно при клике на «Отправить на проверку» Для того чтобы отправить новый документ на проверку, достаточно нажать на кнопку «Проверить документ» рядом с поиском и откроется модальное окно. Пример модального окна для загрузки нового документа представлен на рисунке 5.14. Рисунок 5.14 – Модальное окно для загрузки нового документа Далее выбираем из выпадающего списка тип работы, пишем название работы и в поле для загрузки документа либо нажав на кнопку «Загрузить документ» либо перетащив документ в область загрузки документа, если же документ выбран не тот, что нужно, его можно удалить из данной формы нажав на кнопку крестика данного документа. Если все поля заполнены корректно, нажимая на кнопку «Проверить» документ отправится на проверку и закроется модальное окно. Также для того, чтобы закрыть модальное окно, достаточно нажать на иконку крестика или же на область вне модального окна. Пример заполненной формы представлен на рисунке 5.15. Рисунок 5.15 – Заполненная форма загрузки документа Перейдя на страницу «Результаты» можно увидеть, для удобства взаимодействия, поле поиска по ФИО, а также внизу страницы пагинацию для перехода между страницами с информацией, в случаи если больше 10 пользователей выводится на экран за один раз и информационный блок с подсказкой. Основной контент занимает вывод информации о результатах документов, их название, статус, дату, оригинальность и кнопку. Дата равна дате загрузки документа на проверку. Состояние статуса меняется и, может быть, либо зачтен, либо отправлен на доработку. Пример страницы «Результаты» показан на рисунке 5.16. Рисунок 5.16 – Пример страницы «Результаты» Нажимая на иконку троеточия у каждого документа, появляется выпадающее меню с выбором «Результаты» нажимая на нее происходит скачивание результатов документа в формате *pdf и кнопка «Оценить» для открытия модального окна и оценки данной работы. Пример клика на иконку троеточия показан на рисунке 5.17. Рисунок 5.17 – Пример клика на иконку троеточия Нажимая на кнопку «Оценить», открывается модальное окно для оценки документа, в котором выводится подтверждение для внесения окончательного решения о данном документе, и информация о данном документе в виде ФИО, названии документа и оригинальность. Пример вывода модального окна показан на рисунке 5.18. Рисунок 5.18 – Модальное окно «Оценки документа» Также есть две кнопки «Отправить на доработку» и «Зачтен», при клике на кнопку «Отправить на доработку» документ отправляется на доработку и статус документа меняется на отрицательный. Статус документа после клика на кнопку «Отправить на доработку» показан на рисунке 5.19. Рисунок 5.19 – Статус при клике на кнопку «Отправить на доработку» При клике на кнопку «Зачтен» статус документа меняется на положительный. Статус документа после клика на кнопку «Зачтен» показан на рисунке 5.20. Рисунок 5.20 – Статус при клике на кнопку «Зачтен» После клика на кнопку «Зачтен» или же на кнопку «Отправить на доработку» модальное окно закрывается, также для того, чтобы закрыть модальное окно достаточно нажать на кнопку крестика или же на область вне модального окна. Также для мобильной версии предусмотрена кнопка скроллинга наверх страницы, для быстрого перехода в вверх страницы и любого положения. Пример кнопки скроллинга наверх показан на рисунке 5.21. Рисунок 5.21 – Пример кнопки скроллинга Таким образом, в данном разделе было представлено руководство по вводу в эксплуатацию и эксплуатации разработанного программного продукта. ЗАКЛЮЧЕНИЕ В ходе выполнения курсового проекта была поставлена и успешно достигнута цель – разработка модульной системы проверки текстов на заимствования с использованием Docker-контейнеров. Разработанная система реализована на основе микросервисной архитектуры, что обеспечивает высокий уровень модульности, отказоустойчивости и удобство горизонтального масштабирования. Каждая функциональная часть программного средства, включая обработку запросов пользователей, анализ текстов, управление базой данных и формирование отчётов, выделена в отдельный сервис и упакована в Docker-контейнер. Это решение позволяет легко управлять конфигурациями, обеспечивать переносимость системы между различными средами и упрощает её обновление и поддержку. В процессе работы был проведён детальный анализ существующих решений в области проверки оригинальности текста, что позволило определить ключевые требования к функциональности, безопасности, хранению данных и взаимодействию сервисов. На основе этих требований была спроектирована архитектура системы и реализован пользовательский веб-интерфейс, предоставляющий возможность загрузки файлов, просмотра результатов проверки и управления историей анализов. Дополнительно внедрены механизмы логирования, мониторинга, защиты данных и контроля доступа, что повышает надёжность и безопасность работы системы. Разработанное решение демонстрирует высокую практическую ценность. Система может быть эффективно использована в образовательных учреждениях, научных организациях и коммерческих компаниях для автоматизации проверки текстов, повышения качества работ и предотвращения нарушений авторских прав. Модульная архитектура обеспечивает гибкость и адаптивность системы под различные предметные области и объёмы данных, а технология контейнеризации значительно облегчает её внедрение в существующие ИТ-инфраструктуры. Таким образом, выполненный проект подтвердил возможность создания эффективной и масштабируемой системы проверки на заимствования, сочетающей современные методы анализа текстов с преимуществами контейнеризации и микросервисного подхода. Реализованное решение может стать основой для дальнейшего расширения функционала и интеграции в образовательные и корпоративные платформы. СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ [1] БГУИР ГОСТ СТП 01-2017 [Электронный ресурс]. – Режим доступа: https://www.bsuir.by/m/12_100229_1_122976.pdf − Дата доступа: 10.05.2024. [2] Антиплагиат [Электронный ресурс]. – Режим доступа: https:/ /antiplagiat.ru/ − Дата доступа: 12.04.2024. [3] PlagScan [Электронный ресурс]. – Режим доступа: https:/ /www.turnitin.com/ − Дата доступа: 12.04.2024. [4] Text.ru [Электронный ресурс]. – Режим доступа: https://text.ru /doccheck − Дата доступа: 12.04.2024. [5] Antiplagius [Электронный ресурс]. – Режим доступа: https:/ /antiplagius.ru/− Дата доступа: 12.04.2024. [6] BE1.ru [Электронный ресурс]. – Режим доступа: https://be1.ru /antiplagiat-online/ − Дата доступа: 12.04.2024. [7] MDN Web Docs [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/HTML − Дата доступа: 10.03.2024. [8] W3Schools [Электронный ресурс]. – Режим доступа: https:/ /www.w3schools.com/html/ − Дата доступа: 05.03.2024. [9] Основы HTML – Изучение веб-разработки [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/HTML – Дата доступа: 08.03.2024. [10] Руководство по CSS: каскадные таблицы [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/CSS/Reference – Дата доступа: 10.03.2024. [11] Основы SCSS [Электронный ресурс]. – Режим доступа: https://sass-scss.ru/guide/ – Дата доступа: 12.03.2024. [12] Современный учебник JavaScript [Электронный ресурс]. – Режим доступа: https://learn.javascript.ru/ – Дата доступа: 14.03.2024. [13] UI Дока JavaScript [Электронный ресурс]. – Режим доступа: https://doka.guide/js/ – Дата доступа: 14.03.2024. [14] Интегрированная среда разработки [Электронный ресурс]. – Режим доступа: https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки – Дата доступа: 06.03.2024. [15] VSCode [Электронный ресурс]. – Режим доступа: https:/ /code.visualstudio.com/ – Дата доступа: 06.03.2024. [16] VS Code настройка установка плагины [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=nxCLXMBl4e4 – Дата доступа: 06.03.2024. [17] MySQL [Электронный ресурс]. – Режим доступа: https:/ /www.mysql.com/ – Дата доступа: 05.04.2024. [18] Git и GitHub курс для новичков [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=zZBiln_2FhM – Дата доступа: 17.03.2024. [19] GIT [Электронный ресурс]. – Режим доступа: https://git-scm.com/ – Дата доступа: 20.04.2024. [20] GitHub [Электронный ресурс]. – Режим доступа: https:/ /blog.hubspot.com/website/what-is-github-used-for – Дата доступа: 12.04.2024. [21] Gulp установка настройка плагины [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=jU88mLuLWlk&t=2055s – Дата доступа: 12.03.2024. [22] Гид по Figma для разработчиков [Электронный ресурс]. – Режим доступа: https://www.figma.com/community/file/886207890389884742 – Дата доступа: 12.03.2024. [23] Алексеев, В. Ф. Структуры и базы данных. Пособие для курсового проектирования: пособие / В. Ф. Алексеев, И. Н. Богатко, Г. А. Пискун. – Минск: БГУИР, 2017. – 84 с.: ил. [24] PostgreSQL: Документация – Режим доступа: https://postgrespro.ru /docs/postgresql – Дата доступа: 04.04.2024. [25] Принципы UI/UX. – Режим доступа: https://habr.com/ru /companies/SECL_GROUP/articles/182208/ – Дата доступа: 10.04.2024. [26] Зачем нужно тестирование? Когда оно начинается и когда заканчивается, какие задачи стоят перед тестированием программного обеспечения? [Электронный ресурс]. – Режим доступа: https://dzen.ru /a/ZGEgrWptlGbZJKJi– Дата доступа: 05.01.2024. [27] Что такое хостинг [Электронный ресурс]. – Режим доступа: https://hostiq.ua/info/what-is-hosting/ – Дата доступа: 04.05.2024. [28] Руководство по панели управления Beget [Электронный ресурс]. – Режим доступа: https://beget.com/ru/kb/manual – Дата доступа: 04.05.2024. [29] Выгрузка проекта на хостинг [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=UPnVcTZUwXE&t=854s – Дата доступа: 04.05.2024. [30] Разработанный веб-сервис [Электронный ресурс]. Режим доступа: http://dimaracb.beget.tech/ – Дата доступа: 07.05.2024. ПРИЛОЖЕНИЕ А (обязательное)Отчёт о проверке на заимствования в системе «Антиплагиат» Рисунок А.1 – Отчет о проверке на заимствования в системе «Антиплагиат» ПРИЛОЖЕНИЕ Б (обязательное) Листинги программного кода Файл main.html @Service public class TicketServiceImpl implements TicketService { private TicketRepository ticketRepository; private MovieRepository movieRepository; private CinemaHallService cinemaHallService; private CartRepository cartRepository; private BookingRepository bookingRepository; private MovingPictureShowRepository movingPictureShowRepository; @Autowired public TicketServiceImpl(TicketRepository ticketRepository, MovieRepository movieRepository, CartRepository cartRepository, BookingRepository bookingRepository, CinemaHallService cinemaHallService, MovingPictureShowRepository movingPictureShowRepository) { this.ticketRepository = ticketRepository; this.movieRepository = movieRepository; this.cartRepository = cartRepository; this.bookingRepository = bookingRepository; this.cinemaHallService = cinemaHallService; this.movingPictureShowRepository = movingPictureShowRepository; } @Override public List<DateRequestDto> findAllTicketDates() { List<LocalDate> localDates = movingPictureShowRepository.searchDates(); List<DateRequestDto> dateRequestDtos = new ArrayList<>(); System.out.println(localDates); for (LocalDate localDate : localDates) { dateRequestDtos.add(new DateRequestDto()); dateRequestDtos.getLast().setFullDate(localDate.atStartOfDay().format(DateTimeFormatter.ISO_DATE_TIME)); } return dateRequestDtos; } @Override public List<TicketDto> findAllTicketDatesTime(LocalDateTime localDateTime, Long cinemaHallId) { localDateTime = localDateTime.plusHours(3); LocalDate ld = localDateTime.toLocalDate(); LocalTime lt = localDateTime.toLocalTime(); System.out.println(localDateTime); List<Ticket> tickets = ticketRepository.findAll().stream().filter(e->{ return (ld.equals(e.getMovingPictureShow().getDate()) && lt.equals(e.getMovingPictureShow().getTime()) && e.getMovingPictureShow().getCinemaHall().getId().equals(cinemaHallId)); }).toList(); return tickets.stream().map(TicketMapper::mapToTicketDto).collect(Collectors.toList()); } @Override public List<MovieStatDto> findAllMovieStat() { List<Movie> movies = movieRepository.findAll(); List<MovieStatDto> movieStatDtos = new ArrayList<>(); for(Movie movie : movies) { Integer purchased = ticketRepository.findPurchased(movie.getId()); MovieStatDto movieStatDto = MovieStatDto.builder() .id(movie.getId()) .title(movie.getTitle()) .soldTickets(purchased) .revenue(purchased * movie.getCost()) .build(); movieStatDtos.add(movieStatDto); } return movieStatDtos; } @Override public List<CinemaHallStatDto> findAllCinemaHallStat() { List<CinemaHallStatDto> cinemaHallStatDtos = new ArrayList<>(); List<Movie> movies = movieRepository.findAll(); for(Movie movie : movies) { List<MovingPictureShow> movingPictureShow = movingPictureShowRepository.searchCinoSession(movie.getId()); // System.out.println(movingPictureShow.getFirst().getTickets().size()); // List<Ticket> tickets = movingPictureShow.stream().map(session -> session.getTickets().getFirst()).toList(); for(MovingPictureShow session : movingPictureShow){ Integer purchased = ticketRepository.findPurchasedCinemaHall(session.getDate(), session.getTime()); CinemaHallStatDto cinemaHallStatDto = CinemaHallStatDto.builder() .id(session.getId()) .cinemaHallId(session.getCinemaHall().getId()) .hallName(session.getCinemaHall().getName()) .movieName(session.getMovie().getTitle()) .date(session.getDate()) .time(session.getTime()) .amountOfSeats(session.getCinemaHall().getCol() * session.getCinemaHall().getRow()) .amountOfOccupiedSeats(purchased) .build(); cinemaHallStatDtos.add(cinemaHallStatDto); }} return cinemaHallStatDtos; } @Override public void createTicket(TicketDto ticketDto, MovingPictureShow movingPictureShow) { Ticket ticket = TicketMapper.mapToTicket(ticketDto); ticket.setMovingPictureShow(movingPictureShow); ticketRepository.save(ticket); } @Override public List<TicketDto> findTicketsByMovieIdAndDate(Long movieId,LocalDate date) { Movie movie = movieRepository.findById(movieId).get(); return movie.getMovingPictureShows() .stream() .filter(e -> e.getDate().equals(date)) .map(e -> TicketMapper.mapToTicketDto(e.getTickets().getFirst())) .collect(Collectors.toList()); } @Override public List<TicketDto> findTicketsByCartId(Long cartId) { Cart cart = cartRepository.findById(cartId).get(); return cart.getTickets().stream().map(TicketMapper::mapToTicketDto).collect(Collectors.toList()); } @Override public List<TicketDto> findTicketsByBookingId(Long bookingId) { Booking booking = bookingRepository.findById(bookingId).get(); return booking.getTickets().stream().map(TicketMapper::mapToTicketDto).collect(Collectors.toList()); } @Override public void addTicketToBooking(Long bookingId, Long ticketId, PaymentType payType) { Booking booking = bookingRepository.findById(bookingId).get(); Ticket ticket = ticketRepository.findById(ticketId).get(); ticket.setBooking(booking); ticket.setPayType(payType); ticket.setStatus(true); ticket.setCart(null); ticketRepository.save(ticket); } @Override public void addTicketToAllBooking(Long bookingId, Long cartId, PaymentType paytype) { Booking booking = bookingRepository.findById(bookingId).get(); List<Ticket> tickets = cartRepository.findById(cartId).get().getTickets(); for (Ticket ticket : tickets) { ticket.setBooking(booking); ticket.setPayType(paytype); ticket.setStatus(true); ticket.setCart(null); ticketRepository.save(ticket); }} @Override public void delete(Long ticketId) { ticketRepository.deleteById(ticketId); } public void deleteSchedule(){ LocalDate localDate = LocalDateTime.now().minusHours(3).toLocalDate().minusDays(10); List<Ticket> tickets = ticketRepository.findAll().stream().filter(t -> { return t.getMovingPictureShow().getDate().isBefore(localDate); }).toList(); ticketRepository.deleteAll(tickets); } @Override public void createShedule(LocalDate localDate){ deleteSchedule(); final LocalTime startOfWork= LocalTime.of(10,0); final LocalTime endOfWork= LocalTime.of(0,0); LocalTime time; List<CinemaHallDto> cinemaHallDtos = cinemaHallService.getAllCinemaHalls(); List<Movie> movies = movieRepository.findAll().stream().sorted(Comparator.comparing((e) -> { if(e.getMovingPictureShows()==null || e.getMovingPictureShows().isEmpty()) { System.out.println(e); return 1000000; } else { int soldTickets = e.getMovingPictureShows().stream().flatMap(session -> session.getTickets().stream()).reduce(0, (x, y) -> x + y.getStatus().compareTo(true), Integer::sum); int allTickets = (int)e.getMovingPictureShows().stream().flatMap(session -> session.getTickets().stream()).count(); if( soldTickets == 0){ return allTickets; } else{ return allTickets + soldTickets; }} } )).collect(Collectors.toList()).reversed(); for(CinemaHallDto cinemaHallDto : cinemaHallDtos){ Movie movie = movies.getFirst(); time = startOfWork; while(true) { movie =movies.getFirst(); if(time.plusMinutes(movie.getDuration()).getHour() < startOfWork.getHour()) { for(Movie mv : movies){ if(time.plusMinutes(mv.getDuration()).getHour() > startOfWork.getHour()) { movie = mv; break; }} if(time.plusMinutes(movie.getDuration()).getHour() < startOfWork.getHour()) { break; }} movies.remove(movie); createSession(cinemaHallDto, localDate, movie, time); time = time.plusMinutes(movie.getDuration() + 15); int remainder = time.getMinute() % 5; if (!(remainder == 0)) { time = time.plusMinutes(5 - remainder); } movies.add(movie); }}} public void createSession(CinemaHallDto cinemaHallDto, LocalDate localDate, Movie movie,LocalTime time ) { MovingPictureShow sesion = movingPictureShowRepository.save(MovingPictureShow.builder() .cinemaHall(CinemaHallMapper.mapToCinemaHall(cinemaHallDto)) .date(localDate) .movie(movie) .time(time) .build()); TicketDto ticketDto = TicketDto.builder() .movie(MovieMapper.mapToMovieDto(movie)) .cinemaHall(cinemaHallDto) .status(false) .build(); for (int i = 0; i < cinemaHallDto.getRow(); i++) { for (int j = 0; j < cinemaHallDto.getCol(); j++) { ticketDto.setCol(j+1); ticketDto.setRow(i+1); createTicket(ticketDto, sesion); }}} @Override public List<MovieStatDto> filterMovieStats(Long movieId, Long hallId, LocalDate start, LocalDate end) { List<MovieStatDto> base = findAllMovieStat(); return base.stream() .filter(m -> movieId == null || m.getId().equals(movieId)) .collect(Collectors.toList()); } @Override public List<CinemaHallStatDto> filterHallStats(Long movieId, Long hallId, LocalDate start, LocalDate end) { return findAllCinemaHallStat().stream() .filter(h -> movieId == null || h.getMovieName().equals( movieRepository.findById(movieId).get().getTitle())) .filter(h -> hallId == null || h.getCinemaHallId().equals(hallId)) .filter(h -> { if (start == null || end == null) return true; return (!h.getDate().isBefore(start) && !h.getDate().isAfter(end)); }) .collect(Collectors.toList());} @Override public byte[] generateReport() { StringBuilder sb = new StringBuilder(); sb.append(\"Hall,Date,Time,Movie,Seats,Occupied,Percent\\n\"); for (CinemaHallStatDto dto : findAllCinemaHallStat()) { int percent = dto.getAmountOfOccupiedSeats() * 100 / dto.getAmountOfSeats(); sb.append(dto.getHallName()).append(\",\") .append(dto.getDate()).append(\",\") .append(dto.getTime()).append(\",\") .append(dto.getMovieName()).append(\",\") .append(dto.getAmountOfSeats()).append(\",\") .append(dto.getAmountOfOccupiedSeats()).append(\",\") .append(percent).append(\"%\\n\"); } return sb.toString().getBytes(); }} <User className=\"h-5 w-5\" /> <span className=\"sr-only\">Account</span> </Button> </Link> <Link href=\"/admin\" className=\"md:hidden\"> <Button variant=\"ghost\" size=\"icon\" className=\"text-gray-400 hover:text-white\"> <Settings className=\"h-5 w-5\" /> <span className=\"sr-only\">Admin</span> </Button> </Link> <Link href=\"/login\"> <Button variant=\"outline\" className=\"hidden md:inline-flex border-gray-700 bg-gray-800 text-white hover:bg-gray-700\" > Sign In </Button> </Link> </div> </div> </header> {/* Hero Section */} <section className=\"relative overflow-hidden py-20 md:py-32\"> <div className=\"container flex flex-col items-center text-center\"> <div className=\"absolute inset-0 -z-10 bg-[radial gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-gray-900 via black to-black\"> <div className=\"absolute inset-0 bg-grid-pattern opacity 5\"></div> <div className=\"absolute inset-0 animate-pulse-slow bg-[radial gradient(circle_at_center,_var(--tw-gradient-stops))] from-blue-900/10 via transparent to-transparent\"></div> </div> <div className=\"absolute inset-0 -z-10 bg [url('/placeholder.svg?height=800&width=1600')] bg-cover bg-center opacity-10 mix-blend-overlay\"></div> <h1 className=\"max-w-4xl text-4xl font-bold tracking-tight sm:text 5xl md:text-6xl lg:text-7xl\"> Premium Vaping{\" \"} <span className=\"bg-gradient-to-r from-teal-400 to-blue-500 bg clip-text text-transparent\">Experience</span> </h1> <p className=\"mt-6 max-w-2xl text-lg text-gray-200\"> Discover our premium collection of electronic cigarettes and accessories. Designed for the modern vaper with quality and style in mind. </p> <div className=\"mt-10 flex flex-wrap justify-center gap-4\"> <Button className=\"bg-gradient-to-r from-teal-500 to-blue-600 hover:from-teal-600 hover:to-blue-700\"> Shop Now <ArrowRight className=\"ml-2 h-4 w-4\" /> </Button> <Button variant=\"outline\" </div> </div> </section> {/* Featured Products */} <section id=\"products\" className=\"py-16 bg-gray-950\"> <div className=\"container\"> <h2 className=\"text-3xl font-bold tracking-tight mb-8\">Featured Products</h2> <ProductCatalog /> </div> </section> {/* Features Section */} <section className=\"py-16\"> <div className=\"container\"> <div className=\"grid grid-cols-1 gap-8 md:grid-cols-3\"> <div className=\"group rounded-lg border border-gray-800 bg-gray 950 p-6 transition-all duration-300 hover:border-blue-500 hover:shadow-md hover:shadow-blue-500/10 hover:translate-y-[-5px]\"> <div className=\"mb-4 rounded-full bg-blue-500/10 p-3 w-12 h-12 flex items-center justify-center\"> <svg className=\"h-6 w-6 text-blue-500\" fill=\"none\" height=\"24\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\" > <path d=\"M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z\" /> </svg> </div> <h3 className=\"mb-2 text-xl font-bold\">Premium Quality</h3> <p className=\"text-gray-400\"> Our products are crafted with the highest quality materials for a superior vaping experience. </p> </div> <div className=\"group rounded-lg border border-gray-800 bg-gray 950 p-6 transition-all duration-300 hover:border-teal-500 hover:shadow-md hover:shadow-teal-500/10 hover:translate-y-[-5px]\"> <div className=\"mb-4 rounded-full bg-teal-500/10 p-3 w-12 h-12 flex items-center justify-center\"> </svg> </div> <h3 className=\"mb-2 text-xl font-bold\">Secure Shopping</h3> <p className=\"text-gray-400\"> Shop with confidence with our secure payment system and fast, reliable shipping. </p> </div> <div className=\"group rounded-lg border border-gray-800 bg-gray 950 p-6 transition-all duration-300 hover:border-blue-500 hover:shadow-md hover:shadow-blue-500/10 hover:translate-y-[-5px]\"> <div className=\"mb-4 rounded-full bg-blue-500/10 p-3 w-12 h-12 flex items-center justify-center\"> <svg className=\"h-6 w-6 text-blue-500\" fill=\"none\" height=\"24\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\" > <path d=\"M18 6H5a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h13l4-3.5L18 6Z\" /> <path d=\"M12 13v8\" /> <path d=\"M5 13v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6\" /> </svg> </div> <h3 className=\"mb-2 text-xl font-bold\">Customer Support</h3> <p className=\"text-gray-400\"> Our dedicated support team is always ready to assist you with any questions or concerns. </p> </div> </div> </div> </section> {/* Newsletter Section */} <section className=\"py-16 bg-gray-950\"> <div className=\"container\"> <div className=\"rounded-xl border border-gray-800 bg-gradient-to-br from-gray-900 to-black p-8 relative overflow-hidden\"> <div className=\"absolute inset-0 bg-grid-pattern opacity 5\"></div> <div className=\"absolute -inset-1 bg-gradient-to-r from-teal 500/10 via-blue-500/10 to-teal-500/10 blur-xl filter opacity-30 animate pulse-slow\"></div> <div className=\"relative\"> <div className=\"flex flex-col items-center justify-between gap 4 md:flex-row\"> <div> <h3 className=\"text-2xl font-bold\">Stay Updated</h3> <p className=\"text-gray-400\"> Subscribe to our newsletter for the latest products and exclusive offers. </p> type=\"email\" placeholder=\"Enter your email\" className=\"w-full rounded-md border border-gray-800 bg black px-4 py-2 text-white focus:border-blue-500 focus:outline-none\" /> <Button className=\"bg-gradient-to-r from-teal-500 to-blue 600 hover:from-teal-600 hover:to-blue-700\"> Subscribe </Button> </div> </div> </div> </div> </div> </section> {/* Footer */} <footer className=\"border-t border-gray-800 bg-black py-12\"> <div className=\"container\"> <div className=\"grid grid-cols-1 gap-8 md:grid-cols-4\"> <div> <Link href=\"/\" className=\"flex items-center gap-2 text-xl font bold\"> <span className=\"bg-gradient-to-r from-teal-400 to-blue-500 bg-clip-text text-transparent\">VAPOR</span> <span>TECH</span> </Link> <p className=\"mt-4 text-gray-400\">Premium vaping products for the modern enthusiast.</p> </div> <div> <h3 className=\"mb-4 text-lg font-semibold\">Quick Links</h3> <ul className=\"space-y-2 text-gray-400\"> <li> <Link href=\"/\" className=\"hover:text-blue-400\"> Home </Link> </li> <li> <Link href=\"#products\" className=\"hover:text-blue-400\"> Products </Link> </li> <li> <Link href=\"#about\" className=\"hover:text-blue-400\"> About Us </Link> </li> <li> <Link href=\"#contact\" className=\"hover:text-blue-400\"> Contact </Link> </li> </ul> </div> <div> <h3 className=\"mb-4 text-lg font-semibold\">Customer Service</h3> <ul className=\"space-y-2 text-gray-400\"> <li> </li> <li> <Link href=\"/shipping\" className=\"hover:text-blue-400\"> Shipping & Returns </Link> </li> <li> <Link href=\"/warranty\" className=\"hover:text-blue-400\"> Warranty </Link> </li> <li> <Link href=\"/privacy\" className=\"hover:text-blue-400\"> Privacy Policy </Link> </li> </ul> </div> <div> <h3 className=\"mb-4 text-lg font-semibold\">Contact Us</h3> <address className=\"not-italic text-gray-400\"> <p>1234 Street</p> <p>San Francisco, CA 94103</p> <p className=\"mt-2\">Email: info@vaportech.com</p> <p>Phone: (123) 456-7890</p> </address> </div> </div> <div className=\"mt-12 border-t border-gray-800 pt-8 text-center text-gray-400\"> <p>© 2024 VaporTech. All rights reserved.</p> </div> </div> </footer> </div> ) } export default function Home() { return ( <div className=\"flex min-h-screen flex-col bg-black text-white\"> {/* Navigation */} <header className=\"sticky top-0 z-40 w-full border-b border-gray-800 bg-black/80 backdrop-blur-sm\"> <div className=\"container flex h-16 items-center justify-between\"> <Link href=\"/\" className=\"flex items-center gap-2 text-xl font bold\"> <span className=\"bg-gradient-to-r from-teal-400 to-blue-500 bg clip-text text-transparent\">VAPOR</span> <span>TECH</span> </Link> <nav className=\"hidden md:flex items-center gap-6 text-sm\"> <Link href=\"/\" className=\"font-medium text-white transition colors hover:text-blue-400\"> Home </Link> <Link href=\"#products\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> Products </Link> 49 <Link href=\"#about\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> About </Link> <Link href=\"#contact\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> Contact </Link> <Link href=\"/admin\" className=\"font-medium text-gray-400 transition-colors hover:text-blue-400\"> Admin </Link> </nav> <div className=\"flex items-center gap-4\"> <Link href=\"/cart\"> <Button variant=\"ghost\" size=\"icon\" className=\"relative text gray-400 hover:text-white\"> <ShoppingCart className=\"h-5 w-5\" /> <span className=\"absolute -top-1 -right-1 flex h-4 w-4 items center justify-center rounded-full bg-blue-500 text-[10px] font-bold text white\"> 3 </span> <span className=\"sr-only\">Shopping Cart</span> </Button> </Link> <Link href=\"/account\"> ПРИЛОЖЕНИЕ В (обязательное) Графический материал ПРИЛОЖЕНИЕ Г (обязательное) Ведомость курсового проекта",
      "wordCount": 12597,
      "uploadDate": "2026-01-28T23:18:04.747Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        118115,
        35722,
        35456,
        47974,
        40675,
        53090,
        101639,
        166996,
        142348,
        53874,
        79417,
        118127,
        80905,
        2108,
        344873,
        376892,
        130897,
        80489,
        56184,
        22874,
        44872,
        64880,
        28480,
        41365,
        135663,
        544551,
        10284,
        29535,
        51127,
        131290,
        46838,
        82281,
        114802,
        149836,
        19382,
        27216,
        58359,
        29425,
        5072,
        44225,
        355946,
        248464,
        76468,
        95321,
        26861,
        343390,
        10165,
        229934,
        52576,
        396221,
        123214,
        31268,
        115144,
        36331,
        153600,
        35737,
        44206,
        115505,
        46953,
        95050,
        172363,
        193051,
        122991,
        46854,
        10511,
        59676,
        17621,
        47931,
        222264,
        49161,
        63058,
        103730,
        13049,
        4509,
        35237,
        19474,
        34560,
        155298,
        109757,
        85813,
        7481,
        53068,
        36150,
        26384,
        20381,
        10874,
        62353,
        52509,
        76982,
        59454,
        6810,
        10376,
        186383,
        31802,
        128544,
        111792,
        41640,
        82358,
        27602,
        171660,
        143496,
        805,
        24411,
        141064,
        40686,
        7003,
        25243,
        47919,
        56862,
        25173,
        16065,
        138033,
        53371,
        16031,
        73953,
        87067,
        1231,
        116178,
        12127,
        50765,
        109736,
        117086,
        37286,
        18237,
        11781,
        31667,
        53574,
        37535
      ],
      "shingleCount": 29083
    },
    {
      "id": 50,
      "title": "ved1",
      "author": "Фурсов Артем Валерьевич",
      "filename": "ved1.docx",
      "filePath": "data/uploads/1769642576004_ved1.docx",
      "content": "Перв. примен. Зона Обозначение Наименование Дополнительные,сведения Текстовые документы БГУИР КП 6-05-0611-01 023 ПЗ Пояснительная записка 66 с. Справочный № Графические документы ГУИР.314301.001 ПЛ ER-диаграмма базы данных Формат А3 ГУИР.314301.002 ПЛ Диаграмма развертывания Формат А3 Программного средства ГУИР.314301.003 ПЛ Графический интерфейс Формат А3 Программного средства Подпись и дата Инв. № дубл. Взам. Инв. № Подпись и дата БГУИР КП 6-05-0611-01 023 Д1 Изм. Лист № докум. Подп. Дата Инв. № подл. Разраб. Сурженко Система аунтефикации и авторизации пользователей с использованием LDAP и асинхронной обработки задач Лит. Лист Листов Пров. Крез Т 66 66 Кафедра ПИКС, группа 314302 Формат А4,",
      "wordCount": 98,
      "uploadDate": "2026-01-28T23:22:56.033Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        3460779,
        4971610,
        807036,
        5955097,
        5215599,
        8356340,
        1163475,
        3099499,
        7497188,
        2130377,
        2836416,
        3946094,
        122533,
        2453393,
        1134052,
        2111335,
        4665584,
        3305944,
        2203337,
        9734160,
        571919,
        7802516,
        6719536,
        1721276,
        1722976,
        4657879,
        348000,
        608062,
        51127,
        2973632,
        2706735,
        5718525,
        202130,
        9346769,
        7972861,
        851283,
        2023928,
        514002,
        10336261,
        8064988,
        1575749,
        2326494,
        3944897,
        127195,
        1301957,
        12605695,
        14776087,
        1529290,
        84454,
        1738202,
        7135095,
        1472150,
        6017871,
        2470336,
        7964695,
        204574,
        2223411,
        3984303,
        7740224,
        2068493,
        2579865,
        11401208,
        16323233,
        4400686,
        256956,
        4711857,
        2115439,
        7070680,
        2623049,
        1682526,
        3688096,
        2117779,
        3419546,
        2140035,
        12236128,
        104103,
        12168249,
        1047967,
        2049795,
        12491527,
        2039524,
        2844955,
        4610293,
        9011444,
        479191,
        20465672,
        1112204,
        11408655,
        5900476,
        336932,
        2113428,
        6145329,
        12028690,
        67318,
        5466617,
        119660,
        5437464,
        5186436,
        3053183,
        621036,
        1804416,
        4227062,
        10515480,
        3228696,
        1399999,
        7003,
        12097187,
        2868741,
        56862,
        198656,
        5205535,
        307377,
        3219215,
        2837194,
        1099031,
        5499114,
        1311551,
        2047375,
        1435344,
        2401863,
        734576,
        117086,
        4524990,
        1511273,
        11781,
        784055,
        492218,
        7897963
      ],
      "shingleCount": 519
    },
    {
      "id": 51,
      "title": "ved2",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "ved2.docx",
      "filePath": "data/uploads/1769642586991_ved2.docx",
      "content": "Перв. примен. Зона Обозначение Наименование Дополнительные,сведения Текстовые документы БГУИР КП 6-05-0611-01 025 ПЗ Пояснительная записка 52 с. Справочный № Графические документы ГУИР.314302.001 ПЛ Диаграмма алгоритма сравнения Формат А3 Текстовых документов ГУИР.314302.002 ПЛ Диаграмма алгоритма сравнения Формат А3 изображений ГУИР.314302.003 ПЛ Графический интерфейс Формат А3 Программного средства Подпись и дата Инв. № дубл. Взам. Инв. № Подпись и дата БГУИР КП 6-05-0611-01 025 Д1 Изм. Лист № докум. Подп. Дата Инв. № подл. Разраб. Фурсов Веб-сервис для проверки оригинальности различных работ на основе репозитория БГУИР с использованием Django Лит. Лист Листов Пров. Крез Т 52 52 Кафедра ПИКС, группа 314302 Формат А4,",
      "wordCount": 101,
      "uploadDate": "2026-01-28T23:23:07.012Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        3460779,
        4971610,
        807036,
        873214,
        3758063,
        8356340,
        3466142,
        3099499,
        4763190,
        12413670,
        3298178,
        2741187,
        122533,
        2453393,
        10437681,
        2111335,
        4665584,
        3305944,
        1128719,
        9734160,
        571919,
        3506705,
        239923,
        1721276,
        3534388,
        7790363,
        7395599,
        608062,
        20078450,
        11222253,
        2706735,
        2914983,
        1380860,
        9346769,
        865153,
        851283,
        2023928,
        514002,
        6340819,
        8064988,
        3047671,
        9134471,
        3944897,
        127195,
        2552062,
        6205902,
        7915469,
        1529290,
        11673234,
        1915754,
        7135095,
        1472150,
        6365193,
        2470336,
        7964695,
        204574,
        319540,
        3984303,
        7740224,
        12481676,
        8872349,
        11401208,
        15313901,
        4400686,
        256956,
        4711857,
        2115439,
        3321111,
        2623049,
        8098765,
        1866302,
        3889188,
        3419546,
        2140035,
        12236128,
        104103,
        2684973,
        1047967,
        109757,
        151169,
        2039524,
        2844955,
        91562,
        9011444,
        9965555,
        22206622,
        892799,
        11408655,
        5900476,
        336932,
        2113428,
        6145329,
        12028690,
        67318,
        3786703,
        119660,
        844108,
        7193568,
        316219,
        4264907,
        861635,
        4227062,
        12313338,
        3228696,
        5502137,
        2558944,
        8958202,
        827763,
        56862,
        9562007,
        5205535,
        307377,
        3219215,
        2837194,
        3921398,
        4437798,
        1311551,
        2047375,
        1435344,
        37502,
        734576,
        4047002,
        4524990,
        4118959,
        11781,
        784055,
        711153,
        8685594
      ],
      "shingleCount": 529
    },
    {
      "id": 54,
      "title": "spravka-5 Junit",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "spravka-5 Junit.pdf",
      "filePath": "data/uploads/1769685367059_spravka-5_Junit.pdf",
      "content": "Белорусский государственный университет информатики и радиоэлектроники Справка о результатах проверки текстового документа на наличие заимствований ПРОВЕРКА ВЫПОЛНЕНА В СИСТЕМЕ БГУИР.ПЛАГИАТ ФИО: Ханцевич Андрей Андреевич Тип работы: Курсовая работа / Проект Название работы: 5 Junit Дата проверки: 29.01.2026 Работу проверил(а): ___________________________ Подпись проверяющегося: ___________________________ Результаты: Совпадения 16,00% Оригинальность 84,00% Для просмотра PDF-отчёта (справки) отсканируйте QR-код Для просмотра оригинальной работы (загруженный документ) отсканируйте QR-код Источники № Авторы Доля Источник 1 31810079 16,00 stsr 2 student 16,00 stsr 3 31810079 15,00 test1 4 student 15,00 1 (3) 5 31810079 4,00 Лабораторная работа 1 Белорусский государственный университет информатики и радиоэлектроники БГУИР.ПЛАГИАТ — Стр. 1 из 1",
      "wordCount": 102,
      "uploadDate": "2026-01-29T11:16:07.083Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        11675595,
        5526382,
        807036,
        873214,
        1254508,
        374739,
        3349154,
        1713173,
        1996230,
        1915095,
        4639721,
        3251597,
        3523935,
        6044164,
        1054005,
        5333365,
        4088568,
        4054179,
        2203337,
        3822732,
        512533,
        4145306,
        91694,
        2313504,
        14587980,
        5064943,
        6148619,
        2350365,
        234058,
        1073146,
        3683646,
        4041676,
        8150793,
        856628,
        6305922,
        18920065,
        6723706,
        6667799,
        2361621,
        7326297,
        3065097,
        1627549,
        3212184,
        127195,
        234840,
        10867833,
        7411931,
        7036322,
        1615383,
        99000,
        14060773,
        1642418,
        4572673,
        6333828,
        3005947,
        204574,
        319540,
        839295,
        1799122,
        3968386,
        3765264,
        1140295,
        2371002,
        293838,
        6128132,
        1898127,
        987754,
        4385299,
        1883399,
        3231124,
        70245,
        1923343,
        9360569,
        11131920,
        9403652,
        907049,
        39245,
        3423883,
        7644096,
        2421280,
        2036122,
        4848192,
        4550915,
        3669891,
        8420301,
        2990075,
        1749466,
        1769063,
        1153583,
        11055208,
        2192174,
        6145329,
        5510798,
        7379826,
        243624,
        1076632,
        11595734,
        7193568,
        1555921,
        371762,
        960680,
        953119,
        944483,
        1898294,
        2925782,
        1306350,
        225975,
        8078684,
        7522640,
        412444,
        300649,
        4060218,
        18763632,
        7562257,
        772728,
        5063664,
        743993,
        7815563,
        171427,
        2262664,
        4649676,
        2346258,
        8386219,
        1080622,
        2791521,
        5281040,
        543244,
        2230847
      ],
      "shingleCount": 568
    },
    {
      "id": 55,
      "title": "spravka-spravka-5 Junit",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "spravka-spravka-5 Junit.pdf",
      "filePath": "data/uploads/1769686853381_spravka-spravka-5_Junit.pdf",
      "content": "Белорусский государственный университет информатики и радиоэлектроники Справка о результатах проверки текстового документа на наличие заимствований ПРОВЕРКА ВЫПОЛНЕНА В СИСТЕМЕ БГУИР.ПЛАГИАТ ФИО Ханцевич Андрей Андреевич Тип работы: Курсовая работа / Проект Название работы: spravka-5 Junit Результаты: Совпадения 5,00% Оригинальность 95,00% Дата проверки: 29.01.2026 Работу проверил(а): ___________________________ Дата: Подпись проверяющего: Для подтверждения подлинности и актуальности данной справки отсканируйте QR-код Для просмотра оригинальной электронной версии документа отсканируйте QR-код Источники № ID Доля Источник 1 51 5,00 ved2 2 50 4,00 ved1 3 34 3,00 Лабораторная работа 1 4 45 2,00 5 Junit 5 41 2,00 test1 Белорусский государственный университет информатики и радиоэлектроники БГУИР.ПЛАГИАТ — Стр. 1 из 1",
      "wordCount": 105,
      "uploadDate": "2026-01-29T11:40:53.399Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        3317569,
        5394443,
        807036,
        873214,
        1254508,
        374739,
        3349154,
        1713173,
        1996230,
        1915095,
        5549668,
        3251597,
        3523935,
        5860833,
        1054005,
        5333365,
        2385317,
        4054179,
        2203337,
        589248,
        512533,
        3506705,
        91694,
        2313504,
        444538,
        5064943,
        8225369,
        2350365,
        51127,
        382589,
        3683646,
        4041676,
        21466458,
        856628,
        6305922,
        7854776,
        6723706,
        6667799,
        2301284,
        4495731,
        3065097,
        1627549,
        1190973,
        127195,
        234840,
        11075892,
        3060503,
        7036322,
        310042,
        99000,
        197435,
        1642418,
        4572673,
        1939083,
        607840,
        204574,
        319540,
        839295,
        1799122,
        3575242,
        3765264,
        1252377,
        2371002,
        3653781,
        6128132,
        4799973,
        8220537,
        3905191,
        1883399,
        4631117,
        70245,
        1923343,
        5380426,
        11131920,
        9403652,
        200382,
        366780,
        3812270,
        17098818,
        2421280,
        2036122,
        9674300,
        4550915,
        26384,
        1100371,
        2990075,
        1749466,
        1123675,
        4219419,
        3203702,
        2192174,
        3291713,
        5510798,
        10211007,
        243624,
        1076632,
        2518811,
        7193568,
        1275808,
        371762,
        960680,
        953119,
        1787663,
        4725286,
        2925782,
        1306350,
        225975,
        5709053,
        7522640,
        412444,
        300649,
        4060218,
        18763632,
        7562257,
        3921398,
        5063664,
        7201461,
        5700503,
        171427,
        2262664,
        4649676,
        6160504,
        8386219,
        6077084,
        2791521,
        5281040,
        6993360,
        2230847
      ],
      "shingleCount": 588
    },
    {
      "id": 56,
      "title": "spravka-document",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "spravka-document.pdf",
      "filePath": "data/uploads/1769686893226_spravka-document.pdf",
      "content": "Белорусский государственный университет информатики и радиоэлектроники Справка о результатах проверки текстового документа на наличие заимствований ПРОВЕРКА ВЫПОЛНЕНА В СИСТЕМЕ БГУИР.ПЛАГИАТ ФИО: — Тип работы: Курсовая работа / Проект Название работы: document Дата проверки: 29.01.2026 Работу проверил(а): ___________________________ Подпись проверяющегося: ___________________________ Результаты: Совпадения 16,00% Оригинальность 84,00% Для просмотра PDF-отчёта (справки) отсканируйте QR-код Для просмотра оригинальной работы (загруженный документ) отсканируйте QR-код Источники № Авторы Доля Источник 1 31810079 16,00 stsr 2 student 16,00 stsr 3 31810079 15,00 test1 4 student 15,00 1 (3) 5 31810079 4,00 Лабораторная работа 1 Белорусский государственный университет информатики и радиоэлектроники БГУИР.ПЛАГИАТ — Стр. 1 из 1",
      "wordCount": 99,
      "uploadDate": "2026-01-29T11:41:33.243Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        11675595,
        5526382,
        807036,
        873214,
        1254508,
        374739,
        3349154,
        1713173,
        1996230,
        1915095,
        4639721,
        3251597,
        3523935,
        10868142,
        1054005,
        5333365,
        4088568,
        4054179,
        2203337,
        3822732,
        512533,
        4145306,
        91694,
        2313504,
        14587980,
        5064943,
        6148619,
        2350365,
        234058,
        1073146,
        3683646,
        82281,
        577202,
        856628,
        10215828,
        18920065,
        9865126,
        6667799,
        2361621,
        7326297,
        3065097,
        1627549,
        3212184,
        127195,
        234840,
        10867833,
        7411931,
        7036322,
        1615383,
        99000,
        14060773,
        1642418,
        4572673,
        6333828,
        3005947,
        204574,
        319540,
        839295,
        1799122,
        3968386,
        3765264,
        1140295,
        2371002,
        293838,
        6128132,
        1898127,
        987754,
        4385299,
        1883399,
        3231124,
        70245,
        1923343,
        9360569,
        11131920,
        9403652,
        907049,
        39245,
        3423883,
        7644096,
        2421280,
        2036122,
        4848192,
        6106784,
        3669891,
        8420301,
        9538602,
        1749466,
        1769063,
        1153583,
        11055208,
        2192174,
        6145329,
        5510798,
        7379826,
        243624,
        1076632,
        11595734,
        7193568,
        1555921,
        2264426,
        960680,
        953119,
        944483,
        1898294,
        2809971,
        1306350,
        225975,
        8078684,
        7522640,
        412444,
        300649,
        4060218,
        1936356,
        7562257,
        772728,
        5063664,
        743993,
        7815563,
        171427,
        2262664,
        4649676,
        2346258,
        8386219,
        1080622,
        2791521,
        5281040,
        543244,
        2230847
      ],
      "shingleCount": 546
    },
    {
      "id": 57,
      "title": "РЕ ИВАН (3)",
      "author": "Фурсов Артем Валерьевич",
      "filename": "РЕ ИВАН (3).docx",
      "filePath": "data/uploads/1769783638914_РЕ_ИВАН__3_.docx",
      "content": "Министерство образования Республики Беларусь Учреждение образования «Белорусский государственный университет информатики и радиоэлектроники» Факультет компьютерного проектирования Кафедра проектирования информационно-компьютерных систем Дисциплина «Микроконтроллерные устройства» «К ЗАЩИТЕ ДОПУСТИТЬ» Руководитель курсового проекта Ассистент кафедры ПИКС _______________ К.С. Крез ___.____.2025 ПОЯСНИТЕЛЬНАЯ ЗАПИСКА к курсовой работе на тему: «Создание Pipeline для очистки, нормализации текста и его последующего преобразования в векторные представления с использованием различных подходов» БГУИР КП 1-39 02 01 038 ПЗ Выполнил студент группы 314302 Рековец Иван Максимович _______________________________ (подпись студента) Курсовой проект представлен на проверку ___.____.2025 _______________________________ (подпись студента) Минск 2025 РЕФЕРАТ БГУИР КП 1-39 02 01 038 ПЗ Рековец И. М. Создание Pipeline для очистки, нормализации текста и его последующего преобразования в векторные представления с использованием различных подходов: пояснительная записка к курсовому проекту/ И.М. Рековец. – Минск: БГУИР, 2025. – 60 с. Пояснительная записка 60 с., 35 рис., 3 табл., 30 источников, 3 приложения. СОЗДАНИЕ PIPELINE ДЛЯ ОЧИСТКИ, НОРМАЛИЗАЦИИ ТЕКСТА И ЕГО ПОСЛЕДУЮЩЕГО ПРЕОБРАЗОВАНИЯ В ВЕКТОРНЫЕ ПРЕДСТАВЛЕНИЯ С ИСПОЛЬЗОВАНИЕМ РАЗЛИЧНЫХ ПОДХОДОВ Цель проектирования: создание программного средства, реализующего полный конвейер обработки текстовых данных, включающий их очистку, нормализацию и преобразование в векторные представления с использованием различных алгоритмов. Данный pipeline предназначен для подготовки текстовой информации к дальнейшему применению в задачах семантического анализа, поиска сходства и обнаружения заимствований. Методология проведения работы: при проектировании использовались принципы модульности, расширяемости и воспроизводимости обработки данных. Проведён анализ современных методов лингвистической предобработки текста и подходов к его векторизации. Для реализации программного средства применены актуальные инструменты и библиотеки обработки естественного языка. Обеспечена возможность замены отдельных этапов pipeline без изменения общей структуры системы. Результаты работы: разработан и реализован программный конвейер, включающий этапы удаления шумов, нормализации текста, токенизации и формирования векторных представлений на основе статистических и нейросетевых моделей. Проведена оценка производительности и качества получаемых векторных репрезентаций с использованием таких метрик, как точность, полнота и F-мера. Реализована возможность интеграции pipeline с системами анализа текстового сходства и обнаружения заимствований. Область применения результатов: разработанное решение может использоваться в образовательных, научных и корпоративных системах проверки текстов, аналитических платформах, поисковых системах, а также в проектах на основе NLP, требующих качественной подготовки текстовых данных и получения их семантически значимых представлений. Содержание По содержанию отдельный файл без нумерации, т.к. ссылки слитают и не ставятся страницы ВВЕДЕНИЕ В рамках данного курсового проекта был разработан модульный конвейер обработки текстовых данных, включающий очистку, нормализацию и преобразование текста в векторные представления для задач анализа и обнаружения семантических заимствований. Основная цель проекта — создание эффективного решения, позволяющего автоматизировать предварительную обработку текстов и обеспечить их корректное представление для дальнейшего применения методов машинного обучения. Pipeline включает ключевые этапы: удаление шумов, лемматизацию, токенизацию и формирование векторных моделей на основе современных алгоритмов семантического анализа. Использование актуальных библиотек и технологий обеспечивает масштабируемость и возможность адаптации под разные сценарии применения. В работе выполнен обзор методов анализа текстов и алгоритмов выявления заимствований, а также сравнение технологий векторизации, необходимых для оценки сходства документов. Пояснительная записка включает анализ требований, описание разработки и оценку эффективности с применением метрических показателей — точности, полноты и F-меры. В качестве графических материалов приведена диаграмма алгоритма сравнения текстов и иллюстрации работы компонентов системы. Разработанный конвейер повышает качество автоматизированного сравнения документов за счёт корректной подготовки данных и оптимального выбора алгоритмов, что делает решение перспективным для образовательных, научных и корпоративных систем проверки на заимствования. Разработанное программное средство обеспечивает повышение качества и точности автоматизированного сравнения документов за счёт корректной подготовки данных и оптимального выбора алгоритмов векторизации, что делает его перспективным для применения в образовательных, научных и корпоративных системах проверки на заимствования. Проект был выполнен самостоятельно и протестирован на уникальность с помощью системы «Антиплагиат». Процент оригинальности составил 94.92%. Все цитирования и использованные материалы будут четко указаны в \"Списке использованных источников\". Анализ исходных данных и постановка задач 1.1 Анализ исходных данных к курсовому проекту Современные системы обработки текстовой информации требуют высокой степени автоматизации, точности и скорости анализа данных. Объём текстовых документов постоянно растёт, что делает невозможной их ручную обработку и сравнение. Одной из ключевых задач становится качественная подготовка текста — его очистка, нормализация и последующее преобразование в векторные представления, которые являются основой для дальнейших задач машинного обучения, семантического анализа, классификации и поиска похожих документов. Отсутствие стандартизированного конвейера обработки приводит к низкому качеству анализа, ошибкам при сравнении текстов, невозможности корректной оценки семантического сходства, а также значительным временным затратам при работе с большими массивами данных. Эти проблемы особенно проявляются в системах, связанных с проверкой текстов на заимствования, анализом научных работ, обработкой пользовательского контента или построением интеллектуальных поисковых систем. Для решения указанных задач в рамках курсового проекта предлагается разработать модульный Pipeline, обеспечивающий единый и последовательный процесс обработки текстов. Основное внимание уделяется этапам удаления шумов, нормализации, лемматизации, токенизации, а также преобразованию текста в векторные представления с использованием различных современных подходов — от классических статистических методов до нейросетевых эмбеддингов. Создаваемый Pipeline позволит стандартизировать обработку документов, улучшить качество последующего анализа и обеспечить возможность интеграции с алгоритмами сравнения текстов и семантического поиска. Его использование обеспечит повышение точности анализа, уменьшение влияния человеческого фактора и ускорение обработки больших текстовых массивов. Разработка подобной системы будет способствовать созданию надёжных и масштабируемых инструментов анализа текстовой информации и станет важным шагом в направлении автоматизации процессов, связанных с обработкой и сравнением документов. 1.2 Обзор существующих программных средств по теме курсовой работы Обработка текстовой информации и преобразование её в формализованные векторные представления являются ключевыми задачами современных систем анализа данных, поисковых движков, рекомендательных сервисов и алгоритмов машинного обучения. Качество итоговых моделей напрямую зависит от корректности предварительной очистки, нормализации и единообразия представления исходных текстов. В условиях работы с большими корпусами данных особенно важно обеспечить стабильный, воспроизводимый Pipeline, который минимизирует шумы, устраняет артефакты и последовательно формирует готовые к обработке структуры данных. Существующие решения, применяемые для текстовой предобработки и векторизации, предлагают широкий спектр методов — от классических алгоритмов статистической обработки до глубоких нейронных моделей. Тем не менее, многие инструменты ориентированы на узкие задачи, требуют сложной интеграции между собой или не позволяют гибко выстраивать полный конвейер обработки. Это затрудняет получение стабильных результатов и повышает требования к квалификации разработчика. Для анализа были выбраны следующие программные средства и библиотеки: – NLTK– spaCy– Gensim– TensorFlow / Keras Embeddings– HuggingFace Transformers Описание решений представлено в таблице 1.1. Таблица 1.1 – Описание решений Сервис / ПО Краткое описание NLTK Набор инструментов для классической текстовой обработки: токенизация, лемматизация, стоп-слова, синтаксический разбор. spaCy Высокопроизводительная библиотека для промышленной обработки текста, включающая токенизацию, POS-теггинг, лемматизацию и современные модели. Gensim Платформа для обучения моделей Word2Vec, FastText, Doc2Vec и других методов векторизации. TensorFlow / Keras Embeddings Средства для построения нейронных моделей и обучения кастомных эмбеддингов. Transformers (HuggingFace) Современные предобученные модели — BERT, RoBERTa, DistilBERT, обеспечивающие контекстуальные представления текста. Представленные инструменты демонстрируют разные подходы к анализу текста: NLTK ориентирован на академические методы и базовую нормализацию, spaCy — на производительность и промышленное применение, Gensim — на обучение статистических моделей векторизации, а библиотеки TensorFlow и Transformers — на получение высокоточных нейросетевых эмбеддингов. Такой обзор позволяет оценить существующие методы очистки и нормализации текста, а также определить наиболее подходящие подходы к формированию качественных векторных представлений. Для сравнительного анализа возможностей использована таблица 1.2. Таблица 1.2 – Анализ преимуществ и недостатков Критерий сравнения NLTK spaCy Gensim TF/Keras Transformers Разрабатываемый Pipeline Очистка и нормализация текста + + - - - + Готовые модели векторизации - + + + + + Контекстные эмбеддинги - - - + + + Скорость обработки - + + + - + Возможность кастомизации + + + + + + Простота интеграции в Pipeline - + + - - + Поддержка больших данных - + + + + + Анализ показывает, что ни одно из рассмотренных решений не реализует полный циклический конвейер обработки текста \"от сырого ввода до финальной векторизации\" без необходимости сложной интеграции сторонних инструментов. NLTK предоставляет широкий набор функций для очистки, но не обеспечивает современных методов векторизации. Gensim подходит для обучения статистических моделей, однако не решает задачи нормализации текста. Библиотеки на основе Transformers предоставляют высококачественные эмбеддинги, но требуют предварительного этапа подготовки данных, который отсутствует \"из коробки\". Таким образом, построение единой модульной системы, включающей все этапы обработки данных, является обоснованной задачей. Из анализа следует, что: отсутствует единое решение, охватывающее все этапы обработки текста; готовые библиотеки требуют сложной интеграции для построения сквозного Pipeline; современные модели высокочувствительны к качеству входного текста, что повышает значимость нормализации; универсальные облачные системы не подходят для задач с локальными данными и требуют значительных вычислительных ресурсов; ни одна библиотека не обеспечивает адаптивный выбор подхода к векторизации в зависимости от задачи. Разрабатываемый Pipeline должен обеспечить: автоматизированную очистку текста от шумов, спецсимволов и нерелевантных данных; нормализацию текста (токенизацию, лемматизацию, удаление стоп-слов, приведение регистра); поддержку различных методов векторизации, включая TF-IDF, Word2Vec, FastText, BERT-подобные модели; модульность, позволяющую легко заменять или комбинировать этапы обработки; возможность масштабирования и работы с большими корпусами данных; быстрый экспериментальный подбор оптимального метода векторного представления под конкретную задачу. Проведённый анализ подтверждает высокую актуальность разработки единого Pipeline для текстовой обработки. Создание собственного решения: снижает зависимость от разрозненных библиотек; обеспечивает гибкость и воспроизводимость экспериментов; увеличивает точность последующих моделей анализа текста; позволяет адаптировать обработку под специфические корпуса данных. Таким образом, разработка модульного Pipeline является логически обоснованным и необходимым этапом построения современных интеллектуальных систем анализа текста. 1.3 Обоснование и описание выбора языка программирования, средств разработки, используемых технологий и сторонних библиотек В данном курсовом проекте использованы: язык гипертекстовой разметки текста HTML; каскадные таблицы стилей CSS; препроцессор SCSS; язык программирования JavaScript; интегрированная среда разработки VSCode; система контроля версий Git и онлайн-сервис GitHub; сборщик GULP для стилей, скриптов и изображений; для работы с дизайном Figma. HTML – это язык гипертекстовой разметки текста [7-9]. Это набор команд, следуя которым браузеры выводят на монитор различные документы и страницы сайтов. HTML является основным языком разметки для создания структуры веб-страниц. Он является стандартом для создания веб-страниц, поддерживаемым всеми современными браузерами. С помощью HTML можно создавать различные типы веб-страниц, начиная от простых статических страниц и заканчивая сложными интерактивными веб-приложениями. HTML используется для создания структуры веб-страницы, определяя содержимое и его семантику. Он состоит из набора элементов (тегов), каждый из которых определяет определенный тип содержимого. HTML используется для создания основной структуры веб-страниц, которая затем стилизуется с помощью CSS и делается интерактивной с использованием JavaScript. HTML, сокращение от HyperText Markup Language, представляет собой язык разметки текста, который используется для создания веб-страниц и их структуры [7-9]. Этот набор команд определяет, как браузеры должны отображать содержимое документов и страниц сайтов. Будучи основным языком разметки для веб-страниц, HTML является стандартом, поддерживаемым всеми современными браузерами. С его помощью можно создавать разнообразные типы веб-страниц, начиная от простых статических страниц и заканчивая сложными интерактивными веб-приложениями. Одна из ключевых функций HTML заключается в создании структуры веб-страницы и определении семантики её содержимого. HTML состоит из различных элементов, или тегов, каждый из которых определяет определенный тип содержимого на странице. CSS – это формальный язык, предназначенный для описания внешнего вида документа (веб-страницы), написанного с использованием языка разметки [10]. Он играет неотъемлемую роль в веб-разработке, предоставляя средства для стилизации и оформления веб-страниц. С его помощью можно задавать цвета, шрифты, стили, расположение отдельных блоков и другие аспекты представления внешнего вида веб-страниц. Одним из ключевых преимуществ CSS является возможность отделения логической структуры HTML-документа от его визуального оформления. Это способствует созданию более гибких, модульных и легко поддерживаемых веб-сайтов. CSS является стандартом в веб-разработке и поддерживается всеми современными браузерами, что обеспечивает широкую совместимость и надежность. Он предоставляет разработчикам широкий спектр инструментов для создания разнообразных дизайнерских решений, включая возможность задания цветов, шрифтов, размеров, отступов, анимации и многого другого. Основной целью разработки CSS является ограждение и отделение описания логической структуры веб-страницы от описания внешнего вида этой веб-страницы. Такое разделение может увеличить доступность документа, предоставить большую гибкость и возможность управления его представлением, а также уменьшить сложность и повторяемость в структурном содержимом. В данной работе в режиме разработки будет использоваться препроцессор SCSS для более гибкого и быстрого написания стилей, который в итоге соберется в один итоговый CSS файл с помощью сборщика. SCSS обладает расширенным и более читабельным синтаксисом по сравнению с обычным CSS, что позволяет разработчику писать код стилей быстрее и эффективнее, а также облегчает его поддержку в будущем. Большим преимуществом SCSS перед CSS является возможность использования операторов и функций, переменных и миксинов, а также вложенных стилей. Эти возможности значительно упрощают процесс написания и поддержки стилей веб-приложений, делая его более эффективным и удобным для разработчиков [11]. JavaScript (JS) является одним из наиболее распространенных и востребованных инструментов [12][13]. JavaScript обладает универсальностью, позволяя разрабатывать как клиентскую, так и серверную части веб-приложений. Благодаря кроссплатформенной поддержке JavaScript широко применяется на различных устройствах и операционных системах. Активное сообщество разработчиков постоянно развивает новые технологии и библиотеки для улучшения процесса разработки и повышения производительности. JavaScript поддерживает асинхронное программирование и обработку событий, что позволяет создавать отзывчивые и интерактивные веб-приложения. Большой выбор инструментов разработки, включая среды разработки, системы управления версиями и отладчики, делает процесс разработки более эффективным и удобным. В результате JavaScript остается привлекательным выбором для веб-разработки благодаря своей универсальности, широкой поддержке, активному сообществу и большому выбору инструментов. Так же существует множество мощных интегрированных сред разработки (IDE) для веб-сайтов с помощью, JS, HTML, CSS, таких как VSCode, IntelliJ IDEA, WebStorm и другие [14]. Они предоставляют разработчикам удобные инструменты для создания, отладки и тестирования приложений. При разработке программного средства для данной курсовой работы выбор пал на VSCode. VSCode – мощное интегрированное средство разработки (IDE), которое обладает обширным набором инструментов для улучшения процесса написания кода [15]. Одним из его преимуществ является обширный набор операций рефакторинга, таких как переименование переменных и извлечение методов, которые значительно упрощают изменение структуры кода и повышают его читаемость. Кроме того, VSCode предоставляет контекстно-зависимые подсказки и авто дополнение кода, что способствует увеличению производительности и снижению вероятности возникновения ошибок [16]. IDEA, с другой стороны, также предоставляет удобный интерфейс для создания новых проектов и импортирования существующих. Она интегрируется с системами контроля версий, такими как Git, Subversion и Mercurial, обеспечивая удобное отслеживание изменений в коде. Более того, IDEA поддерживает различные языки программирования, включая PHP, Kotlin, JavaScript, Python и многие другие, что делает её универсальным инструментом для разработки в рамках одной среды. Дополнительно, IDEA включает инструменты для работы с базами данных и SQL-запросами [17], что позволяет разработчикам управлять и редактировать таблицы, выполнять запросы и многое другое, не выходя из среды разработки. Кроме того, с помощью плагинов и расширений разработчики могут расширять функциональность IDE и добавлять дополнительные инструменты по мере необходимости. Выбор системы контроля версий Git и онлайн-сервиса GitHub обоснован исходя из ряда ключевых преимуществ и возможностей, которые они предоставляют для эффективного управления кодом и совместной работы над проектами [18]. Git является одной из самых популярных и широко используемых систем контроля версий в мире разработки программного обеспечения. Его распространенность обусловлена простотой в использовании, распределенной структурой, высокой скоростью работы и мощными функциями ветвления и слияния [19]. Git позволяет эффективно отслеживать изменения в коде, возвращаться к предыдущим версиям проекта и управлять конфликтами в изменениях. GitHub, с другой стороны, является онлайн-платформой для хостинга Git-репозиториев, которая предоставляет дополнительные инструменты для совместной работы над проектами [20]. Он обладает широким набором функций, таких как задачи и проблемы (issues), запросы на объединение (pull requests), вики, управление правами доступа и многое другое. GitHub обеспечивает удобный и простой способ совместной разработки, обратной связи и координации команды разработчиков. Использование Git и GitHub позволяет разработчикам эффективно организовывать рабочий процесс, отслеживать изменения в коде, реагировать на обратную связь со стороны других участников проекта, а также обеспечивать надежное хранение и резервное копирование кодовой базы. Благодаря их распространенности и популярности, Git и GitHub являются стандартом в индустрии разработки программного обеспечения и обеспечивают надежную основу для успешного ведения проектов. Выбор сборщика Gulp для обработки стилей, скриптов и изображений обусловлен несколькими факторами, которые способствуют эффективной и удобной разработке веб-приложений [21]. Прежде всего, Gulp является мощным инструментом автоматизации задач, который позволяет разработчикам оптимизировать процесс сборки и развертывания проекта. Он обладает простым и интуитивно понятным синтаксисом, что делает его легко доступным для новичков и удобным для опытных разработчиков. С помощью Gulp можно легко настроить и выполнять различные задачи, такие как компиляция препроцессоров CSS в обычный CSS, минификация и оптимизация стилей и скриптов, сжатие изображений, автоматическое обновление браузера при изменении файлов и многое другое. Это позволяет существенно ускорить процесс разработки, сделать код более оптимизированным и улучшить производительность веб-приложения. Gulp также обладает богатой экосистемой плагинов, которые позволяют расширять его функциональность и адаптировать под конкретные потребности проекта. Благодаря этому разработчики могут выбирать из большого количества плагинов те, которые соответствуют их требованиям и использовать их для решения конкретных задач. Использование сборщика Gulp для обработки стилей, скриптов и изображений обеспечивает более эффективную и удобную разработку веб-приложений, улучшает процесс сборки проекта и помогает создать более оптимизированный и производительный код. Figma – это мощный инструмент для дизайна, который позволяет создавать интерфейсы и макеты веб-приложений с учетом современных требований и тенденций [22]. Figma предоставляет возможность совместной работы над проектом, что позволяет всем участникам команды, включая дизайнеров и разработчиков, работать над одним и тем же макетом одновременно. Это снижает время на коммуникацию и ускоряет процесс разработки. Использование Figma для разработки предоставляет разработчикам мощный инструмент для создания качественного дизайна, улучшает командную работу, ускоряет процесс разработки и помогает создать более удобные и привлекательные веб-приложения. Наличие раннее описанных мощных и многофункциональных библиотек, взаимодействие с HTML, CSS, JS, а также крайне удобной среды разработки с множеством дополнительных функций, ускоряющих процесс разработки засчет своей производительности, предоставляет огромное количество возможностей для реализации массивного функционала программного средства. Также данное программное средство имеет огромный плюс в виде своей адаптивности под разные операционные системы, что позволит не испытывать проблем с его поддержкой в будущем. 1.4 Постановка задач на курсовую работу Целью курсового проекта является проектирование и разработка веб-сервиса для проверки оригинальности различных работ, включая курсовые, дипломные, научные статьи и другие материалы, с использованием репозитория БГУИР. Основное назначение системы — предоставление пользователям возможности проверки уникальности текстов и предотвращения плагиата на основе анализа содержимого репозитория БГУИР. Программное обеспечение должно поддерживать русский язык, а графический интерфейс веб-сервиса должен включать такие страницы, как главная страница, авторизация, личный кабинет и пользовательский кабинет с соответствующей ролью. Разработка веб-сервиса предполагает выполнение нескольких этапов. На первом этапе проводится обзор предметной области, анализируются существующие программные средства для проверки оригинальности текстов, сравниваются их возможности с функционалом разрабатываемого приложения и обосновывается выбор используемых технологий, языков программирования и инструментов разработки. Второй этап включает проектирование архитектуры программного средства, создание базы данных, разработку алгоритмов функционирования приложения и проектирование пользовательского графического интерфейса. Основным результатом второго этапа является работоспособное программное средство, способное проверять тексты на оригинальность и предоставлять пользователю детальные отчеты о совпадениях. На третьем этапе составляется инструкция по развертыванию и эксплуатации веб-сервиса, описываются основные функции системы и рекомендации по использованию всех возможностей приложения. Завершающий этап работы посвящен оформлению пояснительной записки и графических материалов. В рамках данного этапа разрабатываются ER-диаграмма базы данных, UML-диаграммы состояний и вариантов использования, а также графический интерфейс программного средства, отражающий все элементы взаимодействия пользователя с системой. Таким образом, курсовой проект включает комплексную разработку веб-сервиса антиплагиата, начиная с анализа предметной области и выбора технологий, и заканчивая созданием полноценного интерфейса и технической документации, что обеспечивает полное соответствие требованиям к современным веб-приложениям для проверки оригинальности текстов. 1.5 Выводы по главе Анализ исходных данных показал, что при обработке текстовой информации ключевыми проблемами остаются разрозненность данных, наличие большого количества шумов, различия в форматах представления текста и отсутствие единообразных правил предварительной подготовки. Эти факторы значительно снижают качество последующего анализа, затрудняют применение алгоритмов машинного обучения и приводят к непредсказуемости результатов. В условиях увеличивающихся объёмов текстовых данных и растущих требований к точности семантических моделей необходимость создания стандартизированного и модульного Pipeline становится особенно актуальной. Выявлено, что существующие подходы к обработке текста часто требуют ручного вмешательства, не обеспечивают достаточной гибкости и плохо масштабируются при работе с большими корпусами данных. Это негативно отражается на качестве векторных представлений, которые напрямую зависят от корректности этапов очистки и нормализации. Многоэтапная предобработка текста — удаление шумов, токенизация, лемматизация, нормализация регистра, удаление стоп-слов, корректировка знаков препинания — требует последовательного и автоматизированного выполнения, что подчеркивает важность разработанного конвейера. Создание Pipeline позволит обеспечить стабильную, воспроизводимую и масштабируемую обработку текста на всех этапах. Такой подход не только снижает влияние человеческого фактора, но и повышает точность дальнейшего анализа — включая сравнение текстов, обучение моделей, поиск по смыслу и построение эмбеддингов. Разработка целостного решения также открывает возможность использования различных методов векторизации — от классических моделей (TF-IDF, Bag-of-Words) до современных нейросетевых представлений (Word2Vec, FastText, BERT-подобные модели). Таким образом, проведённый анализ подтверждает актуальность, необходимость и практическую ценность разработки модульного Pipeline. Он позволит создавать качественные векторные представления текста, обеспечит высокую скорость обработки данных, упростит интеграцию новых алгоритмов и станет фундаментом для построения надёжных систем анализа, сравнения и классификации текстов. 2 ОБЗОР СУЩЕСТВУЮЩИХ МЕТОДОВ И АЛГОРИТМОВ В ОБЛАСТИ СЕМАНТИЧЕСКОГО АНАЛИЗА ТЕКСТОВ И ОБНАРУЖЕНИЯ ЗАИМСТВОВАНИЙ 2.1 Обзор существующих методов и алгоритмов семантического анализа текста Семантический анализ текста представляет собой важную задачу в области обработки естественного языка (NLP), направленную на извлечение смысла из текстовых данных. В последние десятилетия семантический анализ пережил значительное развитие благодаря достижениям в области машинного обучения и глубокого обучения. Основной целью семантического анализа является не только извлечение информации, но и понимание контекста, отношений между словами и концептами в тексте. Классические методы семантического анализа: TF-IDF (Term Frequency - Inverse Document Frequency): Этот метод является одним из самых популярных и широко используемых в классическом семантическом анализе текста. Он работает путем оценки значимости каждого слова в тексте на основе его частоты в документе и в коллекции документов. Основная идея заключается в том, что если слово часто встречается в документе, но редко в других документах, оно имеет высокое значение для данного текста. Однако, TF-IDF не учитывает контекст слова и его отношения с другими словами, что ограничивает его использование в более сложных задачах, таких как анализ смысловых связей между словами. LDA (Latent Dirichlet Allocation): Это вероятностная модель для тематического моделирования, которая позволяет извлекать скрытые тематические структуры в коллекции документов. В LDA каждый документ представляется как смесь нескольких тем, а каждая тема состоит из множества слов, связанных с определенной вероятностью. Модель помогает выявлять иерархические и скрытые связи между словами и темами, что делает её эффективной для анализа больших текстовых данных. LDA находит применение в задачах классификации и кластеризации текстов. Word2Vec и GloVe: Эти методы представляют собой алгоритмы, преобразующие слова в многомерные векторы, что позволяет математически моделировать смысл слов и их отношения. Word2Vec, например, обучается на большом количестве текстов и использует нейронные сети для создания векторных представлений слов. Эти векторы обладают свойствами, такими как близость слов с похожими значениями в многомерном пространстве. GloVe также использует глобальную информацию о словах в корпусе текста для создания векторных представлений, но с применением статистических методов. Оба подхода являются мощными инструментами для анализа контекста и семантики слов, и их использование стало основой для дальнейших исследований и разработок в области NLP. Современные методы семантического анализа в значительной степени основываются на технологиях глубокого обучения, что позволяет достигать более точных и сложных результатов. Одним из важнейших достижений в этой области является использование моделей на основе архитектуры трансформеров. BERT (Bidirectional Encoder Representations from Transformers): Это одна из самых успешных и мощных моделей для семантического анализа текста. В отличие от классических моделей, таких как Word2Vec, которые обучаются только на одном направлении контекста (слева направо или справа налево), BERT использует двустороннюю архитектуру, что позволяет учитывать контекст как с левой, так и с правой стороны слова в предложении. Это значительно улучшает точность в задачах, таких как анализ тональности, распознавание именованных сущностей и классификация текста. BERT был предварительно обучен на больших объемах текстовых данных и показал выдающиеся результаты на множестве задач NLP. GPT (Generative Pretrained Transformer): В отличие от BERT, который ориентирован на двусторонний контекст, GPT использует однонаправленное предсказание следующего слова, что делает его особенно полезным для задач, связанных с генерацией текста. Модель обучена на огромных корпусах текстов и способна генерировать связные и осмысленные фрагменты текста, что делает её идеальной для таких задач, как машинный перевод, создание диалоговых систем и генерация текстов. GPT широко используется в современном NLP благодаря своей способности \"понимать\" контекст и генерировать текст, который выглядит естественно. Sentence-Transformers: Эта модель была специально разработана для векторизации предложений, что делает её идеальной для задач, таких как поиск схожих текстов, семантический поиск и выявление заимствований. В отличие от обычных моделей, которые работают с отдельными словами, Sentence-Transformers обучены на паре предложений и позволяют эффективно сравнивать не только отдельные слова, но и целые фразы или предложения. Это значительно улучшает результаты в задачах, связанных с анализом схожести между текстами. 2.2 Технологии и инструменты для выявления заимствований в текстовых документах Обнаружение заимствований является одной из ключевых задач для систем антиплагиата. В современной науке и технике было разработано множество методов и технологий, направленных на эффективное обнаружение плагиата и схожих текстов. Алгоритмы на основе схожести текстов: Шинглование (Shingling): Этот метод заключается в разбиении текста на небольшие фрагменты, называемые шинглами. Каждый шингл представляет собой последовательность из нескольких слов или символов. Затем шинглы сравниваются между собой, и на основе этого вычисляется степень схожести между текстами. Этот подход полезен для обнаружения точных совпадений, однако он не всегда эффективен для выявления более сложных форм заимствования, таких как парафразирование. MinHash: Алгоритм MinHash используется для вычисления схожести между большими объемами данных, что делает его идеальным для применения в системах, где необходимо сравнивать огромные массивы текстов. Этот алгоритм работает на основе хеширования и позволяет оценить сходство между двумя текстами с минимальными вычислительными затратами, что делает его очень подходящим для задач с большими объемами данных. Использование методов машинного обучения и глубокого обучения в системах антиплагиата позволяет значительно улучшить точность выявления заимствований и более эффективно обрабатывать сложные случаи плагиата. Методы обучения с учителем: В этих методах алгоритмы обучаются на размеченных данных, где каждый текст помечен как оригинальный или заимствованный. Такие методы могут использовать различные классификаторы, такие как SVM (Support Vector Machine), Random Forests и Naive Bayes. Алгоритмы обучаются на признаках текста, таких как частотность слов, длина предложений, и другие, чтобы классифицировать текст как оригинальный или заимствованный. Глубокое обучение: Нейронные сети, такие как CNN (Convolutional Neural Networks) и RNN (Recurrent Neural Networks), используются для более сложных задач, таких как обнаружение скрытых заимствований или парафраз. Эти модели способны анализировать текст на более глубоком уровне и выявлять неочевидные заимствования, что значительно улучшает эффективность систем антиплагиата. Совмещение различных методов анализа, таких как шинглование, MinHash и методы машинного обучения, позволяет создавать более точные и эффективные системы для выявления заимствований. Например, комбинированное использование алгоритмов для вычисления схожести и классификаторов на основе машинного обучения позволяет повысить как точность, так и полноту обнаружения плагиата. 2.3 Основные подходы к семантическому анализу текстов Семантический анализ текста включает в себя различные подходы, которые помогают выявлять смысл и структуру текста. В последние годы развитие методов на основе нейронных сетей, таких как трансформеры, существенно повысило точность и эффективность этих методов. Семантические векторные представления: Word2Vec и GloVe: Эти методы создали новую парадигму в обработке текстов, позволив преобразовать слова в векторные представления. Такие вектора позволяют вычислять сходство между словами, что делает возможным анализ контекста и семантики слов. Однако, для анализа более сложных смысловых связей, таких как отношения между фразами или предложениями, эти методы оказываются недостаточными. BERT и GPT: Новые методы, такие как BERT, революционизировали подход к семантическому анализу текста, так как они позволяют учитывать контекст в пределах всего предложения. Это делает модели на базе BERT намного более точными и гибкими в решении задач, связанных с пониманием смысла текста. Технологии на базе трансформеров, такие как BERT и GPT, открыли новые горизонты в семантическом анализе текста, позволяя моделям анализировать не только отдельные слова, но и их контекст в предложении и абзаце. Эти модели являются основой для более точного и глубокого анализа текста, который необходим для задач, таких как анализ плагиата, понимание текста и генерация контента. 2.4 Метрики оценки эффективности алгоритмов: точность, полнота, F-мера Для оценки эффективности алгоритмов семантического анализа и обнаружения заимствований применяются несколько ключевых метрик: Точность – оценивает долю правильных предсказаний среди всех положительных классификаций. Это важная метрика для задач, где необходимо минимизировать количество ложных срабатываний. Полнота – измеряет долю верных положительных предсказаний среди всех реальных положительных примеров. Это критично в задачах, где важно не пропустить ни одно заимствование. F-мера – комбинирует точность и полноту, давая единый показатель, который помогает сбалансировать оба аспекта. F-мера полезна для систем, где важно учитывать как ложные срабатывания, так и пропущенные заимствования. 2.5 Выводы по главе В этой главе были рассмотрены ключевые методы и алгоритмы для семантического анализа текста и обнаружения заимствований. Методы на базе трансформеров, такие как BERT и GPT, значительно улучшили результаты в задачах анализа текста. Для эффективного обнаружения заимствований важным является сочетание различных методов, включая шинглование, алгоритмы машинного обучения и нейросети, что позволяет повысить точность и полноту системы антиплагиата. 4.1. Анализ исходных данных и постановка задач для курсовой работы4.1.1. Анализ исходных данных к курсовой работе 4.1.2. Обзор существующих программных средств по теме курсовой работы 4.1.3. Обоснование и описание выбора языка программирования, средств разработки, используемых технологий и сторонних библиотек 4.1.4. Постановка задач на курсовую работу 4.1.5. Выводы по главе 4.2. Обзор существующих методов и алгоритмов в области семантического анализа текстов и обнаружения заимствований4.2.1. Обзор существующих методов и алгоритмов семантического анализа текста 4.2.2. Технологии и инструменты для выявления заимствований в текстовых документах 4.2.3. Основные подходы к семантическому анализу текстов 4.2.4. Метрики оценки эффективности алгоритмов: точность, полнота, F-мера 4.2.5. Выводы по главе 4.3. Предварительная обработка документов для их векторного представления4.3.1. Методы и инструменты предварительной обработки документов 4.3.2. Требования к конечному представлению предварительной обработки текстовых документов 4.3.3. Основные этапы предварительной обработки документов4.3.3.1. Очистка текста. Назначение и описание этапа4.3.3.2. Лемматизация и нормализация. Назначение и описание этапа4.3.3.3. Токенизация текста. Назначение и описание этапа 4.3.4. Математическое описание предварительной обработки документов 4.3.5. Оценка производительности алгоритма предварительной обработки текста 4.3.6. Выводы по главе ЗАКЛЮЧЕНИЕ После завершения проекта была достигнута цель - создан веб-сервис для проверки оригинальности различных работ на основе репозитория БГУИР. Данный сервис разработан при помощи HTML, CSS, JS для разработки фронтенд части проекта. Для использования сервиса необходимо перейти по ссылке, которая будет доступна всем пользователям. Веб-сервис поддерживает работу на всех популярных устройствах и операционных системах, а также является кроссплатформенным. Веб-сервис легок в использовании: оно обладает интуитивно понятным интерфейсом, и не имеет никаких лишний функций, кроме как работы антиплагиата, что делает его простым в эксплуатации. Этот сервис может быть полезен для студентов, преподавателей и других сотрудников БГУИР. Студенты, использующие данный веб-сервис смогут загружать свои работы для проверки на уникальность. После загрузки работы студент получит детальный отчет о проценте уникальности текста, который сможет скачать в формате pdf, а также о возможных источниках совпадений. Таким образом, данный веб-сервис может значительно облегчить процесс проверки оригинальности работ и помочь пользователям быстро и эффективно получить необходимую информацию. В будущем систему можно дополнить новыми возможностями и функционалом для еще более удобного использования. СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ [1] БГУИР ГОСТ СТП 01–2017 [Электронный ресурс]. – Режим доступа: https://www.bsuir.by/m/12_100229_1_122976.pdf − Дата доступа: 10.05.2024. [2] Антиплагиат [Электронный ресурс]. – Режим доступа: https://antiplagiat.ru/ − Дата доступа: 12.04.2024. [3] PlagScan [Электронный ресурс]. – Режим доступа: https://www.turnitin.com/ − Дата доступа: 12.04.2024. [4] Text.ru [Электронный ресурс]. – Режим доступа: https://text.ru/doc-check − Дата доступа: 12.04.2024. [5] Antiplagius [Электронный ресурс]. – Режим доступа: https://antiplagius.ru/− Дата доступа: 12.04.2024. [6] BE1.ru [Электронный ресурс]. – Режим доступа: https://be1.ru/antiplagiat-online/ − Дата доступа: 12.04.2024. [7] MDN Web Docs [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/HTML − Дата доступа: 10.03.2024. [8] W3Schools [Электронный ресурс]. – Режим доступа: https://www.w3schools.com/html/ − Дата доступа: 05.03.2024. [9] Основы HTML – Изучение веб-разработки [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/HTML – Дата доступа: 08.03.2024. [10] Руководство по CSS: каскадные таблицы [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Web/CSS/Reference – Дата доступа: 10.03.2024. [11] Основы SCSS [Электронный ресурс]. – Режим доступа: https://sass-scss.ru/guide/ – Дата доступа: 12.03.2024. [12] Современный учебник JavaScript [Электронный ресурс]. – Режим доступа: https://learn.javascript.ru/ – Дата доступа: 14.03.2024. [13] UI Дока JavaScript [Электронный ресурс]. – Режим доступа: https://doka.guide/js/ – Дата доступа: 14.03.2024. [14] Интегрированная среда разработки [Электронный ресурс]. – Режим доступа: https://ru.wikipedia.org/wiki/Интегрированная_среда_разработки – Дата доступа: 06.03.2024. [15] VSCode [Электронный ресурс]. – Режим доступа: https://code.visualstudio.com/ – Дата доступа: 06.03.2024. [16] VS Code настройка установка плагины [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=nxCLXMBl4e4 – Дата доступа: 06.03.2024. [17] MySQL [Электронный ресурс]. – Режим доступа: https://www.mysql.com/ – Дата доступа: 05.04.2024. [18] Git и GitHub курс для новичков [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=zZBiln_2FhM – Дата доступа: 17.03.2024. [19] GIT [Электронный ресурс]. – Режим доступа: https://git-scm.com/ – Дата доступа: 20.04.2024. [20] GitHub [Электронный ресурс]. – Режим доступа: https://blog.hubspot.com/website/what-is-github-used-for – Дата доступа: 12.04.2024. [21] Gulp установка настройка плагины [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=jU88mLuLWlk&t=2055s – Дата доступа: 12.03.2024. [22] Гид по Figma для разработчиков [Электронный ресурс]. – Режим доступа: https://www.figma.com/community/file/886207890389884742 – Дата доступа: 12.03.2024. [23] Алексеев, В. Ф. Структуры и базы данных. Пособие для курсового проектирования: пособие / В. Ф. Алексеев, И. Н. Богатко, Г. А. Пискун. – Минск: БГУИР, 2017. – 84 с.: ил. [24] PostgreSQL: Документация – Режим доступа: https://postgrespro.ru/docs/postgresql – Дата доступа: 04.04.2024. [25] Принципы UI/UX. – Режим доступа: https://habr.com/ru/companies/SECL_GROUP/articles/182208/ – Дата доступа: 10.04.2024. [26] Зачем нужно тестирование? Когда оно начинается и когда заканчивается, какие задачи стоят перед тестированием программного обеспечения? [Электронный ресурс]. – Режим доступа: https://dzen.ru/a/ZGEgrWptlGbZJKJi– Дата доступа: 05.01.2024. [27] Что такое хостинг [Электронный ресурс]. – Режим доступа: https://hostiq.ua/info/what-is-hosting/ – Дата доступа: 04.05.2024. [28] Руководство по панели управления Beget [Электронный ресурс]. – Режим доступа: https://beget.com/ru/kb/manual – Дата доступа: 04.05.2024. [29] Выгрузка проекта на хостинг [Электронный ресурс]. – Режим доступа: https://www.youtube.com/watch?v=UPnVcTZUwXE&t=854s – Дата доступа: 04.05.2024. [30] Разработанный веб-сервис [Электронный ресурс]. Режим доступа: http://dimaracb.beget.tech/ – Дата доступа: 07.05.2024. ПРИЛОЖЕНИЕ А (Обязательное)Отчёт о проверке на заимствования в системе «Антиплагиат» Рисунок А.1 – Отчет о проверке на заимствования в система «Антиплагиат» ПРИЛОЖЕНИЕ Б (обязательное) Листинги программного кода Файл main.html <main class=\"auth-page\"> <section class=\"auth\"> <div class=\"container\"> <div class=\"auth__container\"> <h1 class=\"auth__title title\">Личный кабинет</h1> <form class=\"auth__form\" id=\"auth-form\"> <div class=\"auth__form-input input\"> <label class=\"input__label\" for=\"login\">Логин</label> <input autocomplete=\"off\" class=\"input__input\" type=\"text\" placeholder=\"Введите логин\" name=\"login\" /> <div class=\"input__btn-notify js-notify\" data-notify=\"Менее 8 символов\"> <svg> <use xlink:href=\"assets/img/sprite.svg#input-error\"></use> </svg> </div> <div class=\"input__error\">Некорректный формат логина!</div> </div> <div class=\"auth__form-input input input--pass\"> <label class=\"input__label\" for=\"login\">Пароль</label> <input autocomplete=\"off\" class=\"input__input\" type=\"password\" placeholder=\"Введите пароль\" name=\"password\" /> <button type=\"button\" class=\"input__btn\"> <svg> <use xlink:href=\"assets/img/sprite.svg#pass-open\"></use> </svg> <svg> <use xlink:href=\"assets/img/sprite.svg#pass-close\"></use> </svg> </button> <div class=\"input__btn-notify js-notify\" data-notify=\"Менее 8 символов\"> <svg> <use xlink:href=\"assets/img/sprite.svg#input-error\"></use> </svg> </div> <div class=\"input__error\">Некорректный формат пароля!</div> </div> <button class=\"auth__form-btn btn btn-def\" form=\"auth-form\" type=\"submit\">Войти</button> </form> <div class=\"auth__content\"> <div class=\"auth__content-block\"> <h2 class=\"auth__content-title\">Вы в первый раз на нашем сайте?</h2> <p>Учетные данные для авторизации аналогичны тем, которые используются для доступа к ИИС БГУИР.</p> <p> Логин для студентов - номер студенческого билета, для преподавателей - имя почтового ящика БГУИР без @bsuir.by. </p> </div> <div class=\"auth__content-block\"> <h2 class=\"auth__content-title\"> Что делать, если логин/пароль <br /> не работает? </h2> <p> Если самостоятельно сбросить пароль не удалось, воспользуйтесь пунктом <a href=\"https://courses.bsuir.by/customforms/form1.html\">«Восстановление пароля»</a> в <a href=\"https://courses.bsuir.by/customforms/form1.html\">форме связи с техподдержкой.</a> </p> </div> </div> </div> </div> </section> @include('../templates/btnUp.html') Файл main.html .header { background: $blue400; &__container { @include flexCenterBetween; padding: 10px 0; height: 70px; } &__menus { position: relative; } &__btn { display: flex; align-items: center; column-gap: 5px; cursor: pointer; &.--active { .header__btn-arrow { transform: rotate(180deg); svg { background-color: $white; fill: $blue400; } } } } &__btn-icon { border-radius: 50%; @include sizes(50px, 50px); background-color: $white; @include flexCenter; svg { @include sizes(25px, 25px); stroke: $blue400; fill: none; stroke-width: 1.5; } } &__btn-arrow { @include transition(transform); @include sizes(25px, 25px); } &__btn-arrow svg { fill: $white; stroke: none; background: none; border-radius: 50%; transition: fill 0.2s ease, background 0.2s ease; } &__menu { border: 1px solid $blue400; padding: 15px 15px 15px 10px; border-radius: 8px; background-color: $blue50; @include flexColumn; row-gap: 8px; position: absolute; top: 42px; right: 0; width: 183px; @include hidden; z-index: -2; &.--active { @include visible; z-index: 2; } svg { fill: none; stroke: $blue400; } } &__menu-item { display: flex; align-items: center; column-gap: 5px; span { border-bottom: 1px solid transparent; @include regular14; @include transition(border-color); } @include hover { svg { &:first-child { @include hidden; } &:last-child { @include visible; } } span { color: $blue400; border-color: $blue400; } } } &__menu-icon { position: relative; @include sizes(20px, 20px); svg { transition: opacity 0.2s ease, visibility 0.2s ease; position: absolute; &:first-child { fill: none; stroke: $blue400; @include visible; } } } } Файл btn-up.js document.addEventListener('DOMContentLoaded', () => { const btnUp = document.querySelector('.js-btn-up'); btnUp.addEventListener('click', () => { window.scrollTo({ top: 0, behavior: 'smooth', }); }); }); ПРИЛОЖЕНИЕ В (Обязательное) Ведомость курсового проекта",
      "wordCount": 5765,
      "uploadDate": "2026-01-30T14:33:59.046Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        261718,
        300794,
        35456,
        56924,
        40675,
        53090,
        64575,
        100158,
        72007,
        61833,
        79417,
        60703,
        80905,
        50633,
        90800,
        199641,
        442972,
        80489,
        56184,
        49845,
        49372,
        64880,
        91694,
        161388,
        179789,
        542866,
        33077,
        102327,
        51127,
        131290,
        2373,
        82281,
        114802,
        152544,
        19382,
        51155,
        128606,
        26761,
        417176,
        66273,
        726392,
        206183,
        176030,
        127195,
        64093,
        247307,
        249113,
        229934,
        7451,
        140947,
        152863,
        363262,
        200403,
        36331,
        251881,
        35737,
        44206,
        130099,
        46953,
        190278,
        132845,
        96494,
        27987,
        46854,
        138436,
        169696,
        2274,
        47931,
        26305,
        138982,
        200468,
        173350,
        13049,
        4509,
        83768,
        68910,
        34560,
        240433,
        109757,
        63523,
        103466,
        53068,
        65550,
        33453,
        19657,
        27898,
        168631,
        52509,
        132017,
        213007,
        229145,
        10376,
        186383,
        66361,
        128544,
        119660,
        41640,
        226053,
        83507,
        171660,
        163919,
        46590,
        24411,
        124391,
        40686,
        7003,
        25243,
        105866,
        246,
        108284,
        104127,
        144925,
        74624,
        10847,
        600794,
        87067,
        3238,
        116178,
        12127,
        37502,
        151466,
        117086,
        593468,
        18237,
        11781,
        290401,
        27137,
        37535
      ],
      "shingleCount": 15680,
      "originalityPercent": 66
    },
    {
      "id": 58,
      "title": "Лаб_06_Полная_цепочка_CI_CD_на_одном_компьютере_с_Java,_Maven,_Git",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "Лаб_06_Полная_цепочка_CI_CD_на_одном_компьютере_с_Java,_Maven,_Git.docx",
      "filePath": "data/uploads/1769783778202_Лаб_06_Полная_цепочка_CI_CD_на_одном_компьютере_с_Java__Maven__Git.docx",
      "content": "ПРАКТИКА Лаб. 06. Полная цепочка CI/CD на одном компьютере с Java, Maven, Git и Jenkins https://www.guru99.com/ru/jenkins-tutorial.html -— пошаговое руководство для новичков https://slurm.io/jenkins-course?ysclid=mi1nb9uqoe128557025 https://habr.com/ru/companies/slurm/articles/691876/?ysclid=mi1ncptnnh871932764 https://curiousdevops.com/?ysclid=mi1ulyrjo7599073883 nuancesprog.ru !!! Много статей !!! Модель процесса: Команда из нескольких разработчиков работает над одним Java-проектом, а сборка, тесты и релизы автоматически проходят через Jenkins. Ниже пример — минималистичный пример, который можно развернуть на одном ПК. Он демонстрирует ветвление, PR-поток, автоматические сборки, тесты, артефакты и условные релизы. ОКРУЖЕНИЕ: Java: установи JDK (например, jdk 17 или Jdk 21). Maven: установи Maven (например, 3.9.x). Git: установи Git. Jenkins: установи Jenkins (LTS). Для быстрого старта локальная установка curiousdevops.com. Архитектура процесса Репозиторий: локальный Git (можно GitHub/GitLab, но для демо достаточно локального). Ветвление: feature-ветки от develop, pull request в develop, релиз — merge в main (или master). Сборка: Maven — компиляция, тесты, сборка артефакта. CI: Jenkins автоматически собирает ветки и PR, публикует отчёты, артефакты. CD (локально): условный шаг развёртывания (например, запуск JAR после успешной сборки main, или master). Примеры пайплайна с Jenkins+Git+Maven можно посмотреть в туториалами и демо-репозиториях curiousdevops.com Github CI/CD на одном ПК с Java, Maven, Git и Jenkins Структура проекта java-maven-ci-demo/ ├─ pom.xml ├─ Jenkinsfile └─ src/ ├─ main/java/com/example/App.java └─ test/java/com/example/AppTest.java Корень проекта: pom.xml — конфигурация Maven. Jenkinsfile — конвейер Jenkins (Declarative Pipeline). src/main/java/com/example/App.java — прикладной код java. src/test/java/com/example/AppTest.java — модульные тесты JUnit 5. Настройка окружения Установить: JDK, Maven (3.9+), Git, Jenkins (LTS). Создать локальный bare‑репозиторий (репозиторий на сервере): Windows: git init --bare C:\\repos\\java-maven-ci-demo.git У меня: E:\\java-maven-ci-demo>git init --bare E:\\repos\\java-maven-ci-demo.git Инициализация пустого Git repository in E:/repos/java-maven-ci-demo.git/ Клонировать для двух «разработчиков»: devA: git clone file:///E:/repos/java-maven-ci-demo.git E:\\work\\devA E:\\java-maven-ci-demo>git init --bare E:\\repos\\java-maven-ci-demo.git Initialized empty Git repository in E:/repos/java-maven-ci-demo.git/ E:\\java-maven-ci-demo>git clone file:///E:/repos/java-maven-ci-demo.git E:\\work\\devA Cloning into 'E:\\work\\devA'... warning: You appear to have cloned an empty repository. git clone file:///E:/repos/java-maven-ci-demo.git E:\\work\\devB E:\\java-maven-ci-demo>git clone file:///E:/repos/java-maven-ci-demo.git E:\\work\\devB Cloning into 'E:\\work\\devB'... warning: You appear to have cloned an empty repository. У меня получился разбросанные E:\\repos\\java-maven-ci-demo.git и: E:\\work\\devA и E:\\work\\devB . Для простоты работы лучше объединить их в каком-то родительском каталоге. Добавить файлы ниже в один из рабочих клонов, закоммитить и пушнуть: git add . git commit -m \"Initial project with Maven, tests and Jenkins pipeline\" git push origin main pom.xml <!-- POM-файл Maven описывает проект, его зависимости, плагины и процесс сборки. Этот пример собирает исполняемый JAR, запускает JUnit 5 тесты и формирует отчёт покрытия JaCoCo. --> <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> <!-- Версия модели POM --> <modelVersion>4.0.0</modelVersion> <!-- Координаты артефакта: группа, имя, версия --> <groupId>com.example</groupId> <artifactId>java-maven-ci-demo</artifactId> <version>1.0.0</version> <!-- Общие свойства проекта --> <properties> <!-- Целевая версия Java (JDK 17) --> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <!-- Кодировка исходников --> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <!-- Версия JUnit 5 --> <junit.jupiter.version>5.10.2</junit.jupiter.version> </properties> <!-- Зависимости проекта --> <dependencies> <!-- JUnit Jupiter — модульные тесты (scope test: не попадает в релизный JAR) --> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>${junit.jupiter.version}</version> <scope>test</scope> </dependency> </dependencies> <!-- Конфигурация сборки --> <build> <plugins> <!-- maven-jar-plugin: сборка исполняемого JAR с манифестом (mainClass) --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jar-plugin</artifactId> <version>3.3.0</version> <configuration> <archive> <manifest> <!-- Добавить Class-Path в манифест (если есть внешние зависимости) --> <addClasspath>true</addClasspath> <!-- Главный класс с методом main --> <mainClass>com.example.App</mainClass> </manifest> </archive> </configuration> </plugin> <!-- JaCoCo: инструмент покрытия кода тестами --> <plugin> <groupId>org.jacoco</groupId> <artifactId>jacoco-maven-plugin</artifactId> <version>0.8.12</version> <executions> <!-- Агент для сбора покрытия подключается перед фазой тестирования --> <execution> <goals> <goal>prepare-agent</goal> </goals> </execution> <!-- Генерация HTML-отчёта после выполнения тестов --> <execution> <id>report</id> <phase>test</phase> <goals> <goal>report</goal> </goals> </execution> </executions> </plugin> <!-- Surefire: запуск модульных тестов (JUnit 5) на фазе test --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-surefire-plugin</artifactId> <version>3.2.5</version> <configuration> <!-- Совместимость модулей: отключение module path для простоты --> <useModulePath>false</useModulePath> </configuration> </plugin> </plugins> </build> </project> Приложение // src/main/java/com/example/App.java package com.example; /** * Простейшее Java-приложение, которое демонстрирует бизнес-метод greet() * и точку входа main(). Этот класс попадёт в исполняемый JAR. */ public class App { /** * Точка входа. При запуске через `java -jar` будет выполнен метод main(). * результат работы бизнес-метода greet(). * */ public static void main(String[] args) { System.out.println(greet(\"World\")); } /** * Бизнес-метод: формирует приветствие. * */ public static String greet(String name) { // Здесь могла бы быть любая логика — валидация, обработка и т.п. return \"Hello, \" + name + \"!\"; } } Тесты // src/test/java/com/example/AppTest.java package com.example; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; /** * Модульный тест для бизнес-метода greet(). Запускается Surefire-плагином Maven. * Результаты тестов будут собраны Jenkins и показаны в отчёте JUnit. */ class AppTest { /** * Базовый тест: проверяем, что greet(\"World\") возвращает ожидаемое значение. * В реальном проекте добавьте больше тестов (пограничные случаи, null, длинные строки). */ @Test void testGreet() { assertEquals(\"Hello, World!\", App.greet(\"World\")); } } Jenkinsfile (Pipeline) /* Declarative Pipeline для Jenkins. Демонстрирует полный цикл: checkout → build → test → package → отчёты → (условный) деплой. Работает как на локальном Jenkins, так и на CI-сервере. */ pipeline { // Где будет выполняться пайплайн. 'any' — любой Jenkins-агент. agent any // Общие опции конвейера options { // Добавляет метки времени в лог сборки timestamps() // Обрезает историю сборок, хранит только последние 20 buildDiscarder(logRotator(numToKeepStr: '20')) // Запрещает параллельные сборки одного job (полезно для локального демо) disableConcurrentBuilds() } // Переменные окружения для стадий environment { // Опции Maven: падать при ошибках тестов MAVEN_OPTS = '-Dmaven.test.failure.ignore=false' } // Триггеры запуска конвейера triggers { // Периодически проверяет SCM (репозиторий) на изменения каждые ~2 минуты pollSCM('H/2 * * * *') // Для продакшена лучше настраивать webhooks, но локально pollSCM удобнее. } stages { //Вставка stage('Fix Git Ownership') { steps { bat 'git config --global --add safe.directory E:/repos/java-maven-ci-demo.git' } } //Вставка конец stage('Checkout') { steps { // Извлечение кода из Git. Для локального демо используем file:// путь к bare-репозиторию. // Замените путь на ваш локальный (Windows/Linux). checkout([$class: 'GitSCM', branches: [[name: '*/${BRANCH_NAME ?: \"develop\"}']], userRemoteConfigs: [[url: 'file:///E:/repos/java-maven-ci-demo.git']] ]) // Примечание: BRANCH_NAME Jenkins подставляет для мультиветочных пайплайнов. // Для простого pipeline можно явно указать '*/main' или '*/develop'. } } stage('Build') { steps { // Проверка версии Maven bat 'mvn -v' // Компиляция проекта. Параметры: // -B: batch mode (без интерактивных вопросов) // -U: принудительно обновить снапшоты (на случай зависимостей) bat 'mvn -B -U clean compile' } } stage('Test') { steps { // Запуск модульных тестов (JUnit 5) и сбор покрытия JaCoCo bat 'mvn -B test' } post { // Действия после стадии Test always { // Публикация результатов JUnit (Surefire создаёт XML-отчёты в target/surefire-reports) junit '**/target/surefire-reports/*.xml' // Публикация HTML-отчёта JaCoCo (генерируется в target/site/jacoco/index.html) // Требуется плагин HTML Publibater в Jenkins. publibatHTML([reportDir: 'target/site/jacoco', reportFiles: 'index.html', reportName: 'JaCoCo Coverage']) } } } stage('Package') { steps { // Сборка исполняемого JAR. Артефакт будет в target/java-maven-ci-demo-1.0.0.jar bat 'mvn -B package' } post { success { // Архивирование собранных артефактов в Jenkins (видны в UI job) archiveArtifacts artifacts: 'target/*.jar', fingerprint: true } } } stage('Quality gates') { // Стадия качества включается только для веток develop и main when { anyOf { branch 'develop' branch 'main' } } steps { // Здесь можно подключить статический анализ: SpotBugs, Checkstyle, SonarQube. echo 'Quality checks placeholder: линтеры, статанализ, SonarQube и т.д.' } } stage('Deploy (local)') { // Условный «деплой»: выполняем только для main when { branch 'main' } steps { // Запуск приложения в фоне (nohup) и вывод логов в app.log // В учебных целях это имитация CD (continuous deployment). bat 'nohup java -jar target/java-maven-ci-demo-1.0.0.jar > app.log 2>&1 &' } } } // Глобальные действия после конвейера post { success { echo \"Build successful for ${env.BRANCH_NAME}\" } failure { echo \"Build failed for ${env.BRANCH_NAME}\" } } } Пример сценария работы «нескольких разработчиков» Как правильно работать: Работать нужно только внутри клона (E:\\work\\devA или E:\\work\\devB).Bare‑репозиторий (E:\\repos\\...) — это «сервер», туда только push, оттуда pull Скопируй исходники из E:\\java-maven-ci-demo в E:\\work\\devA: xcopy E:\\java-maven-ci-demo\\* E:\\work\\devA\\ /E /I (или просто перенести файлы вручную в проводнике). В E:\\work\\devA сделайте: git add . git commit -m \"Initial project with Maven, tests and Jenkins pipeline\" git push origin main Теперь bare‑репозиторий (E:\\repos\\...) будет содержать коммит, и E:\\work\\devB сможет его получить: cd E:\\work\\devB git pull origin main Разработчик А: Создаёт ветку от develop: git checkout -b feature/login Пишет код, тесты, коммитит: git commit -am \"Add login feature\" Пушит: git push origin feature/login Разработчик Б: Создаёт ветку: git checkout -b feature/profile Пишет код, тесты, пушит: git push origin feature/profile Интеграция: Делают merge feature‑веток в develop (локально через git merge или через UI, если есть Git‑сервис). Jenkins собирает develop, показывает отчёты тестов и покрытия. Релиз: Merge develop → main. Jenkins собирает main, архивирует JAR и выполняет локальный запуск приложения. Команды для локальной проверки без Jenkins Сборка: mvn -B -U clean compile Тесты: mvn -B test Пакет: mvn -B package Запуск JAR: java -jar target/java-maven-ci-demo-1.0.0.jar Роли инструментов Git: управление версиями, ветки, слияния, история, код‑ревью. Maven: компиляция, тесты, зависимости, плагины, жизненный цикл сборки. Jenkins: автоматический запуск пайплайна по событиям SCM, публикация артефактов и отчётов. CI/CD: непрерывная интеграция (каждое изменение проходит сборку и тесты), непрерывная доставка/развёртывание (автоматическое распространение успешных сборок). Работа с Jenkins: Пароль администратора из протокола установки (ниже, выделено красным), либо файла (у меня) c:\\Users\\Vitaiy\\.jenkins\\secrets\\ initialAdminPassword После установки и разблокирования сервиса должно быть что-то вроде окна ниже, в котором регистрируем пользователя: c:\\Program Files(x86)\\Jenkins>\"C:\\Program Files\\Java\\jdk-21\\bin\\java.exe\" -Dhudson.plugins.git.GitSCM.ALLOW_LOCAL_CHECKOUT=true -jar jenkins.war --httpPort=8080 Running from: C:\\Program Files(x86)\\Jenkins\\Jenkins.war webroot: C:\\Users\\Vitaiy\\.jenkins\\war 2025-11-16 22:28:46.606+0000 [id=1] INFO winstone.Logger#logInternal: Beginning extraction from war file 2025-11-16 22:28:48.079+0000 [id=1] WARNING o.e.j.ee9.nested.ContextHandler#setContextPath: Empty contextPath 2025-11-16 22:28:48.141+0000 [id=1] INFO org.eclipse.jetty.server.Server#doStart: jetty-12.0.25; built: 2025-08-11T23:52:37.219Z; git: a862b76d8372e24205765182d9ae1d1d333ce2ea; jvm 21.0.5+9-LTS-239 2025-11-16 22:28:49.012+0000 [id=1] INFO o.e.j.e.w.StandardDescriptorProcessor#visitServlet: NO JSP Support for /, did not find org.eclipse.jetty.ee9.jsp.JettyJspServlet 2025-11-16 22:28:49.083+0000 [id=1] INFO o.e.j.s.DefaultSessionIdManager#doStart: Session workerName=node0 2025-11-16 22:28:49.570+0000 [id=1] INFO hudson.WebAppMain#contextInitialized: Jenkins home directory: C:\\Users\\Vitaiy\\.jenkins found at: $user.home/.jenkins 2025-11-16 22:28:49.691+0000 [id=1] INFO o.e.j.s.handler.ContextHandler#doStart: Started oeje9n.ContextHandler$CoreContextHandler@540dbda9{Jenkins v2.528.1,/,b=file:///C:/Users/Vitaiy/.jenkins/war/,a=AVAILABLE,h=oeje9n.ContextHandler$CoreContextHandler$CoreToNestedHandler@22bb5646{STARTED}} 2025-11-16 22:28:49.723+0000 [id=1] INFO o.e.j.server.AbstractConnector#doStart: Started ServerConnector@597f48df{HTTP/1.1, (http/1.1)}{0.0.0.0:8080} 2025-11-16 22:28:49.738+0000 [id=1] INFO org.eclipse.jetty.server.Server#doStart: Started oejs.Server@63eef88a{STARTING}[12.0.25,sto=0] @3855ms 2025-11-16 22:28:49.738+0000 [id=35] INFO winstone.Logger#logInternal: Winstone Servlet Engine running: controlPort=disabled 2025-11-16 22:28:49.886+0000 [id=34] INFO jenkins.model.Jenkins#<init>: Starting version 2.528.1 2025-11-16 22:28:50.005+0000 [id=43] INFO jenkins.InitReactorRunner$1#onAttained: Started initialization 2025-11-16 22:28:50.018+0000 [id=43] INFO jenkins.InitReactorRunner$1#onAttained: Listed all plugins 2025-11-16 22:28:50.972+0000 [id=47] INFO jenkins.InitReactorRunner$1#onAttained: Prepared all plugins 2025-11-16 22:28:50.977+0000 [id=43] INFO jenkins.InitReactorRunner$1#onAttained: Started all plugins 2025-11-16 22:28:50.977+0000 [id=44] INFO jenkins.InitReactorRunner$1#onAttained: Augmented all extensions 2025-11-16 22:28:51.169+0000 [id=44] INFO jenkins.InitReactorRunner$1#onAttained: System config loaded 2025-11-16 22:28:51.169+0000 [id=44] INFO jenkins.InitReactorRunner$1#onAttained: System config adapted 2025-11-16 22:28:51.169+0000 [id=45] INFO jenkins.InitReactorRunner$1#onAttained: Loaded all jobs 2025-11-16 22:28:51.169+0000 [id=41] INFO jenkins.InitReactorRunner$1#onAttained: Configuration for all jobs updated 2025-11-16 22:28:51.247+0000 [id=62] INFO hudson.util.Retrier#start: Attempt #1 to do the action check updates server 2025-11-16 22:28:51.582+0000 [id=46] INFO jenkins.install.SetupWizard#init: [CRLF]> [CRLF]> ************************************************************* [CRLF]> ************************************************************* [CRLF]> ************************************************************* [CRLF]> [CRLF]> Jenkins initial setup is required. An admin user has been created and a password generated. [CRLF]> Please use the following password to proceed to installation: [CRLF]> [CRLF]> ca964ec3a3a7493da6f8b8a3decab47d [CRLF]> [CRLF]> This may also be found at: C:\\Users\\Vitaiy\\.jenkins\\secrets\\initialAdminPassword [CRLF]> [CRLF]> ************************************************************* [CRLF]> ************************************************************* [CRLF]> ************************************************************* Создать Job (Новый Item)🡪 Выбрать Pipeline Заполнить настройки Jenkins Job (Раздел: Общие настройки) Общие настройки (Общие настройки) Описание — можно указать кратко, например: Полный цикл CI/CD: Maven + JUnit + JaCoCo + Jenkins Pipeline Этот проект является параметрическим — ❌ не нужно включать (если не используешь параметры). Этот проект может быть запущен параллельно —можно включить, если хочешь запускать несколько сборок одновременно. Запретить удаление сборки —не обязательно. Установить ограничение сборки —можно включить и задать, например: хранить последние 20 сборок. Не сохранять логи сборки —не включать, иначе не увидишь консольный вывод и отчёты. Триггеры (Triggers) Включи \"Запускать при изменении SCM\" — Jenkins будет отслеживать изменения в Git‑репозитории. Можно включить \"Запускать периодически\" и задать cron‑выражение: H/5 * * * * # каждые 5 минут Остальные триггеры (после других проектов) —не нужны для одиночной демонстрации. Pipeline Definition → выбери: Pipeline script from SCM SCM → Git URL репозитория → укажи путь к твоему bare‑репо: file:///E:/repos/java-maven-ci-demo.git Ветка → укажи: */master (или */main, если использовать main как основную ветку) Script Path → укажи: Jenkinsfile Завершение Нажать \"Сохранить\" или \"Применить\" Перейти в проект → нажми \"Собрать сейчас\" (Build Now) После запуска Перейди в сборку → вкладка \"Консольный вывод\" Убедись, что стадии выполняются: Checkout Build Test Package Deploy Проверить тесты: JUnit → отчёты тестов JaCoCo Coverage → HTML‑отчёт покрытия Артефакты → собранный JAR",
      "wordCount": 1931,
      "uploadDate": "2026-01-30T14:36:18.267Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        261718,
        910866,
        807036,
        111763,
        30795,
        488751,
        254037,
        32474,
        42722,
        122408,
        574945,
        166580,
        16540,
        70064,
        87475,
        101071,
        392682,
        107253,
        8254,
        165936,
        1063648,
        463268,
        194019,
        562689,
        773962,
        260270,
        27226,
        141314,
        406340,
        118486,
        306669,
        82281,
        343058,
        150468,
        257753,
        27920,
        568363,
        92559,
        16714,
        457366,
        419335,
        366295,
        344423,
        62048,
        561062,
        236615,
        1436474,
        1575,
        681100,
        12464,
        240495,
        60352,
        115144,
        177015,
        190308,
        287773,
        209811,
        320989,
        171097,
        344638,
        133731,
        476782,
        185534,
        46854,
        261438,
        126907,
        2274,
        77584,
        240153,
        456266,
        200468,
        161336,
        358645,
        785178,
        201908,
        81193,
        67793,
        29788,
        626389,
        81934,
        78846,
        41943,
        65550,
        33453,
        446992,
        10874,
        69707,
        48608,
        241738,
        302799,
        250810,
        159196,
        708113,
        666523,
        51073,
        251282,
        428702,
        263875,
        27602,
        2170,
        112254,
        574305,
        206969,
        28836,
        364802,
        33028,
        807302,
        195019,
        69237,
        108526,
        44733,
        35249,
        98620,
        184927,
        503540,
        72003,
        193340,
        595300,
        70966,
        74270,
        321005,
        73872,
        550726,
        253489,
        62627,
        734809,
        220403,
        163190
      ],
      "shingleCount": 7972,
      "originalityPercent": 87
    },
    {
      "id": 59,
      "title": "4 Hibernate",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "4 Hibernate.docx",
      "filePath": "data/uploads/1769783811020_4_Hibernate.docx",
      "content": "Лабораторная работа №4 Управление персистентностью на основе JPA (hibernate) Перед написанием кода рассмотрим основные понятия, связанные с работой на основе спецификаций JPA. JPA (Java Persistence API) это спецификация, описывающая систему управления персистентными объектами, а также объясняющая, как java- объекты и таблицы реляционных баз данных можно связывать между собой. Таблицы БД и Java-объекты могут быть связаны между собой благодаря ORM (Object-Relational Mapping, “объектно-реляционное отображение”). Эта технология позволяет данные из БД превращать в объекты и наоборот. Персистентный объект – объект, который будет существовать даже после исполнения программы. Когда мы объявляем переменную в коде, она существует до тех пор, пока программа исполняется. Объекты базы данных же сохраняются и существуют даже после исполнения программы, они в нашем случае и являются персистентными объектами. Hibernate - одна из самых популярных открытых реализаций спецификации JPA. То есть JPA описывает правила, а Hibernate реализует их. Конфигурация на основе XML Создадим БД и добавим в нее таблицy developers: CREATE DATABASE hibernate; USE hibernate; CREATE TABLE developers ( `id` int PRIMARY KEY AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, `specialty` varchar(50) DEFAULT NULL, `experience` int DEFAULT NULL ) Создадим Maven-проект со следующей структурой: В pom.xml необходимо подключить необходимые для работы Hibernate зависимости: <dependencies> <dependency> <groupId>org.hibernate.orm</groupId> <artifactId>hibernate-core</artifactId> <version>6.6.1.Final</version> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <version>9.0.0</version> </dependency> </dependencies> Приступим к написанию Java-кода. Класс Developer package com.hibernate.xmlbased.model; public class Developer { private int id; private String name; private String specialty; private int experience; public Developer() { } public Developer(String name, String specialty, int experience) { this.name = name; this.specialty = specialty; this.experience = experience; } public int getId() { return id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void setId(int id) { this.id = id; } public String getSpecialty() { return specialty; } public void setSpecialty(String specialty) { this.specialty = specialty; } public int getExperience() { return experience; } public void setExperience(int experience) { this.experience = experience; } @Override public String toString() { return \"Developer [id=\" + id + \", name=\" + name + \", specialty=\" + specialty + \", experience=\" + experience + \"]\"; } } В данном pojo-классе (если просто говоря, plain old java object это самый “примитивный” класс, включающий в себя поля, сеттеры, геттеры, переопределение toString и т.д. и не отвечающий за сложную бизнес-логику) мы пишем поля, которые бы соответствовали столбцам созданной нами таблице в БД. POJO-классы, которые описывают столбцы таблицы базы данных, называются моделями. Так как в созданной таблице у нас есть id, name, specialty и experience, добавим соответствующие им поля в Java-класс. Сейчас этот класс и таблица в базе данных никак не связаны. Позже, когда мы перейдем к описанию xml-файлов, мы посмотрим, как связываются между собой данные из таблицы с данными в классе. Класс DeveloperDAO package com.hibernate.xmlbased.dao; import org.hibernate.cfg.Configuration; import com.hibernate.xmlbased.model.Developer; import java.util.List; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; public class DeveloperDAO { private final SessionFactory sessionFactory; private Session session; public DeveloperDAO() { sessionFactory = new Configuration().configure().buildSessionFactory(); } public void addDeveloper(Developer developer) { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); session.persist(developer); transaction.commit(); session.close(); } public Developer getDeveloperById(Integer id) { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); Developer developer = session.get(Developer.class, id); transaction.commit(); session.close(); return developer; } public List<Developer> getDevelopers() { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); List<Developer> developers = session.createQuery(\"FROM Developer\", Developer.class).list(); transaction.commit(); session.close(); return developers; } public Developer updateDeveloper(Integer id, Integer experience) { Session session = this.sessionFactory.openSession(); Transaction transaction = session.beginTransaction(); Developer developer = session.get(Developer.class, id); developer.setExperience(experience); transaction.commit(); session.close(); return developer; } public void removeDeveloper(Integer id) { Session session = this.sessionFactory.openSession(); Transaction transaction = session.beginTransaction(); Developer developer = session.get(Developer.class, id); session.remove(developer); transaction.commit(); session.close(); } } Для начала, давайте познакомимся с определением DAO. Data Access Object - это прослойка между базой данных и бизнес-логикой. В таком классе происходят CRUD (Create Read Update Delete) операции. Теперь обратим внимание на то, как происходит взаимодействие с БД. Если вы обратили внимание на код, то вы заметили, что каждый раз мы в начале операции открываем транзакцию методом beginTransaction(), а затем, когда делаем все необходимые операции, закрываем ее методом commit(). Зачем это делается? Обратимся к понятию транзакции. Транзакция — это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку [1]. Если проще говорить, объяснить этот концепт можно на принципе атомарности: контейнер содержимого транзакции будет либо выполняться полностью, либо не выполняться вообще. Подробнее об этом можно почитать в этой статье: https://habr.com/ru/articles/555920/ (Принцип Atomicity) Теперь, когда мы написали класс DAO и класс-модель, нам необходимо написать конфигурационные файлы, чтобы связать Java-классы с базой данных. hibernate.cfg.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE hibernate-configuration SYSTEM \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"hibernate.dialect\"> org.hibernate.dialect.MySQLDialect </property> <property name=\"hibernate.connection.driver_class\"> com.mysql.cj.jdbc.Driver </property> <property name=\"hibernate.connection.url\"> jdbc:mysql://localhost:3306/hibernate </property> <property name=\"hibernate.connection.username\"> YOUR_USERNAME_HERE (root by default) </property> <property name=\"hibernate.connection.password\"> YOUR_PASSWORD_HERE (root by default) </property> <property name=\"current_session_context_class\">thread</property> <property name=\"show_sql\">true</property> <mapping resource=\"Developer.hbm.xml\"/> </session-factory> </hibernate-configuration> Как только вставите этот кусок в свой код, убедитесь, что заменили оранжевые куски текста на свои данные. Если какая-либо из конфигураций вызывает у вас вопросы, можно обратиться к данной статье: https://proselyte.net/tutorials/hibernate-tutorial/configure/ В этом куске конфигурации наибольший интерес для нас представляет тег mapping. Благодаря ему мы будем указывать xml-мапперы, то есть файл, который будет рассказывать базе данных, как класс Developer.java, который мы написали, превращать в запись для базы данных и наоборот. Developer.hbm.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"> <hibernate-mapping> <class name=\"ctp.web.hibernatexml.model.Developer\" table=\"developers\"> <id name=\"id\" type=\"int\" column=\"ID\"> <generator class=\"native\"/> </id> <property name=\"name\" column=\"name\" type=\"string\"/> <property name=\"specialty\" column=\"specialty\" type=\"string\"/> <property name=\"experience\" column=\"experience\" type=\"int\"/> </class> </hibernate-mapping> Как уже было озвучено выше, этот файл объясняет Hibernate, как связать между собой таблицу developers и pojo-класс Developer. Рассмотрим теги [2]: <hibernate-mapping> - Это ключевой тег , который должен быть в каждом XML-mapping файле. Внутри этого тега мы и конфигурируем наши связи. <class> - используется для того, чтобы указать связь между POJO – классов и таблицей в БД. Имя класса указывается с помощью свойства name, имя таблицы в БД – с помощью свойства table. <id> - связывает уникальный идентификатор ID в POJO – классе и первичный ключ (primary key) в таблице БД. Свойство name соединяет поле класса со свойством column, которое указывает нам колонку в таблице БД. Свойство type определяет тип связывания (mapping) и используется для конфертации типа данных Java в тип данных SQL. <generator> - Этот тег внутри тега <id> используется для того, что генерировать первичные ключи автоматически. Если мы указываем это свойство native, как в примере, приведённом выше, то Hibernate сам выберет алгоритм (identity, hilo, sequence) в зависимости от возможностей БД. <property> - Мы используем этот тег для того, чтобы связать (map) конкретное поле POJO – класса с конкретной колонкой в таблице БД. Свойство name указывает поле в классе, в то время как свойство column указывает на колонку в таблице БД. Свойство type указывает тип связывания (mapping) и конвертирует тип данных Java в тип данных SQL. Теперь, когда все конфигурации настроены, можно написать main-класс и проверить работоспособность кода. Класс MainClass package com.hibernate.xmlbased; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import com.hibernate.xmlbased.dao.DeveloperDAO; import com.hibernate.xmlbased.model.Developer; public class MainClass { public static void main(String[] args) { List <Developer> developers = new ArrayList<>(Arrays.asList( new Developer(\"Igor\", \"Java Developer\", 2), new Developer(\"Alexander\", \"C++ Developer\", 4), new Developer(\"Ivan\", \"DevOps\", 3) )); DeveloperDAO developerDAO = new DeveloperDAO(); // Check add operation developerDAO.addDeveloper(developers.get(0)); developerDAO.addDeveloper(developers.get(1)); developerDAO.addDeveloper(developers.get(2)); // Print all devs developerDAO.getDevelopers().stream().forEach(System.out::println); // check getDeveloper System.out.println(developerDAO.getDeveloperById(2)); //update devs developerDAO.updateDeveloper(1, 5); developerDAO.removeDeveloper(2); developerDAO.getDevelopers().stream().forEach(System.out::println); } } Если вы решите перезапустить этот код, не забывайте о том, что каждый раз в базе данных будут создаваться новые повторные записи, а также может происходить обращение к несуществующим данных. В качестве практики, подумайте, как можно запретить добавление повторных записей в бд и как обработать ошибки, которые возникают при повторном запуске кода. Конфигурирование на основе аннотаций Скопируем написанный нами первый проект и сделаем несколько изменений, чтобы получить конфигурацию с использованием аннотаций. Во-первых, удалим файл Developer.hbm.xml и удалим строчку-маппер из hibernate.cfg.xml. Данный маппинг нам больше не понадобится, так как теперь мы будем связывать базу данных с классом-моделью с помощью аннотаций. Заходим в класс Developer и добавляем в него аннотации таким образом, чтобы после изменений он выглядел так: Класс Developer package com.hibernate.xmlbased.model; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; @Entity @Table (name = \"developers\") public class Developer { @Id @GeneratedValue (strategy = GenerationType.IDENTITY) @Column (name = \"id\") private int id; @Column (name = \"name\") private String name; @Column (name = \"specialty\") private String specialty; @Column (name = \"experience\") private int experience; public Developer() { } public Developer(String name, String specialty, int experience) { this.name = name; this.specialty = specialty; this.experience = experience; } public int getId() { return id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void setId(int id) { this.id = id; } public String getLastName() { return name; } public void setLastName(String lastName) { this.name = lastName; } public String getSpecialty() { return specialty; } public void setSpecialty(String specialty) { this.specialty = specialty; } public int getExperience() { return experience; } public void setExperience(int experience) { this.experience = experience; } @Override public String toString() { return \"Developer [id=\" + id + \", name=\" + name + \", specialty=\" + specialty + \", experience=\" + experience + \"]\"; } } Рассмотрим аннотации подробнее [3]: @Entity - указывает Hibernate, что данный класс является сущностью (entity bean). @Table - c помощью этой аннотации мы говорим Hibernate, с какой именно таблицей необходимо связать данный класс. @Id - С помощью этой аннотации мы указываем первичный ключ (Primary Key) @GeneratedValue - эта аннотация используется вместе с аннотацией @Id и определяет стратегию генерации ID. Всего стратегий генераций четыре: IDENTITY (полагается на автоматическое увеличение столбца по правилам, прописанным в БД), SEQUENCE (полагается на sequence, созданную в БД), TABLE (полагается на значение столбца таблицы БД) и AUTO (сам выбирает, какой способ используется) @Column - определяет к какому столбцу в таблице БД относится поле класса. Наиболее часто используемые атрибуты аннотации @Column такие: name (указывает имя столбца в таблице), unique (определяет, должно ли быть данное значение уникальным), nullable (определяет, может ли данное поле быть NULL, или нет). Теперь поменяем немного одну строчку из класса DeveloperDAO. Находим конструктор и заменяем его на этот: public DeveloperDAO() { sessionFactory = new Configuration().addAnnotatedClass(Developer.class). configure().buildSessionFactory(); } Если обратите внимание, теперь мы явно при конфигурации указываем классы, которые необходимо маппить. Теперь можем запускать код 🙂 HQL и Hibernate criteria Вновь скопируем написанный нами код в новый проект. Познакомимся с понятием HQL. В коде выше, когда мы делали выборку из всех сотрудников в методе findAllDevs, мы писали следующее: session.createQuery(\"FROM Developer\", Developer.class).list(); В метод createQuery мы писали HQL запрос. HQL - это технически тот же SQL, который переделали под Hibernate. Вместо названия таблицы, в запросе мы пишем имя класса, а слово SELECT опускаем. В целом, мы можем с помощью писать кастомные запросы, такие же, как мы писали бы на языке SQL. К примеру: session.createQuery(\"FROM Developer ORDER BY experience, Developer.class).list(); session.createQuery(\"FROM Developer WHERE name LIKE ‘%le%’, Developer.class).list(); Думаю, основную суть вы уловили). Теперь давайте познакомимся с JPA Criteria Queries. Criteria позволяет писать запросы, используя встроенные методы своего API вместо написания SQL (в нашем случае, HQL) запросов, таким образом поддерживая более программное написание запросов. Напишем класс DAO и на его примере рассмотрим принцип работы Criteria. Класс DeveloperDAO package com.hibernate.xmlbased.dao; import org.hibernate.cfg.Configuration; import com.hibernate.xmlbased.model.Developer; import jakarta.persistence.criteria.CriteriaBuilder; import jakarta.persistence.criteria.CriteriaDelete; import jakarta.persistence.criteria.CriteriaQuery; import jakarta.persistence.criteria.Root; import java.util.ArrayList; import java.util.List; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; public class DeveloperDAO { private final SessionFactory sessionFactory; private Session session; public DeveloperDAO() { sessionFactory = new Configuration().addAnnotatedClass(Developer.class).configure().buildSessionFactory(); } // найдем всех сотрудников public List<Developer> findAllDevs() { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaQuery<Developer> criteria = criteriaBuilder.createQuery(Developer.class); Root<Developer> devCriteria = criteria.from(Developer.class); List <Developer> developers = session.createQuery(criteria).getResultList(); transaction.commit(); session.close(); return developers; } // найти сотрудника по имени public Developer findByName(String name) { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaQuery<Developer> criteria = criteriaBuilder.createQuery(Developer.class); Root<Developer> devCriteria = criteria.from(Developer.class); criteria.where(criteriaBuilder.equal(devCriteria.get(\"name\"), name)); Developer developer = session.createQuery(criteria).getSingleResult(); transaction.commit(); session.close(); return developer; } // найти сотрудников, имя которого содержит подстроку public List<Developer> findByNameLike(String nameSubstr) { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaQuery<Developer> criteria = criteriaBuilder.createQuery(Developer.class); Root<Developer> devCriteria = criteria.from(Developer.class); criteria.where(criteriaBuilder.like(devCriteria.get(\"name\"), String.format(\"%%%s%%\", nameSubstr))); List<Developer> developers = session.createQuery(criteria).getResultList(); transaction.commit(); session.close(); return developers; } // найти сотрудников с опытом больше указанного значения, относящихся к специальностям public List<Developer> findByExperienceGreaterThanAndSpecialtyIn(Integer experience, ArrayList <String> specialties) { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaQuery<Developer> criteria = criteriaBuilder.createQuery(Developer.class); Root<Developer> devCriteria = criteria.from(Developer.class); criteria.where(criteriaBuilder.and(criteriaBuilder. gt(devCriteria.get(\"experience\"), experience), devCriteria.get(\"specialty\").in(specialties))); List<Developer> developers = session.createQuery(criteria).getResultList(); transaction.commit(); session.close(); return developers; } // удалить сотрудника по имени public void deleteDevByName(String name) { session = sessionFactory.getCurrentSession(); Transaction transaction = session.beginTransaction(); CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaDelete<Developer> criteria = criteriaBuilder.createCriteriaDelete(Developer.class); Root<Developer> devCriteria = criteria.from(Developer.class); criteria.where(criteriaBuilder.equal(devCriteria.get(\"name\"), name)); session.createMutationQuery(criteria).executeUpdate(); transaction.commit(); session.close(); } } Изучим куски кода конфигурации CriteriaBuilder подробнее. CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaQuery<Developer> criteria = criteriaBuilder.createQuery(Developer.class); Root<Developer> devCriteria = criteria.from(Developer.class); Вот это все, по сути, очень замысловатая настройка, в которой мы сначала получаем билдер критерии, затем создаем CriteriaQuery (CriteriaQuery отвечает за создание select-запросов) для необходимого для нас типа данных. В конце мы создаем рут, который соответствует данному нами типу данных. И только после этой настройки мы можем начать собирать наши запросы. Если сварился мозг, не волнуйтесь, так и должно быть. Давайте посмотрим, как мы строим запросы в разных методах. Для начала, посмотрим на findAllDevs, который делает выборку из всех сотрудников: List <Developer> developers = session.createQuery(criteria).getResultList() Так как для критерии мы не определили никаких дополнительных параметров, выполняется запрос FROM Developer. А как тогда определяются запросы с определенными параметрами? Давайте обратимся к классу findByNameLike, который находит всех сотрудников, содержащих переданную подстроку. criteria.select(devCriteria).where(criteriaBuilder.like(devCriteria.get(\"name\"), String .format(\"%%%s%%\", nameSubstr))); List<Developer> developers = session.createQuery(criteria).getResultList(); Как мы можем посмотреть, в первой строке мы строим запрос, который выглядит как SELECT * FROM Developer WHERE name LIKE ‘%name%’. И сейчас мы это наглядно продемонстрируем: where = WHERE criteriaBuilder.like = LIKE devCriteria.get(\"name\") = name String.format(\"%%%s%%\", nameSubstr))) = ‘%name%’ Во второй строке, соответственно, мы получаем результат созданного нами запроса. В зависимости от того, ожидаем ли мы один результат или несколько, в конце мы будем прописывать getResultList() либо getSingleResult(). Теперь давайте посмотрим на класс findByExperienceGreaterThanAndSpecialtyIn, который берет сотрудников, которые входят в переданный список специальностей с опытом больше чем указанный. На языке HQL этот запрос выглядит так: FROM Developer WHERE Developer.experience > experience AND Developer.specialty IN specialties. Это - сложный запрос с несколькими параметрами для фильтра поиска. criteria.where(criteriaBuilder.and(criteriaBuilder.gt(devCriteria.get(\"experience\"), experience), devCriteria.get(\"specialty\").in(specialty))) Во-первых, мы вызываем CriteriaBuilder. Все, что будет находится внутри этого метода, будет перечисляться через логическое И. Внутри метода and() мы отдельно написали кусок запроса на проверку опыта разработчика: criteriaBuilder.gt(devCriteria.get(\"experience\"), experience), после чего написали проверку на то, что выбранные программисты относятся к указанным специальностям: devCriteria.get(\"specialty\").in(specialty). Давайте рассмотрим вопрос операций манипуляции данными. На примере удаления по имени мы продемонстрируем, что Criteria поддерживает возможность не только делать выборку из данных, но и изменять их. Напишем функцию, которая удаляет разраба по его имени. CriteriaDelete<Developer> criteria = criteriaBuilder.createCriteriaDelete(Developer.class); … criteria.where(criteriaBuilder.equal(devCriteria.get(\"name\"), name)); session.createMutationQuery(criteria).executeUpdate(); Теперь мы используем не CriteriaQuery, а CriteriaDelete для операции удаления. Дальше запрос строится точно также, как в селекте. В последней строке мы исполняем собранный запрос. Давайте проверять наши труды на практике! Класс MainClass package com.hibernate.xmlbased; import java.util.ArrayList; import java.util.Arrays; import com.hibernate.xmlbased.dao.DeveloperDAO; public class MainClass { public static void main(String[] args) { DeveloperDAO developerDAO = new DeveloperDAO(); developerDAO.findAllDevs().stream().forEach(System.out::println); System.out.println(developerDAO.findByName(\"Ivan\")); developerDAO.findByNameLike(\"ya\").stream().forEach(System.out::println); developerDAO.findByExperienceGreaterThanAndSpecialtyIn(1, new ArrayList<>(Arrays.asList(\"C++ Developer\", \"Java Developer\"))). stream().forEach(System.out::println); developerDAO.deleteDevByName(\"Ivan\"); developerDAO.findAllDevs().stream().forEach(System.out::println); } } Если у вас остались вопросы по теме Criteria, эти две статьи могут помочь дополнить уже полученные знания: https://www.baeldung.com/hibernate-criteria-queries https://javarush.com/quests/lectures/questhibernate.level16.lecture00 Отношения между таблицами; Проблема n+1; Типы извлечения данных Как мы знаем, обычно в базе данных находится не одна таблица, а несколько связанных между собой таблиц, которые могут находится в следующих отношениях: один ко многим, или один к одному (многие ко многим в БД обычно связываются третьей таблицей). Если вам необходимо освежить память, данная статья в помощь: https://habr.com/ru/articles/488054/ Давайте создадим проект, в котором будут три связанные таблицы: developers, departments, users. Создадим БД: DBinitialize.sql CREATE DATABASE it_department; USE it_department; CREATE TABLE departments ( department_id CHAR(3) PRIMARY KEY CHECK (LENGTH(department_id) = 3), department_name VARCHAR(100) NOT NULL UNIQUE, location TEXT NOT NULL ); INSERT INTO departments (department_id, department_name, location) VALUES ('A01', 'Инженеры', 'rondo Daszyńskiego 1, 00-843 Warszawa'), ('A07', 'Тестировщики', 'rondo Daszyńskiego 1, 00-843 Warszawa'), ('B04', 'Очень умные человеки', 'J.E. Irausquin Boulevard 20-A Oranjestad, Aruba'); CREATE TABLE developers ( id int PRIMARY KEY AUTO_INCREMENT, name varchar(50) DEFAULT NULL, specialty varchar(50) DEFAULT NULL, experience int DEFAULT NULL, department_id CHAR(3) REFERENCES departments(department_id) ); CREATE TABLE users ( user_id INT PRIMARY KEY, username VARCHAR(30) NOT NULL UNIQUE, password VARCHAR(30) NOT NULL, user_role ENUM('ROLE_ADMIN', 'ROLE_USER') NOT NULL, FOREIGN KEY (user_id) REFERENCES developers(id) ); INSERT INTO developers (name, specialty, experience, department_id) VALUES ('Это я', 'Студент', 1, 'B04'), ('Владимир', 'Java-dev', 5, 'B04'), ('Серый', 'Scrum-мастер', 3, 'A01'); INSERT INTO users VALUES (1, 'admin', 'admin', 'ROLE_ADMIN'), (2, 'user', 'user', 'ROLE_USER'); Благодаря этой диаграмме вам проще будет разобраться, в каких отношениях находятся таблицы: Создадим проект со следующей структурой (Не забудьте в pom.xml записать необходимые зависимости, они все такие же, как и в прошлых проектах): hibernate.cfg.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE hibernate-configuration SYSTEM \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"hibernate.dialect\"> org.hibernate.dialect.MySQLDialect </property> <property name=\"hibernate.connection.driver_class\"> com.mysql.cj.jdbc.Driver </property> <property name=\"hibernate.connection.url\"> jdbc:mysql://localhost:3306/it_department </property> <property name=\"hibernate.connection.username\"> YOUR_USERNAME_HERE (root by default) </property> <property name=\"hibernate.connection.password\"> YOUR_PASSWORD_HERE (root by default) </property> <property name=\"current_session_context_class\">thread</property> <property name=\"show_sql\">true</property> </session-factory> </hibernate-configuration> Приступим к написанию кода. Классы-модели Класс Department package com.hibernate.xmlbased.model; import java.util.List; import java.util.Objects; import jakarta.persistence.CascadeType; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.FetchType; import jakarta.persistence.Id; import jakarta.persistence.OneToMany; import jakarta.persistence.Table; @Entity @Table(name = \"departments\") public class Department { @Id @Column(name = \"department_id\", length = 3) private String departmentId; @Column(name = \"department_name\", unique = true, nullable = false, length = 100) private String departmentName; @Column(name = \"location\", nullable = false) private String location; @OneToMany(mappedBy = \"department\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Developer> developers; public Department(String departmentId, String departmentName, String location) { this.departmentId = departmentId; this.departmentName = departmentName; this.location = location; } public List<Developer> getDevelopers() { return developers; } public void setDevelopers(List<Developer> developers) { this.developers = developers; } public Department() { } public String getDepartmentId() { return departmentId; } public void setDepartmentId(String departmentId) { this.departmentId = departmentId; } public String getDepartmentName() { return departmentName; } public void setDepartmentName(String departmentName) { this.departmentName = departmentName; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } @Override public String toString() { return \"Department [departmentId=\" + departmentId + \", departmentName=\" + departmentName + \", location=\" + location + \"]\"; } @Override public int hashCode() { return Objects.hash(departmentId, departmentName, location); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Department other = (Department) obj; return Objects.equals(departmentId, other.departmentId) && Objects.equals(departmentName, other.departmentName) && Objects.equals(location, other.location); } } Давайте на примере этой модели рассмотрим новые аннотации и их параметры. @OneToMany(mappedBy = \"department\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Developer> developers; Если мы обратимся к SQL-запросу, то заметим, что в таблице Department нет ни намека на существование сотрудников, однако здесь у нас есть массив с разработчиками. Дело в том, что при связывании моделей между собой желательно (но не обязательно) поддерживать двустороннюю связь. Если бы нам в коде ни разу не пришлось бы обращаться к разработчикам отделов, мы могли бы настроить связь только с одной стороны, то есть в модели Developer. В параметре mappedBy мы указываем имя поля в классе, из которого связываем модели (см. код Developer.java). Дальше настраиваем каскадирование. Если объяснять просто, каскадирование описывает поведение связанных таблиц при изменении записи (например, должны ли мы удалять все связанные записи или просто оставлять значения в NULL при удалении связанного значения). Отдельного внимания заслуживает FetchType. Его существует два типа: Lazy и Eager. Рассмотрим на примере: Представьте себе ситуацию, когда у вас есть приложение, которое работает с книгами и авторами. Каждый автор может написать несколько книг. Но есть случаи, когда вам нужно получить информацию только об авторе, без деталей о его книгах. В этом случае LAZY подходит идеально, поскольку он позволяет избежать ненужного извлечения данных о книгах [4]. То есть Hibernate не будет подгружать данные, если они нам не понадобятся. В случае же с Eager, данные автоматически будут загружаться, когда из бд информация будет записываться в экземпляр класса-модели. Немного позднее мы рассмотрим, как же мы можем при необходимости подгружать значения, если они не загружаются по умолчанию. Заметим, что аннотации ManyToOne и OneToOne загружают информацию по умолчанию Eager (если мы явно не укажем FetchType.LAZY), так как загрузить сразу связанную запись будет быстрее, чем потом подгружать ее снова. Аннотации OneToMany и ManyToMany имеют по умолчанию ленивую загрузку данных, так как подгружать целый список ресурсозатратно. Класс Developer package com.hibernate.xmlbased.model; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.FetchType; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.JoinColumn; import jakarta.persistence.ManyToOne; import jakarta.persistence.Table; @Entity @Table (name = \"developers\") public class Developer { @Id @GeneratedValue (strategy = GenerationType.IDENTITY) @Column (name = \"id\") private int id; @Column (name = \"name\") private String name; @Column (name = \"specialty\") private String specialty; @Column (name = \"experience\") private int experience; @ManyToOne (fetch = FetchType.EAGER) @JoinColumn(name = \"department_id\", nullable = false) private Department department; public Developer() {} public Developer(String name, String specialty, int experience, Department department) { this.name = name; this.specialty = specialty; this.experience = experience; this.department = department; } public int getId() { return id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void setId(int id) { this.id = id; } public String getSpecialty() { return specialty; } public void setSpecialty(String specialty) { this.specialty = specialty; } public int getExperience() { return experience; } public void setExperience(int experience) { this.experience = experience; } @Override public String toString() { return \"Developer [id=\" + id + \", name=\" + name + \", specialty=\" + specialty + \", experience=\" + experience + \"]\"; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } } Как мы можем увидеть, тут реализована двухсторонняя связанность: @ManyToOne (fetch = FetchType.EAGER) @JoinColumn(name = \"department_id\", nullable = false) private Department department; C помощью JoinColumn мы определяем ассоциативную связь с помощью Foreign Key. Относитесь к ней как к аннотации Column, но вытаскиваем мы не значение из текущей таблицы, а запись, которая связана с ней. Возможно, эти примеры помогут лучше понять эту идею: https://stackoverflow.com/questions/37542208/what-is-joincolumn-and-how-it-is-used-in-hibernate Заметим, что мы могли бы (но не сделали из-за того, что users.user_id=developers.id, из-за чего мы легко можем достать пользователя по ID разработчика) также настроить двухстороннюю связь вместе с моделью User с отношением OneToOne. Класс User @Entity @Table(name = \"users\") public class User { @Id @Column(name = \"user_id\") private int userId; @OneToOne (fetch = FetchType.LAZY) @MapsId @JoinColumn(name = \"user_id\") private Developer developer; @Column(name = \"username\", nullable = false, unique = true, length = 30) private String username; @Column(name = \"password\", nullable = false, length = 30) private String password; @Enumerated(EnumType.STRING) @Column(name = \"user_role\", nullable = false) private Role userRole; @Override public String toString() { return \"User [userId=\" + userId + \", username=\" + username + \", password=\" + password + \", userRole=\" + userRole + \"]\"; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public Developer getDeveloper() { return developer; } public void setDeveloper(Developer developer) { this.developer = developer; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Role getUserRole() { return userRole; } public void setUserRole(Role userRole) { this.userRole = userRole; } public User(int userId, String username, String password) { this.userId = userId; this.username = username; this.password = password; this.userRole = Role.ROLE_USER; } public User() { } } Enum Role package com.hibernate.xmlbased.model; public enum Role { ROLE_ADMIN(\"ROLE_ADMIN\"), ROLE_USER(\"ROLE_USER\"); private String role; Role(String role) { this.role = role; } public String getRole() { return role; } } В оригинальной таблице users.user_id=developers.id - и связаны они как один к одному. Так, как ID пользователя использует ID разработчика, мы указываем аннотацию @MapsId. Аннотация @Enumerated(EnumType.STRING) используется для Enum-ов. Конфигурация Сессий в отдельном файле package com.hibernate.xmlbased.config; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; import com.hibernate.xmlbased.model.Department; import com.hibernate.xmlbased.model.Developer; import com.hibernate.xmlbased.model.User; public class SessionConfig { private static SessionConfig sc; final SessionFactory sessionFactory; private SessionConfig() { sessionFactory = new Configuration(). addAnnotatedClass(User.class). addAnnotatedClass(Developer.class). addAnnotatedClass(Department.class). configure().buildSessionFactory(); } public SessionFactory getSessionFactory() { return sessionFactory; } public static SessionConfig getInstanceOfSeccionFactory() { if (sc == null) sc = new SessionConfig(); return sc; } } Так как каждый DAO-класс требует свою настройку, при чем все DAO-классы так или иначе взаимодействуют со всеми таблицами, мы сделаем один файл с конфигурацией, которая содержит все классы модели. Также мы реализуем паттерн синглтон, так как нам необходим только один экземпляр данного класса. Через точку мы можем добавлять сколь угодно классов-моделей. Классы DAO Класс DepartmentDAO package com.hibernate.xmlbased.dao; import java.util.HashSet; import java.util.List; import java.util.Set; import org.hibernate.Hibernate; import org.hibernate.Session; import org.hibernate.Transaction; import com.hibernate.xmlbased.config.SessionConfig; import com.hibernate.xmlbased.model.Department; import com.hibernate.xmlbased.model.Developer; public class DepartmentDAO { private SessionConfig sc; public DepartmentDAO() { sc = SessionConfig.getInstanceOfSeccionFactory(); } public List<Department> getDepartments() { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); List <Department> deps = session.createQuery(\"FROM Department\", Department.class).getResultList(); transaction.commit(); session.close(); return deps; } // этот кусок кода решает проблему n+1 public Set<Department> getDepartmentWithWorkers() { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Set<Department> departments = new HashSet<>(session.createQuery(\"FROM Department d LEFT JOIN FETCH d.developers\", Department.class).getResultList()); transaction.commit(); session.close(); return departments; } public List<Developer> getDevelopersByDepartment(Department department){ Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Department dep = session.get(Department.class, department.getDepartmentId()); Hibernate.initialize(dep.getDevelopers()); List<Developer> devs = dep.getDevelopers(); transaction.commit(); session.close(); return devs; } public Department findDepartmentByID(String departmentID) { // ЗАДАНИЕ } public Department addDepartament(Department dep) { // ЗАДАНИЕ } public void deleteDepartment(String ID) { // ЗАДАНИЕ } } Обратите внимание на класс, помеченный комментарием “решает проблему n+1”. Что такое проблема n+1? Дело в том, что когда мы будем обращаться к связанной таблице, мы будем делать n запросов, чтобы вытащить из нее данные. Проще объяснить на примере. Пускай мы хотим получить всех авторов (их будет 10) с их книгами. Если мы не решаем проблему n+1, сначала мы вытащим авторов первым запросом, а потом для каждого автора будем делать запрос на получение всех его книг, то есть 10 запросов (SELECT * FROM books WHERE author_id = n) где n в нашем случае принадлежит промежутку от 1 до 10. Эту проблему мы решаем этой строчкой: Set<Department> departments = new HashSet<>(session.createQuery(\"FROM Department d LEFT JOIN FETCH d.developers\", Department.class).getResultList()); Здесь мы сразу делаем джоин и получаем селект с джоином - одну таблицу. Если мы запишем эти значения в List, то мы получим что-то очень похожее на то, что выйдет при соединении таблиц в запросе, однако это будет избыточностью данных (можете проверить сами и посмотреть, что произойдет). Чтобы предотвратить избыточность данных, мы используем сет. Теперь, если мы рассмотрим все тот же пример с авторами книг, мы получим одним запросом сет, в котором одному автору соответствует несколько книг. Класс DeveloperDAO package com.hibernate.xmlbased.dao; import java.util.List; import org.hibernate.Session; import org.hibernate.Transaction; import com.hibernate.xmlbased.config.SessionConfig; import com.hibernate.xmlbased.model.Department; import com.hibernate.xmlbased.model.Developer; import jakarta.persistence.criteria.CriteriaBuilder; import jakarta.persistence.criteria.CriteriaQuery; import jakarta.persistence.criteria.Root; public class DeveloperDAO { private SessionConfig sc; public DeveloperDAO() { sc = SessionConfig.getInstanceOfSeccionFactory(); } public void addDeveloper(Developer developer) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); session.persist(developer); transaction.commit(); session.close(); } public Developer getDeveloperById(Integer id) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Developer developer = session.get(Developer.class, id); transaction.commit(); session.close(); return developer; } public List<Developer> getDevelopers() { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); List<Developer> developers = session.createQuery(\"FROM Developer\", Developer.class).list(); transaction.commit(); session.close(); return developers; } public Developer updateDevelopersDepartment(Integer devId, Department department) { // ЗАДАНИЕ } public void removeDeveloper(Integer id) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); Developer developer = session.get(Developer.class, id); session.remove(developer); transaction.commit(); session.close(); } Класс UserDAO package com.hibernate.xmlbased.dao; import java.util.List; import org.hibernate.Hibernate; import org.hibernate.Session; import org.hibernate.Transaction; import com.hibernate.xmlbased.config.SessionConfig; import com.hibernate.xmlbased.model.User; import jakarta.persistence.NoResultException; import jakarta.persistence.criteria.CriteriaBuilder; import jakarta.persistence.criteria.CriteriaQuery; import jakarta.persistence.criteria.Root; public class UserDAO { private SessionConfig sc; public UserDAO() { sc = SessionConfig.getInstanceOfSeccionFactory(); } public User AuthUser(String username, String password) throws NoResultException { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); try { CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); CriteriaQuery<User> criteria = criteriaBuilder.createQuery(User.class); Root<User> devCriteria = criteria.from(User.class); criteria.where(criteriaBuilder.and(criteriaBuilder.equal(devCriteria.get(\"username\"), username), criteriaBuilder.equal(devCriteria.get(\"password\"), password))); User user = session.createQuery(criteria).getSingleResult(); Hibernate.initialize(user.getDeveloper()); return user; } finally { transaction.commit(); session.close(); } } public void updatePassword(Integer id, String password) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); try { session.createMutationQuery(String.format(\"update User u SET password = '%s' WHERE userId = %d\", password, id)).executeUpdate(); } catch (Exception ex) { throw ex; } finally { transaction.commit(); session.close(); } } public User getDeveloperById(Integer id) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); User developer = session.get(User.class, id); transaction.commit(); session.close(); return developer; } public List<User> getUsers() { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); List<User> users = session.createQuery(\"FROM User\", User.class).getResultList(); transaction.commit(); session.close(); return users; } public User getUserByUsername(String username) throws NoResultException { // ЗАДАНИЕ } public User addUser(User user) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); session.merge(user); transaction.commit(); session.close(); return user; } public User getUserByID(Integer ID) { Session session = sc.getSessionFactory().getCurrentSession(); Transaction transaction = session.beginTransaction(); User user = session.find(User.class, ID); transaction.commit(); session.close(); return user; } } Классы-меню Класс Menu package com.hibernate.xmlbased.menu; import java.util.Scanner; import com.hibernate.xmlbased.dao.DepartmentDAO; import com.hibernate.xmlbased.dao.DeveloperDAO; import com.hibernate.xmlbased.dao.UserDAO; import com.hibernate.xmlbased.model.User; public class Menu { User authUser; Scanner in = new Scanner(System.in); static DeveloperDAO developerDAO = new DeveloperDAO(); static UserDAO userDAO = new UserDAO(); static DepartmentDAO departmentDAO = new DepartmentDAO(); public void menu(User authUser) { this.authUser = authUser; System.out.printf(\"\\nHi, %s. Your role: %s\\n\", authUser.getDeveloper().getName(), authUser.getUserRole().getRole()); } } Класс AdminMenu public class AdminMenu extends Menu { public void menu(User authUser) { super.menu(authUser); while (true) { String options = null; System.out.println(\"0. Выход\"); System.out.println(\"1. Посмотреть все департаменты и их сотрудников\"); System.out.println(\"2. Найти департамент по ID (ЗАДАНИЕ)\"); System.out.println(\"3. Добавить департамент (ЗАДАНИЕ)\"); System.out.println(\"4. Перевести сотрудника в новый департамент (ЗАДАНИЕ)\"); System.out.println(\"5. Удалить департмент (Внимание! Удаляет также связанных сотрудников) (ЗАДАНИЕ)\"); System.out.println(\"6. Найти сотрудника по ID\"); System.out.println(\"7. Добавить сотрудника\"); System.out.println(\"8. Удалить сотрудника\"); System.out.println(\"9. Получить список юзеров\"); System.out.println(\"10. Найти юзера по никнейму (ЗАДАНИЕ)\"); System.out.println(\"11. Добавить аккаунт сотруднику\"); System.out.println(\"12. Удалить юзера\"); // 13-15. Написать три SELECT-а с использованием HQL или Criteria для любых таблиц try { System.out.print(\"Ввод: \"); options = in.nextLine(); switch (options) { case \"0\": return; case \"1\": seeAllWorkers(); break; case \"2\": findDepartmentByID(); break; case \"3\": addDepartament(); break; case \"4\": relocateDeveloper(); break; case \"5\": deleteDepartment(); break; case \"6\": findDeveloperByID(); break; case \"7\": addDeveloper(); break; case \"8\": deleteDeveloper(); break; case \"9\": getUsers(); break; case \"10\": getUserByUsername(); break; case \"11\": addUser(); break; case \"12\": deleteUser(); break; default: System.out.println(\"\\nНеверный ввод.\"); } } catch (Exception ex) { System.out.println(ex.getMessage()); } } } public void seeAllWorkers() { Set<Department> departments = departmentDAO.getDepartmentWithWorkers(); for (Department department : departments) { System.out.println(department); List<Developer> devs = department.getDevelopers(); for (Developer dev : devs) { System.out.println(\"\\t\" + dev); } } } public void findDepartmentByID() { System.out.print(\"Введите ID департамента: \"); String depID = in.nextLine(); System.out.println(departmentDAO.findDepartmentByID(depID)); } public void addDepartament() { Scanner scan = new Scanner(System.in); System.out.print(\"Введите ID департамента: \"); String depID = scan.nextLine(); if (depID.length() != 3) { throw new IllegalArgumentException(\"ID департамента должен быть длиной в три символа.\"); } System.out.print(\"Введите название департамента: \"); String departmentName = scan.nextLine(); System.out.print(\"Введите адрес департамента: \"); String location = scan.nextLine(); Department dep = new Department(depID, departmentName, location); if (departmentDAO.addDepartament(dep) == dep) { System.out.println(\"Департамент успешно добавлен.\"); } else { System.out.println(\"Возникла ошибка добавления.\"); } } public void relocateDeveloper() { System.out.print(\"Введите ID сотрудника: \"); Integer devID = Integer.valueOf(in.nextLine()); Developer dev = developerDAO.getDeveloperById(devID); if (dev == null) { throw new NullPointerException(\"Сотрудник не найден\"); } System.out.print(\"Введите ID департамента: \"); String depID = in.nextLine(); Department department = departmentDAO.findDepartmentByID(depID); developerDAO.updateDevelopersDepartment(devID, department); System.out.println(\"Сотрудник переведен в новый департамент\"); } private void deleteDepartment() { System.out.print(\"Введите ID департамента: \"); String depID = in.nextLine(); departmentDAO.deleteDepartment(depID); System.out.println(\"Департамент удален.\"); } private void findDeveloperByID() { System.out.print(\"Введите ID работника: \"); Integer devID = Integer.valueOf(in.nextLine()); Developer developer = developerDAO.getDeveloperById(devID); if (developer == null) { throw new NullPointerException(\"Сотрудник не найден\"); } System.out.println(developer); } private void addDeveloper() { System.out.print(\"Введите имя работника: \"); String name = in.nextLine(); System.out.print(\"Введите специализацию работника: \"); String specialty = in.nextLine(); System.out.print(\"Введите опыт работника: \"); Integer experience = Integer.valueOf(in.nextLine()); for (Department department : departmentDAO.getDepartments()) { System.out.println(department); } System.out.print(\"Введите ID департамента работника: \"); String depID = in.nextLine(); Department department = departmentDAO.findDepartmentByID(depID); Developer dev = new Developer(name, specialty, experience, department); developerDAO.addDeveloper(dev); System.out.println(\"Сотрудник успешно добавлен\"); } private void deleteDeveloper() { System.out.print(\"Введите ID сотрудника: \"); Integer devID = Integer.valueOf(in.nextLine()); Developer dev = developerDAO.getDeveloperById(devID); if (dev == null) { throw new NullPointerException(\"Сотрудник не найден\"); } developerDAO.removeDeveloper(devID); System.out.println(\"Разработчик успешно удален\"); } private void getUsers() { List<User> users = userDAO.getUsers(); for (User user : users) { System.out.println(user); } } private void getUserByUsername() { System.out.print(\"Введите username: \"); String username = in.nextLine(); System.out.println(userDAO.getUserByUsername(username)); } private void addUser() { seeAllWorkers(); System.out.print(\"Введите ID сотрудника, для которого мы добавляем аккаунт: \"); Integer devID = Integer.valueOf(in.nextLine()); if (developerDAO.getDeveloperById(devID) == null) { throw new NullPointerException(\"Сотрудник не найден\"); } System.out.print(\"Введите username: \"); String username = in.nextLine(); System.out.print(\"Введите password: \"); String password = in.nextLine(); System.out.println(\"Юзер \" + userDAO.addUser(new User(devID, username, password)) + \" успешно добавлен\"); } private void deleteUser() { System.out.print(\"Введите ID аккаунта: \"); Integer userID = Integer.valueOf(in.nextLine()); if (userDAO.getUserByID(userID) == null) { throw new NullPointerException(\"Юзер не найден\"); } developerDAO.removeDeveloper(userID); System.out.println(\"Разработчик успешно удален\"); } private void findDepartmentByLetterInID() { System.out.print(\"Введите первый символ из ID департамента: \"); String charID = in.nextLine(); if (charID.length() != 1) { throw new NullPointerException(\"Это не один символ\"); } System.out.println(departmentDAO.findDepartmentByLetterInID(charID.charAt(0))); } private void findByExperienceEqual() { System.out.print(\"Введите опыт работы: \"); Integer experience = Integer.valueOf(in.nextLine()); List<Developer> devs = developerDAO.findByExperienceEqual(experience); if (devs.isEmpty()) { throw new NullPointerException(\"Сотрудников с таким опытом работы не найдено\"); } else { for (Developer dev: devs) { System.out.println(dev); } } } private void findByExperienceEqualCriteria() { System.out.print(\"Введите опыт работы: \"); Integer experience = Integer.valueOf(in.nextLine()); List<Developer> devs = developerDAO.findByExperienceEqualCriteria(experience); if (devs.isEmpty()) { throw new NullPointerException(\"Сотрудников с таким опытом работы не найдено\");} else{ for (Developer dev: devs) { System.out.println(dev); } } } } Класс UserMenu public class UserMenu extends Menu { public void menu(User authUser) { super.menu(authUser); Integer options = null; System.out.println(\"0. Выход\"); System.out.println(\"1. Информация по моему департаменту\"); System.out.println(\"2. Получить список моих коллег\"); System.out.println(\"3. Сменить мой пароль\"); while (true) { try { System.out.print(\"Ввод: \"); options = in.nextLine(); switch (options) { case”0”: return; case “1”: getMyDepartment(authUser); break; case “2”: getMyPals(authUser); break; case “3”: updatePassword(authUser); break; default: System.out.println(\"Invalid input.\"); } } catch (Exception e) { System.out.println(e.getMessage()); } } } public void updatePassword(User user) { System.out.print(\"Input new password: \"); String password = in.nextLine(); try { userDAO.updatePassword(user.getUserId(), password); } catch (Exception ex) { System.out.println(\"Some error occured: \" + ex.getMessage()); return; } } public void getMyDepartment(User user) { System.out.println(\"Your department: \" + user.getDeveloper().getDepartment()); } public void getMyPals(User user) { departmentDAO.getDevelopersByDepartment(user.getDeveloper().getDepartment()).stream() .forEach(System.out::println); } } MainClass package com.hibernate.xmlbased; import java.util.Scanner; import com.hibernate.xmlbased.dao.UserDAO; import com.hibernate.xmlbased.menu.AdminMenu; import com.hibernate.xmlbased.menu.Menu; import com.hibernate.xmlbased.menu.UserMenu; import com.hibernate.xmlbased.model.User; import jakarta.persistence.NoResultException; public class MainClass { static UserDAO userDAO = new UserDAO(); public static void main(String[] args) { Scanner in = new Scanner(System.in); Menu menu = null; while (true){ System.out.print(\"Username:\"); String username = in.nextLine(); System.out.print(\"Password:\"); String password = in.nextLine(); User user; try { user = userDAO.AuthUser(username, password); } catch(NoResultException ex) { System.out.println(\"Bad credentials\"); continue; } switch(user.getUserRole()) { case ROLE_ADMIN: menu = new AdminMenu(); break; case ROLE_USER: menu = new UserMenu(); break; } menu.menu(user); break; } } } Задания (все задания находятся в разделе “Отношения между таблицами”): Дописать код где указано. Написать свои три селекта по любым таблицам Ссылки на источники: [1] Что такое транзакция: https://habr.com/ru/articles/537594/ [2] Руководство по Hibernate. Соединяющие файлы https://proselyte.net/tutorials/hibernate-tutorial/mapping-files/ [3] Руководство по Hibernate. Аннотации. https://proselyte.net/tutorials/hibernate-tutorial/annotations/ [4] Разница между FetchType LAZY и EAGER в Java Persistence API https://sky.pro/media/raznicza-mezhdu-fetchtype-lazy-i-eager-v-java-persistence-api/",
      "wordCount": 5744,
      "uploadDate": "2026-01-30T14:36:51.121Z",
      "category": "coursework",
      "status": "final",
      "userId": "31810079",
      "institution": "БГУИР",
      "minhashSignature": [
        487885,
        423375,
        214367,
        65691,
        189858,
        333170,
        175700,
        32474,
        149980,
        3783,
        179328,
        29609,
        93567,
        208704,
        37379,
        10237,
        140278,
        69716,
        275365,
        99793,
        49372,
        54539,
        91694,
        41365,
        139330,
        416592,
        66773,
        141314,
        68217,
        71811,
        209950,
        26557,
        97703,
        171240,
        32785,
        291923,
        196844,
        391713,
        5072,
        46667,
        409317,
        206183,
        36658,
        62048,
        200297,
        48075,
        624346,
        1575,
        346573,
        12464,
        84404,
        158419,
        31985,
        36331,
        251881,
        35737,
        33387,
        37758,
        82250,
        329147,
        172363,
        53725,
        122991,
        17053,
        22375,
        123545,
        17621,
        53173,
        222264,
        240949,
        222090,
        161555,
        13049,
        296922,
        35237,
        104103,
        127379,
        18750,
        25207,
        104581,
        763359,
        53068,
        65550,
        389716,
        47064,
        10874,
        28734,
        129394,
        201150,
        104376,
        6810,
        32841,
        351548,
        67318,
        84529,
        119660,
        243751,
        306390,
        166850,
        82541,
        59815,
        19088,
        204076,
        124391,
        338776,
        7003,
        346281,
        47919,
        56862,
        25173,
        300649,
        119348,
        222464,
        7940,
        50060,
        56123,
        1231,
        211494,
        12127,
        68578,
        195826,
        117086,
        98237,
        18237,
        40799,
        31667,
        53574,
        37535
      ],
      "shingleCount": 12436,
      "originalityPercent": 77
    },
    {
      "id": 60,
      "title": "rdy",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "rdy.docx",
      "filePath": "data/uploads/1770205169974_rdy.docx",
      "content": "Гант-диаграмма управления проектом Самый значимый рабочий факап В рамках развития при переходе на cross-platform стратегию мы столкнулись с серьёзным срывом сроков: одновременный запуск MacOS и Android MVP привёл к перегрузке команды, затягиванию релизов и росту технического долга. Изначально roadmap предполагал параллельную разработку обеих платформ, чтобы быстрее выйти на новый рынок, но не были заложены буферы на интеграцию, синхронизацию дизайн-системы и QA. Что произошло Перегрузка команды: разработчики работали над двумя MVP одновременно, что снижало качество кода и скорость ревью. Разные сроки готовности компонентов: MacOS был почти готов, когда Android отставал на 2–3 недели; при этом общий launch планировали на одну дату. Оголение QA: QA были подключены поздно и не успевали покрыть регресс на обеих платформах. Стресс и демотивация: из-за постоянных переработок и давления сроков часть команды начала выгорать. Как решал Пересмотр roadmap: разнесли релизы — сначала MacOS (он был ближе к готовности), затем Android с учётом уроков MacOS. Усиление процесса: внедрил и улучшил документацию (Notion) и онбординг новых сотрудников, что ускорило итерации и снизило зависимость от людей. Ежедневные standups и синхронизация: более плотная коммуникация с dev, design и QA, чтобы вовремя ловить блокеры и сдвигать приоритеты. Упор на MVP: сознательно урезали scope первого релиза до «must-have», чтобы не гнаться за полным feature parity с iOS. Ретроспектива с командой: провели сессию, чтобы выявить причины срыва и согласовать новые нормы планирования. В итоге MacOS и Android были запущены с задержкой, но без критических багов и без полного выгорания команды. После этого cross-platform expansion продолжилась уже в более управляемом режиме. Как предотвратил бы в будущем Буферы в оценках: всегда закладывать 20–30% времени на непредвиденное (интеграции, дефекты, внешние зависимости). Последовательные релизы вместо параллельных: при ограниченной команде не ставить два крупных MVP на одну дату; делать по одному фокусу за раз. Раннее подключение QA: вовлекать QA уже на этапе проектирования и первых спринтов, а не перед релизом. Честные риски в roadmap: явно помечать риски и зависимости в Gantt/Notion и обсуждать их со стейкхолдерами. Мониторинг загрузки команды: отслеживать burnout-сигналы (переработки, качество ревью, скорость закрытия задач) и при необходимости пересматривать сроки, а не «дожимать» людей.",
      "wordCount": 337,
      "uploadDate": "2026-02-04T11:39:30.012Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        743260,
        2102917,
        720344,
        513112,
        2511619,
        53090,
        101639,
        584846,
        142348,
        1234457,
        239984,
        740439,
        1016604,
        292191,
        1251758,
        3669523,
        5212047,
        1518078,
        1097520,
        182272,
        901203,
        445251,
        724792,
        425078,
        176606,
        544391,
        348000,
        141314,
        673166,
        1655051,
        938081,
        662328,
        2563567,
        18489,
        330882,
        398997,
        128606,
        152983,
        1882318,
        6733404,
        877186,
        1612006,
        338436,
        95321,
        1301957,
        1114959,
        175920,
        1275768,
        4633480,
        989742,
        1715453,
        95140,
        148049,
        1816641,
        153600,
        4168335,
        3951002,
        839295,
        1768969,
        471783,
        1009598,
        450933,
        274282,
        1792462,
        346719,
        126907,
        1073294,
        172699,
        1351574,
        747477,
        443879,
        5022637,
        744863,
        720451,
        35237,
        571507,
        127379,
        1167137,
        3114781,
        104581,
        317186,
        117229,
        1764354,
        1415399,
        209907,
        374295,
        84538,
        1884078,
        1238105,
        328949,
        676177,
        269738,
        1001567,
        897835,
        128544,
        446160,
        426772,
        113098,
        27602,
        849303,
        1257194,
        976098,
        663491,
        286153,
        753519,
        486117,
        518210,
        891214,
        682310,
        3557260,
        247407,
        151173,
        522062,
        494487,
        1099031,
        1087347,
        259513,
        499569,
        2039786,
        1093427,
        532839,
        415834,
        680918,
        1984584,
        151666,
        325748,
        1051745,
        37535
      ],
      "shingleCount": 1971,
      "originalityPercent": 92
    },
    {
      "id": 61,
      "title": "rdy",
      "author": "Ханцевич Андрей Андреевич",
      "filename": "rdy.docx",
      "filePath": "data/uploads/1770235050154_rdy.docx",
      "content": "Гант-диаграмма управления проектом Самый значимый рабочий факап В рамках развития при переходе на cross-platform стратегию мы столкнулись с серьёзным срывом сроков: одновременный запуск MacOS и Android MVP привёл к перегрузке команды, затягиванию релизов и росту технического долга. Изначально roadmap предполагал параллельную разработку обеих платформ, чтобы быстрее выйти на новый рынок, но не были заложены буферы на интеграцию, синхронизацию дизайн-системы и QA. Что произошло Перегрузка команды: разработчики работали над двумя MVP одновременно, что снижало качество кода и скорость ревью. Разные сроки готовности компонентов: MacOS был почти готов, когда Android отставал на 2–3 недели; при этом общий launch планировали на одну дату. Оголение QA: QA были подключены поздно и не успевали покрыть регресс на обеих платформах. Стресс и демотивация: из-за постоянных переработок и давления сроков часть команды начала выгорать. Как решал Пересмотр roadmap: разнесли релизы — сначала MacOS (он был ближе к готовности), затем Android с учётом уроков MacOS. Усиление процесса: внедрил и улучшил документацию (Notion) и онбординг новых сотрудников, что ускорило итерации и снизило зависимость от людей. Ежедневные standups и синхронизация: более плотная коммуникация с dev, design и QA, чтобы вовремя ловить блокеры и сдвигать приоритеты. Упор на MVP: сознательно урезали scope первого релиза до «must-have», чтобы не гнаться за полным feature parity с iOS. Ретроспектива с командой: провели сессию, чтобы выявить причины срыва и согласовать новые нормы планирования. В итоге MacOS и Android были запущены с задержкой, но без критических багов и без полного выгорания команды. После этого cross-platform expansion продолжилась уже в более управляемом режиме. Как предотвратил бы в будущем Буферы в оценках: всегда закладывать 20–30% времени на непредвиденное (интеграции, дефекты, внешние зависимости). Последовательные релизы вместо параллельных: при ограниченной команде не ставить два крупных MVP на одну дату; делать по одному фокусу за раз. Раннее подключение QA: вовлекать QA уже на этапе проектирования и первых спринтов, а не перед релизом. Честные риски в roadmap: явно помечать риски и зависимости в Gantt/Notion и обсуждать их со стейкхолдерами. Мониторинг загрузки команды: отслеживать burnout-сигналы (переработки, качество ревью, скорость закрытия задач) и при необходимости пересматривать сроки, а не «дожимать» людей.",
      "wordCount": 337,
      "uploadDate": "2026-02-04T19:57:30.175Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        743260,
        2102917,
        720344,
        513112,
        2511619,
        53090,
        101639,
        584846,
        142348,
        1234457,
        239984,
        740439,
        1016604,
        292191,
        1251758,
        3669523,
        5212047,
        1518078,
        1097520,
        182272,
        901203,
        445251,
        724792,
        425078,
        176606,
        544391,
        348000,
        141314,
        673166,
        1655051,
        938081,
        662328,
        2563567,
        18489,
        330882,
        398997,
        128606,
        152983,
        1882318,
        6733404,
        877186,
        1612006,
        338436,
        95321,
        1301957,
        1114959,
        175920,
        1275768,
        4633480,
        989742,
        1715453,
        95140,
        148049,
        1816641,
        153600,
        4168335,
        3951002,
        839295,
        1768969,
        471783,
        1009598,
        450933,
        274282,
        1792462,
        346719,
        126907,
        1073294,
        172699,
        1351574,
        747477,
        443879,
        5022637,
        744863,
        720451,
        35237,
        571507,
        127379,
        1167137,
        3114781,
        104581,
        317186,
        117229,
        1764354,
        1415399,
        209907,
        374295,
        84538,
        1884078,
        1238105,
        328949,
        676177,
        269738,
        1001567,
        897835,
        128544,
        446160,
        426772,
        113098,
        27602,
        849303,
        1257194,
        976098,
        663491,
        286153,
        753519,
        486117,
        518210,
        891214,
        682310,
        3557260,
        247407,
        151173,
        522062,
        494487,
        1099031,
        1087347,
        259513,
        499569,
        2039786,
        1093427,
        532839,
        415834,
        680918,
        1984584,
        151666,
        325748,
        1051745,
        37535
      ],
      "shingleCount": 1971,
      "originalityPercent": 0
    },
    {
      "id": 64,
      "title": "ЛР1",
      "author": "fewfw",
      "filename": "ЛР1.docx",
      "filePath": "data/uploads/1770646779506_ЛР1.docx",
      "content": "Министерство образования Республики Беларусь Учреждение образования БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ Факультет компьютерного проектирования Кафедра проектирования информационно-компьютерных систем Дисциплина Разработка программных приложений для бизнес-анализа ОТЧЕТ по лабораторной работе №1 на тему: «ВВЕДЕНИЕ В МОДУЛЬНОЕ ТЕСТИРОВАНИЕ» Проверил: _____________________ (подпись) Косарева Е. М. магистр, ассистент кафедры ПИКС Выполнил: _____________________ (подпись) Ханцевич А.А. гр. 314302 Минск, 2025 Цель работы: Получение практических навыков разработки автоматизированных тестов для проверки корректности работы функций на примере расчёта заработной платы. Краткое описание задания: Вариант №14: Проверка текста на спам. 1. Разработайте функцию, которая принимает строку (текст сообщения) и список запрещенных слов. Функция возвращает процент «спама» (отношение количества запрещенных слов к общему количеству слов в тексте). 2. Учтите обработку ошибок: текст не должен быть пустым. Если слов в тексте нет, процент спама равен 0. 3. Проверьте текст без спама, текст, состоящий только из спама, и проверку регистра слов (например, «Spam» и «spam» должны считаться одинаково). 3. Основная часть 3.1 Подготовка рабочей среды Установлена IDE Visual Studio Code. Установлен Node.js (версия 18+). Инициализирован Git-репозиторий и настроены глобальные параметры. Установлен Jest: npm install --save-dev jest Добавлен скрипт запуска тестов в package.json: \"scripts\": { \"test\": \"jest\" } 3.2 Реализация функции window.checkSpam = function(text, forbiddenWords) { window._lastText = text; window._lastForbiddenWords = forbiddenWords; return checkSpam(text, forbiddenWords); }; window.testSpam = function(text, forbiddenWords) { console.log('=== Автоматическая проверка данных ==='); console.log('Текст:', text); console.log('Запрещенные слова:', forbiddenWords); console.log(''); try { const result = checkSpam(text, forbiddenWords); console.log('✅ Результат:', result + '%'); if (result === 0) { console.log('📝 Текст не содержит спама'); } else if (result === 100) { console.log('⚠️ Текст полностью состоит из спама'); } else { console.log('⚠️ Текст содержит частичный спам'); } return result; } catch (error) { console.error('❌ Ошибка:', error.message); return null; } }; window.runAllTests = function(text, forbiddenWords) { if (!text || !forbiddenWords) { if (window._lastText && window._lastForbiddenWords) { text = window._lastText; forbiddenWords = window._lastForbiddenWords; console.log('Используются последние данные из checkSpam:'); console.log('Текст:', text); console.log('Запрещенные слова:', forbiddenWords); console.log(''); } else { console.error('❌ Ошибка: Укажите текст и список запрещенных слов'); console.log('Использование: runAllTests(\"ваш текст\", [\"спам\", \"реклама\"])'); console.log('Или сначала вызовите: checkSpam(\"текст\", [\"спам\"])'); return; } } console.log('=== Запуск всех тестовых сценариев для вашего текста ==='); console.log('Текст:', text); console.log('Запрещенные слова:', forbiddenWords); console.log(''); let testNumber = 1; let passed = 0; let failed = 0; const result = checkSpam(text, forbiddenWords); const words = text.toLowerCase().split(/\\s+/).map(w => w.replace(/[.,!?;:()\\[\\]{}'\"]/g, '')).filter(w => w.length > 0); const forbiddenWordsLower = forbiddenWords.map(w => typeof w === 'string' ? w.toLowerCase() : String(w).toLowerCase()); const spamWords = words.filter(w => forbiddenWordsLower.includes(w)); 3.3 Разработка модульных тестов function checkSpam(text, forbiddenWords) { if (!text || typeof text !== 'string' || text.trim().length === 0) { throw new Error('Текст не должен быть пустым'); } if (!Array.isArray(forbiddenWords)) { throw new Error('Список запрещенных слов должен быть массивом'); } if (forbiddenWords.length === 0) { return 0; } const words = text .toLowerCase() .split(/\\s+/) .map(word => word.replace(/[.,!?;:()\\[\\]{}'\"]/g, '')) .filter(word => word.length > 0); if (words.length === 0) { return 0; } const forbiddenWordsLower = forbiddenWords.map(word => typeof word === 'string' ? word.toLowerCase() : String(word).toLowerCase() ); let spamCount = 0; words.forEach(word => { if (forbiddenWordsLower.includes(word)) { spamCount++; } }); const spamPercentage = (spamCount / words.length) * 100; return Math.round(spamPercentage * 100) / 100; } window.checkSpam = function(text, forbiddenWords) { window._lastText = text; window._lastForbiddenWords = forbiddenWords; return checkSpam(text, forbiddenWords); }; 3.4 Запуск тестов Позитивные сценарии Тест 1: Текст без спама - НЕ ПРОШЕЛ (25%) Тест 2: Текст полностью из спама - НЕ ПРОШЕЛ (25%) Тест 3: Частичный спам - ПРОШЕЛ (25%) Тест 4: Проверка регистра (есть заглавные буквы) - ПРОШЕЛ Тест 5: Текст с знаками препинания - ПРОШЕЛ Тест 6: Множественные вхождения - пропущен (нет повторений) Негативные сценарии Тест 7: Обработка пустого текста - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 8: Обработка текста только из пробелов - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 9: Обработка null - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 10: Обработка undefined - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 11: Обработка некорректного типа списка - ПРОШЕЛ (ошибка: Список запрещенных слов должен быть массивом) Граничные значения Тест 12: Текст без слов - пропущен (есть слова) Тест 13: Пустой список запрещенных слов - пропущен (список не пуст) Тест 14: Текст из одного слова (не спам) - пропущен Тест 15: Текст из одного слова (спам) - пропущен Тест 16: Очень длинный текст - пропущен (4 слов, нужно > 100) ⚠️ Тест 17: Текст с множественными пробелами - пропущен Тест 18: Текст с переносами строк - пропущен Тест 19: Текст с табуляциями - пропущен Итоги Пройдено: 8 Провалено: 2 Всего тестов: 18 Процент спама в вашем тексте: 25% Всего слов: 4 Запрещенных слов найдено: 1 4. ВЫВОДЫ Реализована функция calculateWages для расчёта заработной платы с учётом сверхурочных. Добавлена проверка входных данных: отрицательные значения, некорректные типы и превышение максимума часов. Созданы модульные тесты с использованием Jest для проверки корректной работы функции и реакции на ошибки. Все тесты прошли успешно, что подтверждает правильность реализации и устойчивость функции к ошибкам. Заключение: лабораторная работа позволила закрепить навыки разработки чистых функций, обработки исключений, модульного тестирования с Jest и работы с Git.",
      "wordCount": 817,
      "uploadDate": "2026-02-09T14:19:39.536Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        161658,
        1719169,
        608273,
        63569,
        1425255,
        53090,
        1732829,
        1053015,
        692487,
        99217,
        2520982,
        10919,
        609360,
        188219,
        68923,
        441402,
        1428707,
        784025,
        1656395,
        1238386,
        49372,
        693932,
        91694,
        573483,
        17857,
        938508,
        1241610,
        141314,
        647844,
        326667,
        174017,
        32104,
        516797,
        236009,
        257753,
        398997,
        478377,
        114669,
        1150836,
        492077,
        1844794,
        383870,
        1647099,
        127195,
        127579,
        941159,
        1528510,
        13355,
        895726,
        1411444,
        197435,
        720156,
        122638,
        177015,
        588275,
        204574,
        319540,
        262764,
        381019,
        1184094,
        172363,
        194200,
        302885,
        425987,
        638119,
        303420,
        478195,
        1597012,
        395779,
        1304449,
        459915,
        681622,
        1292679,
        4509,
        643639,
        104103,
        540565,
        1167137,
        711117,
        151169,
        287698,
        117229,
        106677,
        763173,
        102984,
        10874,
        256416,
        408333,
        492977,
        151986,
        250810,
        1689718,
        566898,
        2762899,
        141961,
        446160,
        725352,
        204617,
        667790,
        171660,
        1671407,
        496839,
        2150632,
        416810,
        1493692,
        131782,
        304871,
        292910,
        1316124,
        754976,
        77127,
        1412901,
        369106,
        1790924,
        50060,
        418406,
        1665916,
        211494,
        171427,
        1903980,
        151466,
        117086,
        529285,
        568017,
        446802,
        2549736,
        1109484,
        298605
      ],
      "shingleCount": 2867
    },
    {
      "id": 66,
      "title": "ЛР1",
      "author": "fewfw",
      "filename": "ЛР1.docx",
      "filePath": "data/uploads/1770646795852_ЛР1.docx",
      "content": "Министерство образования Республики Беларусь Учреждение образования БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ Факультет компьютерного проектирования Кафедра проектирования информационно-компьютерных систем Дисциплина Разработка программных приложений для бизнес-анализа ОТЧЕТ по лабораторной работе №1 на тему: «ВВЕДЕНИЕ В МОДУЛЬНОЕ ТЕСТИРОВАНИЕ» Проверил: _____________________ (подпись) Косарева Е. М. магистр, ассистент кафедры ПИКС Выполнил: _____________________ (подпись) Ханцевич А.А. гр. 314302 Минск, 2025 Цель работы: Получение практических навыков разработки автоматизированных тестов для проверки корректности работы функций на примере расчёта заработной платы. Краткое описание задания: Вариант №14: Проверка текста на спам. 1. Разработайте функцию, которая принимает строку (текст сообщения) и список запрещенных слов. Функция возвращает процент «спама» (отношение количества запрещенных слов к общему количеству слов в тексте). 2. Учтите обработку ошибок: текст не должен быть пустым. Если слов в тексте нет, процент спама равен 0. 3. Проверьте текст без спама, текст, состоящий только из спама, и проверку регистра слов (например, «Spam» и «spam» должны считаться одинаково). 3. Основная часть 3.1 Подготовка рабочей среды Установлена IDE Visual Studio Code. Установлен Node.js (версия 18+). Инициализирован Git-репозиторий и настроены глобальные параметры. Установлен Jest: npm install --save-dev jest Добавлен скрипт запуска тестов в package.json: \"scripts\": { \"test\": \"jest\" } 3.2 Реализация функции window.checkSpam = function(text, forbiddenWords) { window._lastText = text; window._lastForbiddenWords = forbiddenWords; return checkSpam(text, forbiddenWords); }; window.testSpam = function(text, forbiddenWords) { console.log('=== Автоматическая проверка данных ==='); console.log('Текст:', text); console.log('Запрещенные слова:', forbiddenWords); console.log(''); try { const result = checkSpam(text, forbiddenWords); console.log('✅ Результат:', result + '%'); if (result === 0) { console.log('📝 Текст не содержит спама'); } else if (result === 100) { console.log('⚠️ Текст полностью состоит из спама'); } else { console.log('⚠️ Текст содержит частичный спам'); } return result; } catch (error) { console.error('❌ Ошибка:', error.message); return null; } }; window.runAllTests = function(text, forbiddenWords) { if (!text || !forbiddenWords) { if (window._lastText && window._lastForbiddenWords) { text = window._lastText; forbiddenWords = window._lastForbiddenWords; console.log('Используются последние данные из checkSpam:'); console.log('Текст:', text); console.log('Запрещенные слова:', forbiddenWords); console.log(''); } else { console.error('❌ Ошибка: Укажите текст и список запрещенных слов'); console.log('Использование: runAllTests(\"ваш текст\", [\"спам\", \"реклама\"])'); console.log('Или сначала вызовите: checkSpam(\"текст\", [\"спам\"])'); return; } } console.log('=== Запуск всех тестовых сценариев для вашего текста ==='); console.log('Текст:', text); console.log('Запрещенные слова:', forbiddenWords); console.log(''); let testNumber = 1; let passed = 0; let failed = 0; const result = checkSpam(text, forbiddenWords); const words = text.toLowerCase().split(/\\s+/).map(w => w.replace(/[.,!?;:()\\[\\]{}'\"]/g, '')).filter(w => w.length > 0); const forbiddenWordsLower = forbiddenWords.map(w => typeof w === 'string' ? w.toLowerCase() : String(w).toLowerCase()); const spamWords = words.filter(w => forbiddenWordsLower.includes(w)); 3.3 Разработка модульных тестов function checkSpam(text, forbiddenWords) { if (!text || typeof text !== 'string' || text.trim().length === 0) { throw new Error('Текст не должен быть пустым'); } if (!Array.isArray(forbiddenWords)) { throw new Error('Список запрещенных слов должен быть массивом'); } if (forbiddenWords.length === 0) { return 0; } const words = text .toLowerCase() .split(/\\s+/) .map(word => word.replace(/[.,!?;:()\\[\\]{}'\"]/g, '')) .filter(word => word.length > 0); if (words.length === 0) { return 0; } const forbiddenWordsLower = forbiddenWords.map(word => typeof word === 'string' ? word.toLowerCase() : String(word).toLowerCase() ); let spamCount = 0; words.forEach(word => { if (forbiddenWordsLower.includes(word)) { spamCount++; } }); const spamPercentage = (spamCount / words.length) * 100; return Math.round(spamPercentage * 100) / 100; } window.checkSpam = function(text, forbiddenWords) { window._lastText = text; window._lastForbiddenWords = forbiddenWords; return checkSpam(text, forbiddenWords); }; 3.4 Запуск тестов Позитивные сценарии Тест 1: Текст без спама - НЕ ПРОШЕЛ (25%) Тест 2: Текст полностью из спама - НЕ ПРОШЕЛ (25%) Тест 3: Частичный спам - ПРОШЕЛ (25%) Тест 4: Проверка регистра (есть заглавные буквы) - ПРОШЕЛ Тест 5: Текст с знаками препинания - ПРОШЕЛ Тест 6: Множественные вхождения - пропущен (нет повторений) Негативные сценарии Тест 7: Обработка пустого текста - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 8: Обработка текста только из пробелов - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 9: Обработка null - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 10: Обработка undefined - ПРОШЕЛ (ошибка: Текст не должен быть пустым) Тест 11: Обработка некорректного типа списка - ПРОШЕЛ (ошибка: Список запрещенных слов должен быть массивом) Граничные значения Тест 12: Текст без слов - пропущен (есть слова) Тест 13: Пустой список запрещенных слов - пропущен (список не пуст) Тест 14: Текст из одного слова (не спам) - пропущен Тест 15: Текст из одного слова (спам) - пропущен Тест 16: Очень длинный текст - пропущен (4 слов, нужно > 100) ⚠️ Тест 17: Текст с множественными пробелами - пропущен Тест 18: Текст с переносами строк - пропущен Тест 19: Текст с табуляциями - пропущен Итоги Пройдено: 8 Провалено: 2 Всего тестов: 18 Процент спама в вашем тексте: 25% Всего слов: 4 Запрещенных слов найдено: 1 4. ВЫВОДЫ Реализована функция calculateWages для расчёта заработной платы с учётом сверхурочных. Добавлена проверка входных данных: отрицательные значения, некорректные типы и превышение максимума часов. Созданы модульные тесты с использованием Jest для проверки корректной работы функции и реакции на ошибки. Все тесты прошли успешно, что подтверждает правильность реализации и устойчивость функции к ошибкам. Заключение: лабораторная работа позволила закрепить навыки разработки чистых функций, обработки исключений, модульного тестирования с Jest и работы с Git.",
      "wordCount": 817,
      "uploadDate": "2026-02-09T14:19:55.889Z",
      "category": "coursework",
      "status": "final",
      "userId": "student",
      "institution": "БГУИР",
      "minhashSignature": [
        161658,
        1719169,
        608273,
        63569,
        1425255,
        53090,
        1732829,
        1053015,
        692487,
        99217,
        2520982,
        10919,
        609360,
        188219,
        68923,
        441402,
        1428707,
        784025,
        1656395,
        1238386,
        49372,
        693932,
        91694,
        573483,
        17857,
        938508,
        1241610,
        141314,
        647844,
        326667,
        174017,
        32104,
        516797,
        236009,
        257753,
        398997,
        478377,
        114669,
        1150836,
        492077,
        1844794,
        383870,
        1647099,
        127195,
        127579,
        941159,
        1528510,
        13355,
        895726,
        1411444,
        197435,
        720156,
        122638,
        177015,
        588275,
        204574,
        319540,
        262764,
        381019,
        1184094,
        172363,
        194200,
        302885,
        425987,
        638119,
        303420,
        478195,
        1597012,
        395779,
        1304449,
        459915,
        681622,
        1292679,
        4509,
        643639,
        104103,
        540565,
        1167137,
        711117,
        151169,
        287698,
        117229,
        106677,
        763173,
        102984,
        10874,
        256416,
        408333,
        492977,
        151986,
        250810,
        1689718,
        566898,
        2762899,
        141961,
        446160,
        725352,
        204617,
        667790,
        171660,
        1671407,
        496839,
        2150632,
        416810,
        1493692,
        131782,
        304871,
        292910,
        1316124,
        754976,
        77127,
        1412901,
        369106,
        1790924,
        50060,
        418406,
        1665916,
        211494,
        171427,
        1903980,
        151466,
        117086,
        529285,
        568017,
        446802,
        2549736,
        1109484,
        298605
      ],
      "shingleCount": 2867
    }
  ]
}